#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\textcontainer.cpp"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\textcontainer.h"
#pragma once
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#pragma once
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#pragma once

#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths_func.h"
#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"










#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















    
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    
    

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
            
        

#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"













#pragma once







































































































































#line 151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





























#line 185 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





#line 196 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 200 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






























#line 1586 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
























#line 1611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"












#line 1624 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































#line 1663 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"















































































































#line 1775 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































































































#line 1878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








































































































































































#line 2047 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





































































































#line 2149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



















































































































































































































#line 2361 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
extern "C" {




#line 2367 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



































































































































































































































#line 2595 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









































































































































































































































#line 2868 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









#line 2878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


    
    
#line 2883 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2890 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2891 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2899 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 2911 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

































#line 2945 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






















}
#line 2969 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
















































































































































































































































#line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"



#line 269 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















































































#line 352 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


}
#line 356 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"

#line 358 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
#line 2971 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef unsigned int uintptr_t;
    #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    


#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"





#line 54 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
    
    
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"











#line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

    

    
    
    




































#line 116 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


} 
#line 120 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } 

    





#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

#pragma pack(pop)
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    



    





















#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


















    

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 113 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    

#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    





#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"







#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
    
#line 149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    


#line 167 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
        
    

#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"










    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#line 202 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



    
#line 217 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 225 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    
        
    

#line 238 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 243 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 245 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 257 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
    





#line 275 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 280 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
    


#line 288 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 289 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"









    void __cdecl __security_init_cookie(void);

    
        void __fastcall __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    


#line 307 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 308 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

} __pragma(pack(pop))

#line 320 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {









    

#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
        
    

#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"




    
#line 36 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    

#line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
        
    

#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 50 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    
#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"





#line 64 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



    


#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"













    


        
    #line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 96 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    
#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    
#line 110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"










    
#line 153 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



















    

#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
        
    #line 177 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    
#line 186 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"









    











        
    #line 209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 210 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    
#line 214 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    
        
    

#line 221 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 222 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
















    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 246 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    
        

    













#line 277 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 278 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
















#line 295 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


        


    #line 304 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 305 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"









    






        
    #line 323 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 324 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


        
    #line 331 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 332 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"













#line 350 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"















#line 366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"





    
#line 373 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    

#line 382 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 383 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


        


            
        #line 393 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    #line 394 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 395 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 399 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"





#line 405 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


        



    #line 415 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 416 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    
        
    



#line 425 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

    
        
              
        

#line 442 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    



#line 447 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

    
        
    



#line 455 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

    
        
    



#line 463 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 464 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 508 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



#line 512 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 519 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 520 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



    
#line 525 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 529 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 705 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 706 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"












































































    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1781 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 1971 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
    #line 1972 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"
#line 1973 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))

#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

__pragma(pack(push, 8)) extern "C" {

#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 




    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 47 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"
    #line 48 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"
#line 49 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"










#line 60 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 63 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"
#line 84 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"


    
#line 88 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"


















































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 460 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    

          __declspec(dllimport) int  __cdecl _set_SSE2_enable(  int _Flag);

    #line 587 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

    










#line 600 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"




#line 605 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"



    










#line 620 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl acosf(  float _X)
        {
            return (float)acos(_X);
        }

          __inline float __cdecl asinf(  float _X)
        {
            return (float)asin(_X);
        }

          __inline float __cdecl atan2f(  float _Y,   float _X)
        {
            return (float)atan2(_Y, _X);
        }

          __inline float __cdecl atanf(  float _X)
        {
            return (float)atan(_X);
        }

          __inline float __cdecl ceilf(  float _X)
        {
            return (float)ceil(_X);
        }

          __inline float __cdecl cosf(  float _X)
        {
            return (float)cos(_X);
        }

          __inline float __cdecl coshf(  float _X)
        {
            return (float)cosh(_X);
        }

          __inline float __cdecl expf(  float _X)
        {
            return (float)exp(_X);
        }

    #line 662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

    



#line 668 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

    




#line 682 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl floorf(  float _X)
        {
            return (float)floor(_X);
        }

          __inline float __cdecl fmodf(  float _X,   float _Y)
        {
            return (float)fmod(_X, _Y);
        }

    #line 694 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    











#line 723 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl log10f(  float _X)
        {
            return (float)log10(_X);
        }

          __inline float __cdecl logf(  float _X)
        {
            return (float)log(_X);
        }

          __inline float __cdecl modff(  float _X,   float* _Y)
        {
            double _F, _I;
            _F = modf(_X, &_I);
            *_Y = (float)_I;
            return (float)_F;
        }

          __inline float __cdecl powf(  float _X,   float _Y)
        {
            return (float)pow(_X, _Y);
        }

          __inline float __cdecl sinf(  float _X)
        {
            return (float)sin(_X);
        }

          __inline float __cdecl sinhf(  float _X)
        {
            return (float)sinh(_X);
        }

          __inline float __cdecl sqrtf(  float _X)
        {
            return (float)sqrt(_X);
        }

          __inline float __cdecl tanf(  float _X)
        {
            return (float)tan(_X);
        }

          __inline float __cdecl tanhf(  float _X)
        {
            return (float)tanh(_X);
        }

    #line 773 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 961 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 979 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 987 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"

#line 989 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math.h"


#pragma warning(pop)

} __pragma(pack(pop))

#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"


    #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math_defines.h"







#pragma once


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 31 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_math_defines.h"
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"
#line 16 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"
#line 5 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths_func.h"

namespace spork { namespace maths {

	inline float toRadians(float degrees)
	{
		return degrees * (3.14159265358979323846 / 180.0f);
	}

	inline float sqrt(float value)
	{
		return ::sqrt(value);
	}

	inline float rsqrt(float value)
	{
		return 1.0f / ::sqrt(value);
	}
} }
#line 4 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\vec2.h"
#pragma once
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"

#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

  


















































































#line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
 #line 253 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 257 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"








#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"










    

#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 52 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 66 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma pack(push,8)





 
  


   
  #line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
  
 


#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"














 
  
   

#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
    
   #line 52 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
  





#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 66 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 68 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 102 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 104 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 




























#line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

	







		
		
			
		

#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 157 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 158 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		




 
  
 #line 167 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"










































	
	






		
			
		

#line 222 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 223 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	




		
			
		

#line 235 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 236 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	
		
	



#line 245 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





	
		#pragma detect_mismatch("_MSC_VER", "1900")
	#line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	#line 259 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		

#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 266 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 268 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 271 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"








	

#line 283 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
		
	#line 285 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 286 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 296 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 298 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 299 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"













#line 313 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
#line 317 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
 

 









 









 









 

 









 









 




 





 













#line 399 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"











#line 411 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"













#pragma once








#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"











    
    



#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"


    






#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"



    
#line 56 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 67 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"
#line 413 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 417 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 421 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 















 
  

#line 443 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 445 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 446 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 451 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 453 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 454 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 459 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 461 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 462 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  





#line 472 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

   


#line 477 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
    
   #line 479 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  #line 481 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 482 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
 #line 486 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 491 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   


     
   #line 496 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
  #line 497 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 498 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 


























  
   
  #line 529 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 530 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

 
  
  
  




  
  
  

  







   
   
   
  #line 557 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  
  
  
  

 












#line 577 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		





		







typedef long long _Longlong;
typedef unsigned long long _ULonglong;

		






		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 644 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() noexcept;	
  #line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

  











#line 677 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 763 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
  










#line 780 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;
  #line 783 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 797 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 802 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;




 
 #pragma pack(pop)
#line 819 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 820 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





#line 6 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"

__pragma(pack(push, 8)) extern "C" {









    
    



#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"









































#line 71 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    


        
    #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    
        
    #line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#pragma once









 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"













    
#line 16 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\math.h"
#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 

  inline double abs(  double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

  inline double pow(  double _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: pow(_Xx, static_cast<double>(_Yx)));
	}

  inline float abs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float acos(  float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

  inline float acosh(  float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

  inline float asin(  float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

  inline float asinh(  float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

  inline float atan(  float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

  inline float atanh(  float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

  inline float atan2(  float _Yx,   float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

  inline float cbrt(  float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

  inline float ceil(  float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

  inline float copysign(  float _Number,
	  float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

  inline float cos(  float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

  inline float cosh(  float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

  inline float erf(  float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

  inline float erfc(  float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

  inline float exp(  float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

  inline float exp2(  float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

  inline float expm1(  float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

  inline float fabs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float fdim(  float _Xx,   float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

  inline float floor(  float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

  inline float fma(  float _Xx,   float _Yx,
	  float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

  inline float fmax(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

  inline float fmin(  float _Xx,   float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

  inline float fmod(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

  inline float frexp(  float _Xx,   int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

  inline float hypot(  float _Xx,   float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

  inline int ilogb(  float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

  inline float ldexp(  float _Xx,   int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

  inline float lgamma(  float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

  inline long long llrint(  float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

  inline long long llround(  float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

  inline float log(  float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

  inline float log10(  float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

  inline float log1p(  float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

  inline float log2(  float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

  inline float logb(  float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

  inline long lrint(  float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

  inline long lround(  float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

  inline float modf(  float _Xx,   float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

  inline float nearbyint(  float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

  inline float nextafter(  float _Xx,   float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

  inline float nexttoward(  float _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,
	  float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powf(_Xx, static_cast<float>(_Yx)));
	}

  inline float remainder(  float _Xx,   float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

  inline float remquo(  float _Xx,   float _Yx,
	  int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

  inline float rint(  float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

  inline float round(  float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

  inline float scalbln(  float _Xx,   long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

  inline float scalbn(  float _Xx,   int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

  inline float sin(  float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

  inline float sinh(  float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

  inline float sqrt(  float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

  inline float tan(  float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

  inline float tanh(  float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

  inline float tgamma(  float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

  inline float trunc(  float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

  inline long double abs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double acos(  long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

  inline long double acosh(  long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

  inline long double asin(  long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

  inline long double asinh(  long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

  inline long double atan(  long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

  inline long double atanh(  long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

  inline long double atan2(  long double _Yx,
	  long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

  inline long double cbrt(  long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

  inline long double ceil(  long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

  inline long double copysign(  long double _Number,
	  long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

  inline long double cos(  long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

  inline long double cosh(  long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

  inline long double erf(  long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

  inline long double erfc(  long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

  inline long double exp(  long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

  inline long double exp2(  long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

  inline long double expm1(  long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

  inline long double fabs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double fdim(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

  inline long double floor(  long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

  inline long double fma(  long double _Xx,
	  long double _Yx,   long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

  inline long double fmax(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

  inline long double fmin(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

  inline long double fmod(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

  inline long double frexp(  long double _Xx,
	  int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

  inline long double hypot(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

  inline int ilogb(  long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

  inline long double ldexp(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

  inline long double lgamma(  long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

  inline long long llrint(  long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

  inline long long llround(  long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

  inline long double log(  long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

  inline long double log10(  long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

  inline long double log1p(  long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

  inline long double log2(  long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

  inline long double logb(  long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

  inline long lrint(  long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

  inline long lround(  long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

  inline long double modf(  long double _Xx,
	  long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

  inline long double nearbyint(  long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

  inline long double nextafter(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

  inline long double nexttoward(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powl(_Xx, static_cast<long double>(_Yx)));
	}

  inline long double remainder(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

  inline long double remquo(  long double _Xx,
	  long double _Yx,   int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

  inline long double rint(  long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

  inline long double round(  long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

  inline long double scalbln(  long double _Xx,
	  long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

  inline long double scalbn(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

  inline long double sin(  long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

  inline long double sinh(  long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

  inline long double sqrt(  long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

  inline long double tan(  long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

  inline long double tanh(  long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

  inline long double tgamma(  long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

  inline long double trunc(  long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}

 #line 641 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"






 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"


 
#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport)
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict)
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    );

 
__declspec(dllimport)
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 225 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_search.h"










#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stddef.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 37 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stddef.h"




    
        
    

#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stddef.h"


#line 49 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 185 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


































     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 63 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 70 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 86 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 93 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

     __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 361 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 373 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"



    

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 442 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 467 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

         __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 474 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"
#line 481 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {




    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 57 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


    
    
#line 82 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 142 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
    __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

    __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 185 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"












#line 198 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
    __declspec(dllimport)  char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport)  int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"




 __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
 __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
 __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 352 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 379 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 409 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 635 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 645 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 669 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
 __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 694 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
#pragma warning(pop)

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 

__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );


__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 760 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

  
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 789 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 
  
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 814 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 835 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
        
    #line 837 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

    


        
    #line 843 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 850 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 925 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 932 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 951 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 960 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"





__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );


__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 988 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1013 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1020 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1039 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

 __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1048 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1096 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"
#pragma warning(pop)


__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }










    

    
     
    __declspec(dllimport) errno_t __cdecl getenv_s(
                                     size_t*     _RequiredCount,
          char*       _Buffer,
                                      rsize_t     _BufferCount,
                                    char const* _VarName
        );

    #line 1155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"




    __declspec(dllimport) int*       __cdecl __p___argc (void);
    __declspec(dllimport) char***    __cdecl __p___argv (void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);

    




        
        
        
    #line 1172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

    __declspec(dllimport) char***    __cdecl __p__environ (void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);

    
        
    #line 1179 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

    





        
        
    #line 1189 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"



    
    


    

          
        __declspec(dllimport) char* __cdecl getenv(
              char const* _VarName
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

        


#line 1214 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

        
        __declspec(dllimport) errno_t __cdecl _dupenv_s(
                char**      _Buffer,
                                                                                size_t*     _BufferCount,
                                                                                   char const* _VarName
            );

        

#line 1225 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

        __declspec(dllimport) int __cdecl system(
              char const* _Command
            );

        
        
        #pragma warning (push)
        #pragma warning (disable:6540)

         
        __declspec(dllimport) int __cdecl _putenv(
              char const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _putenv_s(
              char const* _Name,
              char const* _Value
            );

        #pragma warning (pop)

        __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                    char const* _Filename,
                                    char const* _VarName,
              char*       _Buffer,
                                      size_t      _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

         __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

        
        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _seterrormode(
              int _Mode
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _beep(
              unsigned _Frequency,
              unsigned _Duration
            );

        __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
        __declspec(dllimport) void __cdecl _sleep(
              unsigned long _Duration
            );

    #line 1287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

#line 1289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"










    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) 
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
        __declspec(dllimport) int __cdecl putenv(
              char const* _EnvString
            );

    #line 1372 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1378 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

 
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 #line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
 #line 44 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
struct _Nil
	{	
	};

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static constexpr _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	constexpr operator value_type() const noexcept
		{	
		return (value);
		}

	constexpr value_type operator()() const noexcept
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

	
template<bool _Val>
	struct _Cat_base
		: integral_constant<bool, _Val>
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

 
template<class _Ty,
	class _Uty>
	constexpr bool is_same_v = is_same<_Ty, _Uty>::value;
 #line 102 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<long long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long long>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

 
template<class _Ty>
	constexpr bool is_integral_v = is_integral<_Ty>::value;
 #line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

 
template<class _Ty>
	constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;
 #line 284 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

 
template<class _Ty>
	constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;
 #line 297 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};














}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 349 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"
#line 350 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}








































template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
		&& ::std:: is_arithmetic<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"    double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"    double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"    double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"    double __cdecl atan2(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"    double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"    double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"    double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C"    double __cdecl fabs(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C"   __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"    double __cdecl fmod(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"    double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"    double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"    double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"    double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"    double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"    double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"    double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

		









		

inline float _Fma(float _Left, float _Middle, float _Right)
	{	
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C"   __declspec(dllimport) double __cdecl acosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl asinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl atanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl cbrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl copysign(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl erf(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl erfc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl expm1(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl exp2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl fdim(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl fmax(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl fmin(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl hypot(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) int __cdecl ilogb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl lgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log1p(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl logb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nearbyint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nextafter(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl nexttoward(  double,   long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl remainder(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl rint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl round(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl scalbln(  double,   long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl scalbn(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl tgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl trunc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 218 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
#line 219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
 #line 220 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"





#line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 649 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 
namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
 #line 731 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#line 733 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



__pragma(pack(push, 8)) extern "C" {



#line 17 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"




#line 22 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"
    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"


    
        
    



#line 33 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"
#line 34 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"














    








#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"




#line 63 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 70 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"
    #line 71 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"
#line 72 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"






#line 79 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 99 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"



#line 103 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_stdio_config.h"



















} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

__pragma(pack(push, 8)) extern "C" {








    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 100 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 206 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 212 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 253 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 305 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 309 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 319 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 323 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 334 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 338 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 350 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 356 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 367 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 371 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 381 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 395 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 399 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 408 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 412 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 422 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 437 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 441 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 453 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 457 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 466 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 470 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 489 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 498 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 507 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 517 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 526 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 537 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 546 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 548 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 558 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 567 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 576 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 585 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 594 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 603 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 611 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 620 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 629 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 648 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 657 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 659 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 668 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 694 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 720 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 726 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 736 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 751 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 757 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 769 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 773 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 775 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 784 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 788 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 797 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 801 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 811 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 815 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 826 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 830 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 832 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 842 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 851 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 860 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 869 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 879 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 888 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 899 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 908 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 910 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 919 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 928 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

      
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 936 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 945 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 954 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 963 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 973 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 982 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 984 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1000 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1058 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1066 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4793)

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...);  __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
     
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1138 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1147 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1160 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1180 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1184 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1197 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1204 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1216 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1220 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1231 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1247 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1251 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1264 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1272 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1285 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 1291 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1299 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1312 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1320 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1332 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1347 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1365 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1380 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1388 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1402 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1413 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1422 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1434 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1453 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1462 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1473 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1482 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(push)
    
    
    #pragma warning(disable:4793 4996)

     __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...);  __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1496 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...);  __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1503 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1517 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1526 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1538 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1547 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 1549 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1556 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1568 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1577 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1588 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1597 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1609 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1618 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1629 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1650 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1664 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1689 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1702 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1723 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1732 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1749 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1758 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1767 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1786 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1795 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1804 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1813 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"


    
        #pragma warning(push)
        #pragma warning(disable: 4141 4412 4793 4996 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
                #pragma warning(suppress: 28719)
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                #pragma warning(suppress: 28719)
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) 
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1874 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1877 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    




#line 1884 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1912 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1918 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1929 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1933 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1945 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1951 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1964 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1968 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 1970 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1978 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1991 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1997 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 2010 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 2016 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2027 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2036 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
      
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2046 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2055 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2066 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2087 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2096 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    #line 2098 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2149 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2181 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2190 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"

    


#line 2195 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstdio.h"



} __pragma(pack(pop))

#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

__pragma(pack(push, 8)) extern "C" {































    
#line 48 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"















    
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 139 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 313 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 338 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 417 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 427 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

      
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 28726) 
 __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 444 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
#pragma warning(pop)

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    













#line 582 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"



    
    

#line 599 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 640 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 644 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 654 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 658 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 669 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 673 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 689 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 691 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 702 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 706 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 716 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 720 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 730 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 734 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 743 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 747 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 757 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 761 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 772 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 778 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 788 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 792 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 801 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 805 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 815 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 824 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 833 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 842 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 858 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 867 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 878 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 887 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 889 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 899 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 908 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 917 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 926 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 935 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 944 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 952 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 961 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 970 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 979 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 989 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 998 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1000 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1009 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1018 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1026 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1035 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1060 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1066 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1076 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1080 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1091 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1097 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1114 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1116 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1126 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1130 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1139 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1153 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1157 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1184 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1193 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

      
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1211 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1221 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1241 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1250 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

      
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1278 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1296 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1305 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1315 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1324 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1326 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"



    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1387 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1395 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1407 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1414 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    








#line 1425 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1437 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1445 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1457 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        #pragma warning(pop)
    }
    #line 1464 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1475 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
        #pragma warning(pop)
    }
    #line 1482 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1495 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1503 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1517 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1521 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1529 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1531 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1544 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1552 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1564 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1568 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1582 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1590 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1603 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1607 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1616 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1631 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1635 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1644 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1646 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1656 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1664 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1673 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1687 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1695 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1704 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1708 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1720 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1728 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1744 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1755 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1769 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1779 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1793 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 4996)
    #pragma warning(disable: 28719) 
    #pragma warning(disable: 28726) 
       int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...);    int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1804 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    #pragma warning(pop)

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1817 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1826 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1839 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1848 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 1850 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1857 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1869 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1878 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1889 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1898 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1910 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1924 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    








#line 1935 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
     
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1946 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    #pragma warning(suppress:28719)    
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1966 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    #pragma warning(suppress:28719)    
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1976 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...);     int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1985 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1997 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2006 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 2017 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2026 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2039 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2048 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2060 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2069 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2077 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2086 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2095 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2103 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2112 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2121 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2130 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2138 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2147 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2188 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2192 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2203 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable:6530)

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2224 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2228 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2239 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2249 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2258 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

      
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2276 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2286 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2295 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2306 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

            #pragma warning(push)
            #pragma warning(disable: 4996) 
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
            #pragma warning(pop)

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2320 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #line 2322 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable:6530)

     
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2349 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2359 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2372 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2384 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2407 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2442 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2452 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2464 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"
#line 2465 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE FILE;

 
namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
 #line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"










#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\errno.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 78 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 126 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"



__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

 
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


__declspec(dllimport) void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

 
__declspec(dllimport) char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

 
__declspec(dllimport) char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

   
__declspec(dllimport) char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

 

__declspec(dllimport) wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

 
__declspec(dllimport) wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

   

__declspec(dllimport) wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 85 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"




__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 56 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"

    












#line 71 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"

#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 111 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 117 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_memory.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"











#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
     __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 119 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
 __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 128 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

#line 150 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 162 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
    
#line 166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 190 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 204 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 212 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 237 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
        



    #line 242 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 

      
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 258 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 269 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 273 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"



 
  
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 294 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 
 
  
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 313 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 351 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 359 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 375 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 382 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 392 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 410 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 417 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 428 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 433 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 446 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 453 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 565 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"









    


#line 578 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 587 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 644 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 650 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wstring.h"
#line 14 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"




__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 70 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"



#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
      char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
#pragma warning(pop)

#line 97 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 128 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

#pragma warning(push)
#pragma warning(disable: 28719) 
#pragma warning(disable: 28726) 
  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
#pragma warning(pop)

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 149 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
 
  
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
  
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 190 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 232 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 237 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 250 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 257 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 264 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 272 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 344 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 

#line 350 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

#line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
    
#line 370 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 379 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 394 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 402 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 425 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

  char* __cdecl _strset( char *_Destination,  int _Value);
#line 431 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 454 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 459 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 472 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 479 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 527 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"





    


#line 536 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );

    

#line 545 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 594 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 600 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\string.h"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

#pragma once










 
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
typedef double max_align_t;	
}

using ::std:: max_align_t;	
 #line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(0), _Last(0)
		{	
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	constexpr const _Elem *begin() const noexcept
		{	
		return (_First);
		}

	constexpr const _Elem *end() const noexcept
		{	
		return (_Last);
		}

	constexpr size_t size() const noexcept
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.end());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 76 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
  
  
 #line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

namespace std {
		
 
 
 #line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 
 
 
 
 

 
 

  

  











#line 55 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
   
   
  #line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



















#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		


		
 

 



































 
 

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static constexpr bool value = false;
	};

		

 
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 #line 172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		
template<class _Ty = void>
	struct plus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
template<>
	struct plus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 




#line 343 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
	const size_t _FNV_offset_basis = 2166136261U;
	const size_t _FNV_prime = 16777619U;
 #line 347 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
	{	
	typedef _Kty argument_type;
	typedef size_t result_type;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static constexpr bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

template<>
	struct hash<char16_t>
		: public _Bitwise_hash<char16_t>
	{	
	};

template<>
	struct hash<char32_t>
		: public _Bitwise_hash<char32_t>
	{	
	};

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 422 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 520 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}
#line 528 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"




 





 #line 539 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 547 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 





 


#line 558 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 567 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


































































namespace std {
	
template<class... _Types>
	struct _Arg_types
	{	
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	
	typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	
	typedef _Ty1 first_argument_type;
	typedef _Ty2 second_argument_type;
	};

	
template<class _Ty>
	struct _Is_function
	{	
	typedef false_type _Bool_type;
	static constexpr bool _Weird = false;
	};












template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };












template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };


template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_function_v = is_function<_Ty>::value;
 #line 699 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		





















template<class _Ty> inline
	constexpr _Ty *addressof(_Ty& _Val) noexcept
	{	
	return (__builtin_addressof(_Val));
	}
#line 728 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


		
template<class _Ptrty> inline
	auto _Unfancy(_Ptrty _Ptr)
	{	
	return (::std:: addressof(*_Ptr));
	}

template<class _Ty> inline
	_Ty * _Unfancy(_Ty * _Ptr)
	{	
	return (_Ptr);
	}

}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 748 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
#line 749 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

namespace std {
template<class _Ty>
	struct _Is_memfunptr
	{	
	typedef false_type _Bool_type;
	};













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };


	
template<class _Ty>
	struct is_void
		: false_type
	{	
	};








template<> struct is_void< void> : true_type { }; template<> struct is_void<const void> : true_type { }; template<> struct is_void<volatile void> : true_type { }; template<> struct is_void<const volatile void> : true_type { };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef const volatile _Ty type;
	};

	
template<class _Ty,
	bool = _Is_function<_Ty>::_Weird || is_void<_Ty>::value>
	struct _Add_reference
	{	
	typedef _Ty _Lvalue;
	typedef _Ty _Rvalue;
	};

template<class _Ty>
	struct _Add_reference<_Ty, false>
	{	
	typedef _Ty& _Lvalue;
	typedef _Ty&& _Rvalue;
	};

	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef typename _Add_reference<_Ty>::_Lvalue type;
	};

	
template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef typename _Add_reference<_Ty>::_Rvalue type;
	};

	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() noexcept;

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};








template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };


	
template<class _Ty,
	bool = _Is_function<_Ty>::_Weird>
	struct _Add_pointer
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct _Add_pointer<_Ty, false>
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

template<class _Ty>
	struct add_pointer
	{	
	typedef typename _Add_pointer<_Ty>::type type;
	};

	
	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};


	
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	
	typedef _Ty2 _Class_type;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	

template<class _Ty>
	struct is_null_pointer
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	
	};

	
template<class _Ty>
	struct is_union
		: _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class
		: _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From,
	class _To>
	struct is_convertible
		: _Cat_base<__is_convertible_to(_From, _To)>
	{	
	};

	
template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_const
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<const _Ty>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<volatile _Ty>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_pod
		: _Cat_base<__is_pod(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_empty
		: _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic
		: _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract
		: _Cat_base<__is_abstract(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_final
		: _Cat_base<__is_final(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_standard_layout
		: _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type
		: _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial
		: _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable
		: _Cat_base<__is_trivially_copyable(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_constructible
		: _Cat_base<__is_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible
		: is_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_assignable
		: integral_constant<bool, __is_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: _Cat_base<__is_destructible(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable
		: _Cat_base<__is_trivially_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable
		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable
		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<__has_trivial_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable
		: _Cat_base<__is_nothrow_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable
		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable
		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible
		: _Cat_base<__is_nothrow_destructible(_Ty)>
	{	
	};

	
template<class _Ty,
	bool = is_integral<_Ty>::value>
	struct _Sign_base
	{	
	typedef typename remove_cv<_Ty>::type _Uty;
	typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
	typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
	};

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	
		
	typedef is_floating_point<_Ty> _Signed;
	typedef false_type _Unsigned;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
	};




	
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	
	static constexpr size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	
	static constexpr size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	
	static constexpr size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	
	static constexpr size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	
template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base,
	class _Der>
	struct is_base_of
		: _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

	
template<class...>
	struct _Conjunction;

template<bool,
	class _Lhs,
	class... _Traits>
	struct _Choose_conjunction
	{	
	typedef _Lhs type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Choose_conjunction<true, _Lhs, _Traits...>
	{	
	typedef typename _Conjunction<_Traits...>::type type;
	};

template<>
	struct _Conjunction<>
	{	
	typedef true_type type;
	};

template<class _Trait>
	struct _Conjunction<_Trait>
	{	
	typedef _Trait type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Conjunction<_Lhs, _Traits...>
	{	
	typedef typename _Choose_conjunction<_Lhs::value, _Lhs, _Traits...>::type type;
	};

template<class... _Traits>
	struct conjunction
		: _Conjunction<_Traits...>::type
	{	
		
		
	};

	
template<class...>
	struct _Disjunction;

template<bool,
	class _Lhs,
	class... _Traits>
	struct _Choose_disjunction
	{	
	typedef _Lhs type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Choose_disjunction<false, _Lhs, _Traits...>
	{	
	typedef typename _Disjunction<_Traits...>::type type;
	};

template<>
	struct _Disjunction<>
	{	
	typedef false_type type;
	};

template<class _Trait>
	struct _Disjunction<_Trait>
	{	
	typedef _Trait type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Disjunction<_Lhs, _Traits...>
	{	
	typedef typename _Choose_disjunction<_Lhs::value, _Lhs, _Traits...>::type type;
	};

template<class... _Traits>
	struct disjunction
		: _Disjunction<_Traits...>::type
	{	
		
		
	};

	
template<class _Trait>
	struct negation
		: bool_constant<!_Trait::value>
	{	
	};


namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	
#line 1156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	{	
	typedef typename decay<_Ty>::type type;
	};

template<class _Ty0,
	class _Ty1>
	struct common_type<_Ty0, _Ty1>
	{	
	typedef typename decay<
		decltype(_Always_false<_Ty0>::value
			? ::std:: declval<_Ty0>()
			: ::std:: declval<_Ty1>())
	>::type type;
	};

template<class _Ty0,
	class _Ty1,
	class... _Ty>
	struct common_type<_Ty0, _Ty1, _Ty...>
	{	
	typedef typename common_type<
		typename common_type<_Ty0, _Ty1>::type, _Ty...
	>::type type;
	};

	
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	
	static_assert(is_integral<_Ty>::value,
		"integer_sequence<T, I...> requires T to be an integral type.");

	typedef integer_sequence<_Ty, _Vals...> type;
	typedef _Ty value_type;

	static constexpr size_t size() noexcept
		{	
		return (sizeof...(_Vals));
		}
	};

	
 




































template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
 #line 1247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;


	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};
#line 1270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

	
template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type& _Arg) noexcept
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type&& _Arg) noexcept
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
		&& is_copy_constructible<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) noexcept
	{	
	return (::std:: move(_Arg));
	}

	
template<class...>
	struct _Param_tester
	{	
	typedef void type;
	};

	
template<class... _Types>	
	using void_t = typename _Param_tester<_Types...>::type;

	
struct _Invoker_pmf_object
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmf_pointer
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmd_object
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
		{	
		return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
		}
	};

struct _Invoker_pmd_pointer
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
		{	
		return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
		}
	};

struct _Invoker_functor
	{	
	template<class _Callable,
		class... _Types>
		static auto _Call(_Callable&& _Obj, _Types&&... _Args)
		-> decltype(::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...));
		}
	};

template<class _Callable,
	class _Ty1,
	class _Decayed = typename decay<_Callable>::type,
	bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
	bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
	struct _Invoker1;

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
		: _If<is_base_of<
			typename _Is_memfunptr<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmf_object,
		_Invoker_pmf_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
		: _If<is_base_of<
			typename _Is_member_object_pointer<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmd_object,
		_Invoker_pmd_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable>
	struct _Invoker<_Callable>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class _Ty1,
	class... _Types2>
	struct _Invoker<_Callable, _Ty1, _Types2...>
		: _Invoker1<_Callable, _Ty1>
	{	
	};

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
	{	
	return (_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
	}

template<class _Rx,
	bool = is_void<_Rx>::value>
	struct _Forced
	{	
	};

struct _Unforced
	{	
	};

template<class _Cv_void,
	class... _Valtys> inline
	void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
	{	
	::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
	}

template<class _Rx,
	class... _Valtys> inline
	_Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

template<class... _Valtys> inline
	auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
	-> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

	
struct _Unique_tag_result_of
	{	
	};

template<class _Void,
	class... _Types>
	struct _Result_of
	{	
	};

template<class... _Types>
	struct _Result_of<
		void_t<
			_Unique_tag_result_of,	
			decltype(::std:: invoke(::std:: declval<_Types>()...))>,
		_Types...>
	{	
	typedef decltype(::std:: invoke(::std:: declval<_Types>()...)) type;
	};

template<class _Fty>
	struct result_of
	{	
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};









template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> : _Result_of<void, _Fty, _Args...> { };  template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __vectorcall (_Args...)> : _Result_of<void, _Fty, _Args...> { };


	
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	
	};

template<class _Ty>
	struct _Weak_result_type<_Ty, void_t<
		typename _Ty::result_type> >
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_argument_type<_Ty, void_t<
		typename _Ty::argument_type> >
		: _Weak_result_type<_Ty>
	{	
	typedef typename _Ty::argument_type argument_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_binary_args<_Ty, void_t<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type> >
		: _Weak_argument_type<_Ty>
	{	
	typedef typename _Ty::first_argument_type first_argument_type;
	typedef typename _Ty::second_argument_type second_argument_type;
	};

template<class _Ty>
	struct _Weak_types
	{	
	typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
	typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
	typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty> >::type>::type type;
	};

	
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	
public:
	static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	typedef _Ty type;

	reference_wrapper(_Ty& _Val) noexcept
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	operator _Ty&() const noexcept
		{	
		return (*_Ptr);
		}

	_Ty& get() const noexcept
		{	
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

	
template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(_Ty& _Val) noexcept
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: ref(_Val.get()));
	}

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) noexcept
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: cref(_Val.get()));
	}

	
template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	static constexpr bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	static constexpr bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	static constexpr bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};


namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	
#line 1680 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class _Ty>
	struct _Is_swappable;

		
template<class _Ty>
	struct _Is_nothrow_swappable;

		




#line 1695 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty,
	class = void> inline
#line 1698 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
	void swap(_Ty&, _Ty&)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);
#line 1701 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

template<class _Ty,
	size_t _Size,
	class = typename enable_if<_Is_swappable<_Ty>::value>::type> inline
	void swap(_Ty (&)[_Size], _Ty (&)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value);

		
template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Swappable_with_helper
		: false_type
	{	
	};

struct _Swappable_with_helper_unique_type {}; 
template<class _Ty1,
	class _Ty2>
	struct _Swappable_with_helper<_Ty1, _Ty2, void_t<
		_Swappable_with_helper_unique_type,
		decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
		: true_type
	{	
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Is_swappable_with
		: conjunction<
			_Swappable_with_helper<_Ty1, _Ty2>,
			_Swappable_with_helper<_Ty2, _Ty1>>::type
	{	
		
	};

		
template<class _Ty>
	struct _Is_swappable
		: _Is_swappable_with<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<_Ty>::type>::type
	{	
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Swap_cannot_throw
	{	
		
		

	static constexpr bool value = 
		noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
		&& noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));


#line 1761 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
	using type = bool_constant<value>;
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with
		: conjunction<
			_Is_swappable_with<_Ty1, _Ty2>,
			_Swap_cannot_throw<_Ty1, _Ty2>>::type
	{	
		
	};

		
template<class _Ty>
	struct _Is_nothrow_swappable
		: _Is_nothrow_swappable_with<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<_Ty>::type>::type
	{	
	};

































#line 1817 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;

	
 
template<class _Ty>
	constexpr bool is_void_v = is_void<_Ty>::value;
template<class _Ty>
	constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_array_v = is_array<_Ty>::value;
template<class _Ty>
	constexpr bool is_pointer_v = is_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_enum_v = is_enum<_Ty>::value;
template<class _Ty>
	constexpr bool is_union_v = is_union<_Ty>::value;
template<class _Ty>
	constexpr bool is_class_v = is_class<_Ty>::value;
template<class _Ty>
	constexpr bool is_reference_v = is_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
template<class _Ty>
	constexpr bool is_object_v = is_object<_Ty>::value;
template<class _Ty>
	constexpr bool is_scalar_v = is_scalar<_Ty>::value;
template<class _Ty>
	constexpr bool is_compound_v = is_compound<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_const_v = is_const<_Ty>::value;
template<class _Ty>
	constexpr bool is_volatile_v = is_volatile<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivial_v = is_trivial<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;
template<class _Ty>
	constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;
template<class _Ty>
	constexpr bool is_pod_v = is_pod<_Ty>::value;
template<class _Ty>
	constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;
template<class _Ty>
	constexpr bool is_empty_v = is_empty<_Ty>::value;
template<class _Ty>
	constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;
template<class _Ty>
	constexpr bool is_abstract_v = is_abstract<_Ty>::value;
template<class _Ty>
	constexpr bool is_final_v = is_final<_Ty>::value;
template<class _Ty>
	constexpr bool is_signed_v = is_signed<_Ty>::value;
template<class _Ty>
	constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_assignable_v = is_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;






#line 1978 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty>
	constexpr bool is_destructible_v = is_destructible<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;






#line 2021 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty>
	constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;
template<class _Ty>
	constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;
template<class _Ty>
	constexpr size_t alignment_of_v = alignment_of<_Ty>::value;
template<class _Ty>
	constexpr size_t rank_v = rank<_Ty>::value;
template<class _Ty,
	unsigned int _Ix = 0>
	constexpr size_t extent_v = extent<_Ty, _Ix>::value;
template<class _Base,
	class _Derived>
	constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template<class _From,
	class _To>
	constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<class... _Traits>
	constexpr bool conjunction_v = conjunction<_Traits...>::value;
template<class... _Traits>
	constexpr bool disjunction_v = disjunction<_Traits...>::value;
template<class _Trait>
	constexpr bool negation_v = negation<_Trait>::value;
 #line 2045 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2052 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
#line 2053 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {

  


  



  




  


  #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

__declspec(dllimport) bool __cdecl uncaught_exception() noexcept;
__declspec(dllimport) int __cdecl uncaught_exceptions() noexcept;

}

 

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {







    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"















typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 72 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    


        
    #line 84 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"

    typedef char __static_assert_t[(sizeof(unsigned int) <= 8) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 8;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 8;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"





    
        
        




    #line 123 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"












#line 136 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"




#line 141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"
#line 142 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 8;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            





        }
    }
    #pragma warning(pop)

#line 169 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"




    
#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\malloc.h"



} __pragma(pack(pop))
#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_terminate.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 40 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_terminate.h"

#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_terminate.h"
#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"



__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;


    
    __declspec(dllimport) __declspec(noreturn) void __cdecl unexpected() throw(...);

    

        __declspec(dllimport) unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) throw();

        __declspec(dllimport) unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

        __declspec(dllimport) _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

    class type_info;

    __declspec(dllimport) int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

    __declspec(dllimport) bool __cdecl __uncaught_exception();
    __declspec(dllimport) int  __cdecl __uncaught_exceptions();

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

} __pragma(pack(pop))

#line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"
#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"





#pragma pack(push, 8)


__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

__declspec(dllimport) void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

__declspec(dllimport) void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

class exception
{
public:

    exception() throw()
        : _Data()
    {
    }

    explicit exception(char const* const _Message) throw()
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) throw()
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) throw()
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) throw()
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

} 

#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"
#pragma pack(pop)





#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);


inline terminate_handler __cdecl get_terminate() noexcept
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected() noexcept
	{	
	return (_get_unexpected());
	}
#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

}

 




































































































































































#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"









#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(  void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(  void*,   void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
[[noreturn]] __declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(
	  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr() throw ()
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) throw ()
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) throw ()
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	explicit operator bool() const throw ()
		{
		return __ExceptionPtrToBool(this);
		}

	[[noreturn]] void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() throw ()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception() noexcept
	{
	return exception_ptr::_Current_exception();
	}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except) noexcept
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}

	
class nested_exception
	{	
public:
	nested_exception() noexcept
		: _Exc(::std:: current_exception())
		{	
		}

	nested_exception(const nested_exception&) noexcept = default;
	nested_exception& operator=(const nested_exception&) noexcept = default;
	virtual ~nested_exception() noexcept = default;

	[[noreturn]] void rethrow_nested() const
		{	
		if (_Exc)
			::std:: rethrow_exception(_Exc);
		else
			::std:: terminate();
		}

	::std:: exception_ptr nested_ptr() const noexcept
		{	
		return (_Exc);
		}

private:
	::std:: exception_ptr _Exc;
	};

	
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
		{	
		}
	};

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;
	typedef _With_nested<_Ty, _Uty> _Glued;

	throw _Glued(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	
	typedef typename decay<_Ty>::type _Decayed;

	throw _Decayed(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;

	integral_constant<bool,
		is_class<_Uty>::value
		&& !is_base_of<nested_exception, _Uty>::value
		&& !is_final<_Uty>::value> _Tag;

	_Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
	}

	
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	
	integral_constant<bool,
		is_polymorphic<_Ty>::value
		&& (!is_base_of<nested_exception, _Ty>::value
			|| is_convertible<_Ty *, nested_exception *>::value)> _Tag;

	_Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 480 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 481 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#pragma once










 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"







#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"



typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;














































    
    
    
#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"




































#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"





#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

 
namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;


	namespace tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
	}	
#line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"
}
 #line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 

  

 
 
extern "C" {
 #line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

		





		






void __cdecl _Feraise(int);

typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 #line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"

#pragma once




#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"
    #line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"
#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"



















    
        
            
        

#line 54 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"
    

#line 57 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"
#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"






















































































































































    





#line 215 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);



    
    __declspec(dllimport) void __cdecl _statusfp2(
          unsigned int* _X86Status,
          unsigned int* _SSE2Status
        );

#line 267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"





__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );


    
    __declspec(dllimport) int __cdecl __control87_2(
               unsigned int  _NewValue,
               unsigned int  _Mask,
          unsigned int* _X86ControlWord,
          unsigned int* _Sse2ControlWord
        );
#line 286 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"


 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);














    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"









#pragma once




#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {









    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

     
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"

#line 428 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 16 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {











    

#line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"
#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"


















































































#line 196 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 17 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 18 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"








#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_share.h"








#pragma once












    
    
    
    
#line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_share.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable:4820) 











    
    
#line 33 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"

 
 __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wio.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 117 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wprocess.h"
#line 118 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 62 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 100 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"

 
 
  
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 119 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 130 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"

 __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"

 __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 151 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"









    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"







#pragma once




    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 32 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"
#line 33 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"
#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\types.h"
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"

__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4820) 







struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 103 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 246 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"
#line 247 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\sys\\stat.h"


#pragma warning(pop)


} __pragma(pack(pop))
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





    
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 93 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

      __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 101 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 119 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

     __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 126 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

     __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 278 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"

#line 280 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
 #line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#line 49 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {















 

 
 
 
 

 
 
 
 

 
 
 
 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static constexpr bool has_denorm_loss = (bool)(false);
	static constexpr bool has_infinity = (bool)(false);
	static constexpr bool has_quiet_NaN = (bool)(false);
	static constexpr bool has_signaling_NaN = (bool)(false);
	static constexpr bool is_bounded = (bool)(false);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(false);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr bool is_specialized = (bool)(false);
	static constexpr bool tinyness_before = (bool)(false);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
	static constexpr int digits = (int)(0);
	static constexpr int digits10 = (int)(0);

	static constexpr int max_digits10 = (int)(0);

	static constexpr int max_exponent = (int)(0);
	static constexpr int max_exponent10 = (int)(0);
	static constexpr int min_exponent = (int)(0);
	static constexpr int min_exponent10 = (int)(0);
	static constexpr int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static constexpr _Ty (min)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(true);
	static constexpr bool is_integer = (bool)(true);
	static constexpr bool is_modulo = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static constexpr bool has_denorm_loss = (bool)(true);
	static constexpr bool has_infinity = (bool)(true);
	static constexpr bool has_quiet_NaN = (bool)(true);
	static constexpr bool has_signaling_NaN = (bool)(true);
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(true);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr bool tinyness_before = (bool)(true);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
	static constexpr int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)((-128) != 0);
	static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 259 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((_Ty)0x0000);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return ((_Ty)0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(0x0000 != 0);
	static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 318 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (false);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (true);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(1);
	static constexpr int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 - 1);
	static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8);
	static constexpr int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-32768));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (32767);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (short) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 548 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned short));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 607 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};
 #line 609 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

		
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	
public:
	typedef char16_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char16_t));
	static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);
#line 666 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647 - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (int) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 724 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned int));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 782 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647L - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 840 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffUL);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	
public:
	typedef char32_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char32_t));
	static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);
#line 956 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long long>
	: public _Num_int_base
	{	
public:
	typedef long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0x7fffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);
#line 1014 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);
#line 1072 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (1.175494351e-38F);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (3.402823466e+38F);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (1.192092896e-07F);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5F);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (1.401298464e-45F);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_valf());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nanf("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nansf("1"));
		}

	static constexpr int digits = (int)(24);
	static constexpr int digits10 = (int)(6);

	static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)128);
	static constexpr int max_exponent10 = (int)((int)38);
	static constexpr int min_exponent = (int)((int)(-125));
	static constexpr int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_val());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nan("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nans("1"));
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5L);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_val());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nan("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nans("1"));
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

  









































































































































































































#line 1466 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

 
 
 
 

 
 
 
 

 
 
 
 
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1486 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1487 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"






#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 






    namespace std
    {
        struct nothrow_t { };

        extern nothrow_t const nothrow;
    }
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"

   
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new(
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

   
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new[](
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();


    
       
    inline void* __cdecl operator new(size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }
#line 97 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


    
       
    inline void* __cdecl operator new[](size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"



#pragma warning(pop)
#pragma pack(pop)

} 
#line 119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  



namespace std {

		
 

typedef void (__cdecl * new_handler) ();
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(  new_handler)
	noexcept;	

__declspec(dllimport) new_handler __cdecl get_new_handler()
	noexcept;	
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"
#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

#pragma once





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

#pragma once








#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"







#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"







#pragma once




extern "C++" {

#pragma pack(push, 8)






         
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

         
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

#line 53 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"
















































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
          char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
          wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 583 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

#line 585 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"





















    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        
        
        
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"







































    

    
    
    
        





    #line 736 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

    
        
    #line 740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

    
        
    #line 744 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 766 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"













    
#line 781 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern __declspec(dllimport)  const streamoff _BADOFF;
  #line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { (void)( (!!(("_Count <= _Dest_size" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0, L"%ls", L"\"_Count <= _Dest_size\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"_Count <= _Dest_size", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((int_type)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

		
template<>
	struct char_traits<char16_t>
	: public _Char_traits<char16_t, unsigned short>
	{	
	};

typedef streampos u16streampos;

		
template<>
	struct char_traits<char32_t>
	: public _Char_traits<char32_t, unsigned int>
	{	
	};

typedef streampos u32streampos;

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(const int_type& _Meta)
		noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(const _Elem& _Ch)
		noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(const int_type& _Meta)
		noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};
 #line 503 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((unsigned char)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #line 674 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

 





















 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 748 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 754 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
#line 755 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size,
	class> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty,
	class> inline
	void swap(_Ty& _Left, _Ty& _Right)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)
#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
	{	
	_Ty _Tmp = ::std:: move(_Left);
	_Left = ::std:: move(_Right);
	_Right = ::std:: move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

constexpr piecewise_construct_t piecewise_construct{};

		
template<class...>
	class tuple;

template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_default_constructible<_Uty1>::value
						&& is_default_constructible<_Uty2>::value> >
		constexpr pair()
		: first(), second()
		{	
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_copy_constructible<_Uty1>::value
						&& is_copy_constructible<_Uty2>::value>,
		enable_if_t<is_convertible<const _Uty1&, _Uty1>::value
				&& is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
		constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_copy_constructible<_Uty1>::value
						&& is_copy_constructible<_Uty2>::value>,
		enable_if_t<!is_convertible<const _Uty1&, _Uty1>::value
				|| !is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
		constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
						&& is_constructible<_Ty2, const _Other2&>::value>,
		enable_if_t<is_convertible<const _Other1&, _Ty1>::value
				&& is_convertible<const _Other2&, _Ty2>::value, int> = 0>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
						&& is_constructible<_Ty2, const _Other2&>::value>,
		enable_if_t<!is_convertible<const _Other1&, _Ty1>::value
				|| !is_convertible<const _Other2&, _Ty2>::value, int> = 0>
		constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 170 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<!is_convertible<_Other1, _Ty1>::value
				|| !is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 198 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<!is_convertible<_Other1, _Ty1>::value
				|| !is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))
#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	_Ty1 first;		
	_Ty2 second;	

	void swap(_Myt& _Right)
		noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)
#line 248 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}
	};

		

template<class _Ty1,
	class _Ty2,
	class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	constexpr pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
template<class _Ty,
	size_t _Size>
	class array;

	
template<class _Tuple>
	struct tuple_size;

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	: integral_constant<size_t, 2>
	{	
	};

template<class... _Types>
	struct tuple_size<tuple<_Types...> >
	: integral_constant<size_t, sizeof...(_Types)>
	{	
	};


template<class _Tuple>
	struct tuple_size<const _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

 
template<class _Ty>
	constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
 #line 412 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

	
template<size_t _Index,
	class _Tuple>
	struct tuple_element;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size> >
	{	
	static_assert(_Idx < _Size, "array index out of bounds");

	typedef _Ty type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<size_t _Index>
	struct tuple_element<_Index, tuple<> >
	{	
	static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
		"tuple index out of bounds");
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...> >
	{	
	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...> >
		: public tuple_element<_Index - 1, tuple<_Rest...> >
	{	
	};


template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	
template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) noexcept
	{	
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) noexcept
	{	
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		_Ctype;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
		get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<1>(::std:: move(_Pr)));
	}

	
template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	
	_Ty _Old_val = ::std:: move(_Val);
	_Val = ::std:: forward<_Other>(_New_val);
	return (_Old_val);
	}

	
template<class _Ty> inline
	constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
	{	
	return (_Val);
	}

template<class _Ty>
	void as_const(const _Ty&&) = delete;
}


namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}
#line 617 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 622 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
#line 623 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 

  

  


typedef const wchar_t *_Dbfile_t;
typedef unsigned int _Dbline_t;

__declspec(dllimport) void __cdecl _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);

 

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() noexcept
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}

		return (*this);
		}

	~_Iterator_base12() noexcept
		{	
 
		_Lockit _Lock(3);
		_Orphan_me();
 #line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 
			if (_Myproxy != _Parent_proxy)
				{	
				_Lockit _Lock(3);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 

#line 174 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 
		if (_Myproxy != 0)
			{	
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_Debug_message(L"ITERATOR LIST CORRUPTED!", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 202);
			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 
	if (_Myproxy != 0)
		{	
		_Lockit _Lock(3);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #line 227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 
	_Lockit _Lock(3);
 #line 234 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 



#line 250 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
typedef _Container_base12 _Container_base;
typedef _Iterator_base12 _Iterator_base;
 #line 253 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	
struct _Zero_then_variadic_args_t
	{	
	};	

struct _One_then_variadic_args_t
	{	
	};	

template<class _Ty1,
	class _Ty2,
	bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
	class _Compressed_pair final
		: private _Ty1

	{	
private:
	_Ty2 _Myval2;

	typedef _Ty1 _Mybase;	

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (*this);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (*this);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (*this);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (*this);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final

	{	
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (_Myval1);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (_Myval1);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (_Myval1);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (_Myval1);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

		
template<class _Ty,
	class = void>
	struct _Is_checked_helper
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_checked_helper<_Ty, void_t<
		typename _Ty::_Unchecked_type> >
		: true_type
	{	
	};

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return {};
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

 


		
 







#line 444 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

template<class _Iter> inline
	_Iter _Unchecked_idl0(_Iter _Src)
	{	
	return (_Src);
	}

 #line 452 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		




















		
		
		




#line 491 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		


		


		


#line 502 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"


		
		
struct input_iterator_tag
	{	
	};

struct _Mutable_iterator_tag	
	{	
	};

struct output_iterator_tag
	: _Mutable_iterator_tag
	{	
	};

struct forward_iterator_tag
	: input_iterator_tag, _Mutable_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	
	};

		
struct _General_ptr_iterator_tag
	{	
	};

struct _Trivially_copyable_ptr_iterator_tag
	: _General_ptr_iterator_tag
	{	
	};

struct _Really_trivial_ptr_iterator_tag
	: _Trivially_copyable_ptr_iterator_tag
	{	
	};

	
struct _Any_tag
	{	
	constexpr _Any_tag() noexcept = default;
	template<class _Ty>
		constexpr _Any_tag(_Ty&&) noexcept {}
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;

		
template<class,
	class = void>
	struct _Iterator_traits_base
	{	
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, void_t<
		typename _Iter::iterator_category,
		typename _Iter::value_type,
		typename _Iter::difference_type,
		typename _Iter::pointer,
		typename _Iter::reference
		> >
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;

	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter>
	using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

		
template<class _Iter>
	using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

		
template<class _Iter>
	using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

		
template<class _Ty,
	class = void>
	struct _Is_iterator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty, void_t<
		typename iterator_traits<_Ty>::iterator_category
		> >
		: true_type
	{	
	};


		
 






#line 683 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff, false_type)
	{	
	return (_Src);
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff _Count, true_type)
	{	
	if (0 < _Count)
		{
		static_cast<void>((_Src) + (_Count));
		}

	return (_Unchecked(_Src));
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n(_Iter _Src, _Diff _Count)
	{	
	return (_Unchecked_n1(_Src, _Count, is_base_of<random_access_iterator_tag, _Iter_cat_t<_Iter>>()));
	}
 #line 709 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"


		
template<class _Ty1,
	class _Ty2>
	struct _Is_same_size
		: bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
	{	
	};

		
template<class _Elem,
	bool _Is_enum = is_enum<_Elem>::value>
	struct _Unwrap_enum
	{	
	typedef underlying_type_t<_Elem> type;
	};

template<class _Elem>
	struct _Unwrap_enum<_Elem, false>
	{	
	typedef _Elem type;
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Both_or_neither_bool
		: bool_constant<is_same<bool, _Ty1>::value == is_same<bool, _Ty2>::value>
	{	
	};

		
template<class _Source,
	class _Dest>
	struct _Ptr_cat_helper
	{	
	typedef typename _Unwrap_enum<_Source>::type _USource;
	typedef typename _Unwrap_enum<_Dest>::type _UDest;
	typedef conditional_t<
		conjunction<
			_Is_same_size<_USource, _UDest>,
			is_integral<_USource>,
			is_integral<_UDest>,
			_Both_or_neither_bool<_USource, _UDest>,
			
			negation<is_volatile<_Source>>,
			negation<is_volatile<_Dest>>
		>::value,
		_Really_trivial_ptr_iterator_tag,
		_General_ptr_iterator_tag> type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef conditional_t<
		is_trivially_copyable<_Elem>::value,
		conditional_t<is_trivial<_Elem>::value,
			_Really_trivial_ptr_iterator_tag,
			_Trivially_copyable_ptr_iterator_tag>,
		_General_ptr_iterator_tag> type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Really_trivial_ptr_iterator_tag type;
	};

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable<_Dest&, _Source&>::value,
		typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
		_General_ptr_iterator_tag>
		_Ptr_copy_cat(_Source * const&, _Dest * const&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable<_Dest&, _Source>::value,
		typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
		_General_ptr_iterator_tag>
		_Ptr_move_cat(_Source * const&, _Dest * const&)
	{	
	return {};
	}

		

 











#line 828 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  
   
  #line 834 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 841 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 848 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 855 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 864 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 871 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 880 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


		
template<class _Pr,
	class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt_pred(_Pr&& _Pred,
		_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		noexcept(noexcept(!_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left)))
#line 895 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	{	
	return (!_Pred(_Left, _Right)
		? false
		: _Pred(_Right, _Left)
			? (_Debug_message(L"invalid comparator", _File, _Line), true)
			: true);
	}

		
template<class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt(_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		noexcept(noexcept(!(_Left < _Right)) && noexcept(_Right < _Left))
#line 910 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	{	
	return (_Debug_lt_pred(less<>(),
		::std:: forward<_Ty1>(_Left), ::std:: forward<_Ty2>(_Right), _File, _Line));
	}

		
template<class _InIt> inline
	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer(_Ty *_Ptr, _Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_pointer_if(bool, _InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer_if(bool _Test, _Ty *_Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Test && _Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_range2(_InIt _First, _InIt _Last,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	static_cast<void>(_First == _Last);	
	}

template<class _RanIt> inline
	void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());
	}

		
template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr2(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, input_iterator_tag)
	{	
	if (_First != _Last)
		_Debug_pointer(_Ptr, _File, _Line);	
	}

template<class _RanIt,
	class _Pty> inline
	void _Debug_range_ptr2(_RanIt _First, _RanIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		_Debug_pointer(_Ptr, _File, _Line);	
		}
	}

template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat_t<_InIt>());
	}

		
template<class _InIt,
	class _Pr> inline
	void _Debug_order2(_InIt, _InIt, _Pr&,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr& _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1017))
			_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void _Debug_order(_InIt _First, _InIt _Last, _Pr&& _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat_t<_InIt>());
	}
 #line 1030 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

 

#line 1034 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"








#line 1043 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _Ty,
	size_t _Actual,
	class _Diff> inline
	void _Debug_array_size2(_Ty (&)[_Actual], _Diff _Desired,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Actual < _Desired)
		_Debug_message(L"array too small", _File, _Line);
	}
  
 #line 1054 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
		
template<class _InIt,
	class _Diff> inline
	void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1063);
 #line 1065 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
		
	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
	}

		
template<class _InIt> inline
	_Iter_diff_t<_InIt>
		_Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
	{	
	_Iter_diff_t<_InIt> _Off = 0;
	for (; _First != _Last; ++_First)
		++_Off;

	return (_Off);
	}

template<class _RanIt> inline
	_Iter_diff_t<_RanIt>
		_Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{	
 
	if (_First != _Last)
		{	
		_Debug_pointer(_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1114);
		_Debug_pointer(_Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1115);
		}
 #line 1118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	return (_Last - _First);
	}

template<class _InIt> inline
	_Iter_diff_t<_InIt>
		distance(_InIt _First, _InIt _Last)
	{	
	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
	}

		
template<class _InIt> inline
	_InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
	{	
	static_assert(is_base_of<input_iterator_tag,
		typename iterator_traits<_InIt>::iterator_category>::value,
		"next requires input iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
	{	
	static_assert(is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value,
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{	
	typedef reverse_iterator<_RanIt> _Myt;

public:
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		: current()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

protected:
	_RanIt current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> operator+(
		typename reverse_iterator<_RanIt>::difference_type _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right.base() < _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
	{	
	return (reverse_iterator<_RanIt>(_Iter));
	}

		

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array + _Size);
	}

		
template<class _Container>
	constexpr auto inline cbegin(const _Container& _Cont)
		noexcept(noexcept(::std:: begin(_Cont)))
		-> decltype(::std:: begin(_Cont))
	{	
	return (::std:: begin(_Cont));
	}

template<class _Container>
	constexpr auto inline cend(const _Container& _Cont)
		noexcept(noexcept(::std:: end(_Cont)))
		-> decltype(::std:: end(_Cont))
	{	
	return (::std:: end(_Cont));
	}

		
template<class _Container>
	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Container>
	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rbegin(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rend(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		
template<class _Container>
	auto inline crbegin(const _Container& _Cont)
		-> decltype(::std:: rbegin(_Cont))
	{	
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	auto inline crend(const _Container& _Cont)
		-> decltype(::std:: rend(_Cont))
	{	
	return (::std:: rend(_Cont));
	}


template<class _Container>
	constexpr auto inline size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr size_t size(const _Ty(&)[_Size]) noexcept
	{	
	return (_Size);
	}

template<class _Container>
	constexpr auto inline empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr bool empty(const _Ty(&)[_Size]) noexcept
	{	
	return (false);
	}

template<class _Elem> inline
	constexpr bool empty(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.size() == 0);
	}

template<class _Container>
	constexpr auto inline data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Container>
	constexpr auto inline data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Elem> inline
	constexpr const _Elem *data(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
 




























































































































#line 1687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	_Array_const_iterator()
		: _Ptr(),
		_Idx(0)
		{	
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		: _Ptr(_Parg),
		_Idx(_Off)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Idx = _Right - _Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr + _Idx);
		}

	reference operator*() const
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1718);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1719, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1719, 0); };
			}

 


#line 1726 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		;

		return (_Ptr[_Idx]);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1743);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1744, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1744, 0); };
			}

 


#line 1751 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		++_Idx;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (_Ptr == 0
			|| _Idx <= 0)
			{	
			_Debug_message(L"array iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1769);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1770, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1770, 0); };
			}

 


#line 1777 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		--_Idx;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Size < _Idx + _Off)
			{	
			_Debug_message(L"array iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1794);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1795, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1795, 0); };
			}

 

#line 1801 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Idx += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx
			? -(difference_type)(_Right._Idx - _Idx)
			: (difference_type)_Idx - _Right._Idx);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (_Ptr != _Right._Ptr)
			{	
			_Debug_message(L"array iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1873);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1874, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1874, 0); };
			}
		}

 




#line 1884 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	pointer _Ptr;	
	size_t _Idx;	
 #line 1888 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef typename iterator_traits<_RanIt>::reference _Ref0;
	typedef conditional_t<is_reference<_Ref0>::value,
		remove_reference_t<_Ref0>&&, _Ref0> reference;
	typedef _RanIt iterator_type;

	move_iterator()
		: current()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (static_cast<reference>(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
template<class _Traits>
	struct _Char_traits_eq
	{
	typedef typename _Traits::char_type _Elem;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::eq(_Left, _Right));
		}
	};

		
template<class _Traits>
	struct _Char_traits_lt
	{
	typedef typename _Traits::char_type _Elem;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::lt(_Left, _Right));
		}
	};

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_memmove(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	const char * const _First_ch = reinterpret_cast<const char *>(_First);
	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
	const size_t _Count = _Last_ch - _First_ch;
	:: memmove(_Dest_ch, _First_ch, _Count);
	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
		
	return (_Copy_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2362);
	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Copy_no_deprecate(_First, _Last, _Dest));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		_Copy_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2388 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	if (0 < _Count)
		{
		*_Dest = *_First;
		while (0 < --_Count)
			*++_Dest = *++_First;
		return (++_Dest);
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
		
		
	return (_Copy_n_unchecked2(_First, _Count,
		_Dest, _Iter_cat_t<_InIt>()));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	if (0 < _Count)
		return (_Copy_memmove(_First, _First + _Count, _Dest));
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2473);
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2485);
	return (_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2497);
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2498);
	return (_Copy_n_unchecked(_First, _Count, _Dest));
	}
 #line 2502 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	const char * const _First_ch = reinterpret_cast<const char *>(_First);
	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
	const size_t _Count = _Last_ch - _First_ch;
	return (static_cast<_BidIt2>(
		:: memmove(_Dest_ch - _Count, _First_ch, _Count)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Copy_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) - ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Copy_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_backward" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2569);
	return (_Copy_backward1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Move_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Move_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2626);
	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "move" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Move_no_deprecate(_First, _Last, _Dest));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		_Move_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2652 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Move_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) - ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Move_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "move_backward" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2706);
	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
	}

		
template<class _Ty>
	struct _Is_character
		: false_type
		{	
		};

template<>
	struct _Is_character<char>
		: true_type
		{	
		};

template<>
	struct _Is_character<signed char>
		: true_type
		{	
		};

template<>
	struct _Is_character<unsigned char>
		: true_type
		{	
		};

template<class _FwdIt,
	class _Ty>
	struct _Fill_memset_is_safe_helper
	{	
	typedef _Iter_value_t<_FwdIt> _Value_type;
	typedef typename conjunction<
		is_pointer<_FwdIt>,
		disjunction<
			conjunction<
				_Is_character<_Ty>,
				_Is_character<_Value_type>>,
			conjunction<
				is_same<bool, _Ty>,
				is_same<bool, _Value_type>>
		>>::type type;
	};

template<class _FwdIt,
	class _Ty> inline
	typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
	_Fill_memset_is_safe(const _FwdIt&, const _Ty&)
	{	
	return {};
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2787);
	_Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
	{	
	if (0 < _Count)
		{
		:: memset(_Dest, _Val, _Count);
		return (_Dest + _Count);
		}

	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
		
	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	return (_Rechecked(_Dest,
		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
	}

		
template<class _Elem1,
	class _Elem2>
	struct _Value_equality_is_bitwise_equality
		: bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
	{	
		
		
		
	};

template<class _Elem1,
	class _Elem2,
	class _Pr>
	struct _Equal_memcmp_is_safe_helper
		: false_type
	{	
		
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
		: conjunction<
			_Is_same_size<_Elem1, _Elem2>,
			is_integral<_Elem1>,
			is_integral<_Elem2>,
			negation<is_same<bool, _Elem1>>,
			negation<is_same<bool, _Elem2>>,
			negation<is_volatile<_Elem1>>,
			negation<is_volatile<_Elem2>>,
			
			
			_Value_equality_is_bitwise_equality<_Elem1, _Elem2>
		>::type
	{	
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
		: is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
	{	
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	
		
	};

template<class _Iter1,
	class _Iter2,
	class _Pr> inline
	false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
	{	
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _Pr> inline
	typename _Equal_memcmp_is_safe_helper<
		remove_const_t<_Obj1>,
		remove_const_t<_Obj2>,
		_Pr>::type
		_Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
	{	
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, false_type)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr&, true_type)
	{	
	const char * const _First1_ch = reinterpret_cast<const char *>(_First1);
	const char * const _First2_ch = reinterpret_cast<const char *>(_First2);
	const size_t _Count = reinterpret_cast<const char *>(_Last1) - _First1_ch;
	return (:: memcmp(_First1_ch, _First2_ch, _Count) == 0);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred)
	{	
	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, input_iterator_tag, input_iterator_tag)
	{	
	return (_Equal_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Equal_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2971);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2972);
	return (_Equal_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "equal" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Equal_no_deprecate(_First1, _Last1, _First2, _Pred));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr,
	class = enable_if_t<!is_same<_InTy *, _Pr>::value>> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (_Equal_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 3000 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}
 #line 3022 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
			input_iterator_tag, input_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3032);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
			random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3049);
	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3059);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3060);
	return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: equal(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _Elem1,
	class _Elem2,
	class _FTy>
	struct _Lex_compare_check_element_types_helper
		: conjunction<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			_Is_character<_FTy>,
			is_unsigned<_FTy>
		>::type
	{	
	};

template<class _Elem1,
	class _Elem2>
	struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
		: conjunction<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			is_unsigned<_Elem1>,
			is_unsigned<_Elem2>
		>::type
	{	
	};

template<class _Memcmp_pr>
	struct _Lex_compare_optimize
	{	
	};

template<class _Memcmp_pr,
	class _Obj1,
	class _Obj2,
	class _FTy>
	using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
		_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
		_Memcmp_pr, void>>;	

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	_Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
	{	
		
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _FTy> inline
	_Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
		_Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
	{	
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred, _Lex_compare_optimize<void>)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3141))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}

	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr,
	class _Memcmp_pr> inline
	bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr&, _Lex_compare_optimize<_Memcmp_pr>)
	{	
	const size_t _Num1 = _Last1 - _First1;
	const size_t _Num2 = _Last2 - _First2;
	const int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Memcmp_pr{}(_Ans, 0) || _Ans == 0 && _Num1 < _Num2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
	{	
	return (_Lex_compare_unchecked1(_First1, _Last1, _First2, _Last2, _Pred,
		_Lex_compare_memcmp_classify(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3179);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3180);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3181);
	return (_Lex_compare_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: lexicographical_compare(_First1, _Last1,
		_First2, _Last2, less<>()));
	}

		
template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
	{	
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	
	return (_Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
	{	
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
	{	
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	
	typedef typename remove_pointer<_InIt>::type _Elem;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
	{	
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	
	typedef integral_constant<bool,
		(is_same<_InIt, char *>::value
		|| is_same<_InIt, signed char *>::value
		|| is_same<_InIt, unsigned char *>::value
		|| is_same<_InIt, const char *>::value
		|| is_same<_InIt, const signed char *>::value
		|| is_same<_InIt, const unsigned char *>::value)
		&& is_integral<_Ty>::value
	> _Memchr_opt;
	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3284);
	return (_Rechecked(_First,
		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	_Iter_diff_t<_InIt>
		_Count_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	_Iter_diff_t<_InIt>
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3320);
	return (_Count_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_Iter_diff_t<_InIt>
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
	{	
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr&,
		forward_iterator_tag, forward_iterator_tag)
	{	
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr& _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	
	
	while (_Pred(*--_Last1, *--_Last2))
		;	
	++_Last1;
	++_Last2;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
	{	
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	
			_Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				return (false);	
			_FwdIt1 _Skip1 = ::std:: next(_Next1);
			_Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				return (false);	
			}

	return (true);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			_FwdIt2 _Last2 = ::std:: next(_First2,
				::std:: distance(_First1, _Last1));
			return (_Check_match_counts(_First1, _Last1,
				_First2, _Last2, _Pred));
			}

	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred, forward_iterator_tag, forward_iterator_tag)
	{	
	return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3429);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3430);
	return (_Is_permutation_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "is_permutation" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Is_permutation_no_deprecate(_First1, _Last1, _First2, _Pred));
	}

 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize,
	class _Pr,
	class = enable_if_t<!is_same<_InTy *, _Pr>::value>> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (_Is_permutation_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 3458 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
	}
 #line 3480 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3490);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			if (::std:: distance(_First1, _Last1)
				!= ::std:: distance(_First2, _Last2))
				return (false);	
			else
				return (_Check_match_counts(_First1, _Last1,
					_First2, _Last2, _Pred));
			}

	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3515);
	return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
		
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3526);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3527);
	return (_Is_permutation_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, _Last2, equal_to<>()));
	}

		
template<class _BidIt> inline
	void _Reverse_unchecked(_BidIt _First, _BidIt _Last)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3554);
	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));
	}

		
template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	
			}
		else if (++_Next == _Last)
			{	
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	
	while (_First != _Sentinel && _Last != _Sentinel)
		::std:: iter_swap(_First++, --_Last);
	return (::std:: make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
	_Reverse_unchecked(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	_Reverse_unchecked(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3625);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3626);
	return (_Rechecked(_First,
		_Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last))));
	}

	
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	
public:
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;


	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits - 1;	
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits - 1;	
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	
	};

		
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 
				_Myptr = (_Elem *)_malloc_dbg(_Count, 2,
					"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3755);

 

#line 3760 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}

		return (*this);
		}

	 ~_Yarn() noexcept
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 
			_free_dbg(_Myptr, 2);

 

#line 3805 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

constexpr allocator_arg_t allocator_arg{};

[[noreturn]] __declspec(dllimport) void __cdecl _Xbad_alloc();
[[noreturn]] __declspec(dllimport) void __cdecl _Xinvalid_argument(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xlength_error(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xout_of_range(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xoverflow_error(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xruntime_error(  const char *);
}

namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};

 
template<class _Ty,
	class _Alloc>
	constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
 #line 3858 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
}	
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3863 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
#line 3864 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"






#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
 #line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma warning(disable: 4100)

namespace std {



 


 

#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 

  


#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

  #line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
inline
	__declspec(allocator) void *_Allocate(size_t _Count, size_t _Sz,
		bool _Try_aligned_allocation = true)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		return (_Ptr);

	
	if ((size_t)(-1) / _Sz < _Count)
		_Xbad_alloc();	
	const size_t _User_size = _Count * _Sz;

 
	if (_Try_aligned_allocation
		&& 4096 <= _User_size)
		{	
		static_assert(sizeof (void *) < 32,
			"Big allocations should at least match vector register size");
		const size_t _Block_size = (2 * sizeof(void *) + 32 - 1) + _User_size;
		if (_Block_size <= _User_size)
			_Xbad_alloc();	
		const uintptr_t _Ptr_container =
			reinterpret_cast<uintptr_t>(::operator new(_Block_size));
		{ if (!(_Ptr_container != 0)) { (void)( (!!(("_Ptr_container != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 70, 0, L"%ls", L"\"_Ptr_container != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 70, 0); } ; };
		_Ptr = reinterpret_cast<void *>((_Ptr_container + (2 * sizeof(void *) + 32 - 1))
			& ~(32 - 1));
		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

 
		static_cast<uintptr_t *>(_Ptr)[-2] = 0xFAFAFAFAUL;
 #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		}
	else
 #line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{	
		_Ptr = ::operator new(_User_size);
		{ if (!(_Ptr != 0)) { (void)( (!!(("_Ptr != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 84, 0, L"%ls", L"\"_Ptr != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 84, 0); } ; };
		}
	return (_Ptr);
	}

		
inline
	void _Deallocate(void * _Ptr, size_t _Count, size_t _Sz)
	{	
 
	{ if (!(_Count <= (size_t)(-1) / _Sz)) { (void)( (!!(("_Count <= (size_t)(-1) / _Sz" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 94, 0, L"%ls", L"\"_Count <= (size_t)(-1) / _Sz\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 94, 0); } ; };
	const size_t _User_size = _Count * _Sz;
	if (4096 <= _User_size)
		{	
		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
		{ if (!((_Ptr_user & (32 - 1)) == 0)) { (void)( (!!(("(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0, L"%ls", L"\"(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0); } ; };
#line 101 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
		const uintptr_t _Ptr_container =
			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

 
		
		
		{ if (!(reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == 0xFAFAFAFAUL)) { (void)( (!!(("reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 110, 0, L"%ls", L"\"reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 110, 0); } ; };
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
		{ if (!(_Ptr_container < _Ptr_user)) { (void)( (!!(("_Ptr_container < _Ptr_user" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 114, 0, L"%ls", L"\"_Ptr_container < _Ptr_user\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 114, 0); } ; };

 
		{ if (!(2 * sizeof(void *) <= _Ptr_user - _Ptr_container)) { (void)( (!!(("2 * sizeof(void *) <= _Ptr_user - _Ptr_container" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 118, 0, L"%ls", L"\"2 * sizeof(void *) <= _Ptr_user - _Ptr_container\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 118, 0); } ; };
#line 119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 


#line 124 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{ if (!(_Ptr_user - _Ptr_container <= (2 * sizeof(void *) + 32 - 1))) { (void)( (!!(("_Ptr_user - _Ptr_container <= _NON_USER_SIZE" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 126, 0, L"%ls", L"\"_Ptr_user - _Ptr_container <= _NON_USER_SIZE\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 126, 0); } ; };
#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		_Ptr = reinterpret_cast<void *>(_Ptr_container);
		}
 #line 131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

	::operator delete(_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...> >
	{	
	typedef _First type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
	{	
	typedef _Ty<_Newfirst, _Rest...> type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 234 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 241 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

	typedef typename _If<is_void<element_type>::value,
		char&,
		typename add_lvalue_reference<element_type>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		using rebind = _Other *;

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_lvalue_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};


		
template<class _Ptrty> inline
	void _Destroy(_Ptrty _Ptr)
	{	
	typedef typename pointer_traits<_Ptrty>::element_type _Ty;
	_Ptr->~_Ty();
	}

		
template<class _Ptrty> inline
	auto _Const_cast(_Ptrty _Ptr)
	{	
	using _Elem = typename pointer_traits<_Ptrty>::element_type;
	using _Modifiable = remove_const_t<_Elem>;
	using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

	return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
	}

template<class _Ty> inline
	auto _Const_cast(_Ty * _Ptr)
	{	
	return (const_cast<remove_const_t<_Ty> *>(_Ptr));
	}


		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 323 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 330 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 337 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 344 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 351 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 357 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 363 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 369 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_is_always_equal
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 375 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	class allocator;
template<class _Alloc>
	struct _Wrap_alloc;

template<class _Alloc>
	struct _Unwrap_alloc
	{	
	typedef _Alloc type;
	};

template<class _Alloc>
	struct _Unwrap_alloc<_Wrap_alloc<_Alloc>>
	{	
	typedef _Alloc type;
	};


		
template<class _Alloc>
	using _Unwrap_alloc_t = typename _Unwrap_alloc<_Alloc>::type;


		
template<class _Alloc,
	class = void>
	struct _Is_default_allocator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
		: true_type
	{	
	};

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Has_no_alloc_construct_tag
	{	
	};

template<class _Void,
	class... _Types>
	struct _Has_no_alloc_construct
		: true_type
	{	
	};

template<class _Alloc,
	class _Ptr,
	class... _Args>
	struct _Has_no_alloc_construct<
		void_t<
			_Has_no_alloc_construct_tag,	
			decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>,
		_Alloc, _Ptr, _Args...>
		: false_type
	{	
	};

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;


		
struct _Has_no_alloc_destroy_tag
	{	
	};

template<class _Alloc,
	class _Ptr,
	class = void>
	struct _Has_no_alloc_destroy
		: true_type
	{	
	};

template<class _Alloc,
	class _Ptr>
	struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<
			_Has_no_alloc_destroy_tag,	
			decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
		: false_type
	{	
	};

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;


		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al) noexcept
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&) noexcept
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)()
			/ sizeof(typename _Ty::value_type));
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;
	typedef typename _Get_is_always_equal<_Alloc>::type
		is_always_equal;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(true_type, _Alloc&, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		::new (static_cast<void *>(_Ptr))
			_Ty(::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
			_Al, _Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty>
		static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
		{	
		_Ptr->~_Ty();
		}

	template<class _Ty>
		static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};

		
template<class _Ty>
	class allocator
	{	
public:
	static_assert(!is_const<_Ty>::value,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	typedef void _Not_user_specialized;

	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef true_type propagate_on_container_move_assignment;
	typedef true_type is_always_equal;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	allocator() noexcept
		{	
		}

	allocator(const allocator<_Ty>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Deallocate(_Ptr, _Count, sizeof (_Ty));
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
		}

	__declspec(allocator) pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		void construct(_Objty *_Ptr, _Types&&... _Args)
		{	
		::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const noexcept
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef void _Not_user_specialized;

	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() noexcept
		{	
		}

	allocator(const allocator<void>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) noexcept
	{	
	return (false);
	}

		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef _Alloc allocator_type;
	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef true_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;
	typedef true_type is_always_equal;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc& _Al, _Objty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;
	typedef typename _Mytraits::is_always_equal
		is_always_equal;

	_Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other>
			_Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (pointer_traits<pointer>::pointer_to(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (pointer_traits<const_pointer>::pointer_to(_Val));
		}

	_Wrap_alloc() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(_Wrap_alloc&& _Right) noexcept
		: _Mybase(::std:: move(_Right))
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other&& _Right) noexcept
		: _Mybase(::std:: forward<_Other>(_Right))
		{	
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(_Wrap_alloc&& _Right)
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(_Other&& _Right)
		{	
		_Mybase::operator=(::std:: forward<_Other>(_Right));
		return (*this);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	__declspec(allocator) pointer allocate(size_type _Count,
		const_void_pointer _Hint, _Nil = _Nil())
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		void construct(_Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Mytraits::construct(*this, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size(_Nil = _Nil()) const noexcept
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (static_cast<const _Ty&>(_Left)
		== static_cast<const _Other&>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
	{	
	_Left = _Right;
	}

template<class _Alty> inline
	void _Pocca(_Alty&, const _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Left = ::std:: move(_Right);
	}

template<class _Alty> inline
	void _Pocma(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Swap_adl(_Left, _Right);
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, false_type) noexcept
	{	
	if (_Left != _Right)
		{	
 
		_Debug_message(L"containers incompatible for swap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 1080);
 

#line 1084 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		}
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}


		
template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range1(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(_Unfancy(_First));
	}

template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range1(_Ptr, _Ptr, _Wrap_alloc<_Alloc>&, true_type)
	{	
		
	}

template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	typedef typename _Alloc::value_type _Val;
	_Destroy_range1(_First, _Last, _Al, typename conjunction<
		is_trivially_destructible<_Val>,
		_Uses_default_destroy<_Alloc, _Val *>>::type());
	}


		
template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
	{	
	for (; _First != _Last; ++_First)
		_Destroy(_First);
	}

template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt, _FwdIt, true_type)
	{	
		
	}

template<class _FwdIt> inline
	void _Destroy_range(_FwdIt _First, _FwdIt _Last)
	{	
		
		
	_Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
	}
}

		
  #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  

#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
   
  #line 44 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  

		
typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

 
  
   
  

#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"





#line 1149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

  
   #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"












#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"









__pragma(pack(push, 8)) extern "C" {






    
    

    typedef struct __JUMP_BUFFER
    {
        unsigned long Ebp;
        unsigned long Ebx;
        unsigned long Edi;
        unsigned long Esi;
        unsigned long Esp;
        unsigned long Eip;
        unsigned long Registration;
        unsigned long TryLevel;
        unsigned long Cookie;
        unsigned long UnwindFunc;
        unsigned long UnwindData[6];
    } _JUMP_BUFFER;





























































































#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"





    
    typedef int jmp_buf[16];
#line 147 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




    
#line 153 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    #pragma warning(push)
    #pragma warning(disable:4987) 
    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) throw(...);
    #pragma warning(pop)





#line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"


} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"



    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"













#pragma once



#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"










#pragma once



#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"







#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




















#pragma once



#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"







#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"



#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"



























#pragma once



#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"














#pragma once






#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"



#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"


extern "C" { 


#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;



void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);

























































#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"


}; 
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 192 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;




#line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 82 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 












































































 
 
 


extern "C" { 
  
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);





extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
#line 282 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"








#line 291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);






extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);
#line 326 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);

extern void _mm_stream_pi(__m64 *, __m64);
#line 350 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
























#line 381 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"







 
 
 


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _m_pcmpgtw(_mm_setzero_si64(), _A);

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _mm_setzero_si64();

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 _A)
{
  return _m_packssdw(_mm_cvt_ps2pi(_A),
                        _mm_cvt_ps2pi(_mm_movehl_ps(_A, _A)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 _A)
{
  __m64  _Ext_val = _m_pcmpgtb(_mm_setzero_si64(), _A);

  return _mm_cvtpi16_ps(_m_punpcklbw(_A, _Ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 _A)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(_A, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 _A)
{
  return _m_packsswb(_mm_cvtps_pi16(_A), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), _A),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), _B));
}
#line 506 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"



}; 
#line 511 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

#line 513 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 514 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 515 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);


extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);
#line 166 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
#line 221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);

extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
#line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);






extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
#line 343 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);

extern __m128i _mm_set1_epi64(__m64 _Q);
#line 354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);

extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
#line 362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);

extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);
#line 389 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);













#line 434 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"


}; 
#line 438 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

#line 440 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 441 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 442 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 35 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 106 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"









extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);


    extern __m64 _mm_hadd_pi16 (__m64, __m64);
    extern __m64 _mm_hadd_pi32 (__m64, __m64);
    extern __m64 _mm_hadds_pi16 (__m64, __m64);
#line 54 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_hsub_pi16 (__m64, __m64);
    extern __m64 _mm_hsub_pi32 (__m64, __m64);
    extern __m64 _mm_hsubs_pi16 (__m64, __m64);
#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_maddubs_pi16 (__m64, __m64);
#line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);


    extern __m64 _mm_mulhrs_pi16 (__m64, __m64);
#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);


    extern __m64 _mm_shuffle_pi8 (__m64, __m64);
#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);


    extern __m64 _mm_sign_pi8 (__m64, __m64);
    extern __m64 _mm_sign_pi16 (__m64, __m64);
    extern __m64 _mm_sign_pi32 (__m64, __m64);
#line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);


    extern __m64 _mm_alignr_pi8 (__m64, __m64, int);
#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);


    extern __m64 _mm_abs_pi8 (__m64);
    extern __m64 _mm_abs_pi16 (__m64);
    extern __m64 _mm_abs_pi32 (__m64);
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"


};
#line 144 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 147 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 148 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"


















































extern "C" {
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );



#line 194 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );



#line 203 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        



        extern __m128i _mm_stream_load_si128(const __m128i*);


}; 
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 260 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 261 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 262 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"



extern "C" {
#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );



#line 121 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );



#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"


}; 
#line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 141 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"



extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 92 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"


extern "C" {
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);


#line 1233 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);


#line 1243 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);


#line 1252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);


#line 1262 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);


#line 1272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);


#line 1282 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);


#line 1291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);


#line 1300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);


#line 1312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

















#line 1330 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );







extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );

























#line 1854 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);


#line 1866 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);


#line 1878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);




















#line 1937 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);


#line 1965 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );







#line 1987 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


}; 
#line 2039 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 2041 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2042 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2043 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"












#pragma once



#line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"







#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"



#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


extern "C" { 
#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);



#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);








#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);











#line 300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);


}; 
#line 309 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

#line 311 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 313 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"















#pragma once



#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"







#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"




extern "C" { 
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"



void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


}; 
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


extern "C" {
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




























#line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"






#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 100 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 122 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);


unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);





















long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);









char _InterlockedAnd8(char volatile * _Value, char _Mask);








long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);






short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);








long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);










long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);






long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);










long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);









char _InterlockedOr8(char volatile * _Value, char _Mask);








long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);









char _InterlockedXor8(char volatile * _Value, char _Mask);
















void _ReadBarrier(void);






void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);






void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);








void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);








unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);





unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);







unsigned char _interlockedbittestandset(long volatile *, long);

















  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);
__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);
__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(const __m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);


void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}
#line 1134 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1136 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 1152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

   

   


  






#line 1166 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		: _Ptr()
		{	
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pstring);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Unfancy(_Ptr) < _Contptr
			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
			{	
			_Debug_message(L"string iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 76);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 77, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 77, 0); };
			}

 





#line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		;

		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Mycont->_Myptr() + _Mycont->_Mysize <= _Unfancy(_Ptr))
			{	
			_Debug_message(L"string iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 106);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 107, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 107, 0); };
			}

 




#line 116 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Unfancy(_Ptr) <= _Mycont->_Myptr())
			{	
			_Debug_message(L"string iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 136);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 137, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 137, 0); };
			}

 




#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
			const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
			if (_Mycont == 0
				|| _Ptr == nullptr_t{}
				|| _Unfancy(_Ptr) + _Off < _Contptr
				|| _Contptr + _Mycont->_Mysize < _Unfancy(_Ptr) + _Off)
				{
				_Debug_message(L"string iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 170);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 171, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 171, 0); };
				}
			}

 









#line 186 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			{
			_Debug_message(L"string iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 256);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 257, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 257, 0); };
			}
		}

 









#line 272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Const_cast(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		: _Bx(),
		_Mysize(0),
		_Myres(0)
		{	
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= _Myres
			? _Unfancy(_Bx._Ptr)
			: _Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= _Myres
			? _Unfancy(_Bx._Ptr)
			: _Bx._Buf);
		}

	union _Bxty
		{	
		_Bxty()
			{	
			}

		~_Bxty() noexcept
			{	
			}

		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<class _Alloc_types>
	class _String_alloc
	{	
public:
	typedef _String_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_String_val<_Val_types> > iterator;
	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;

	enum
		{	
		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
		};

	enum
		{	
		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
		};

	value_type *_Myptr()
		{	
		return (_Get_data()._Myptr());
		}

	const value_type *_Myptr() const
		{	
		return (_Get_data()._Myptr());
		}

 























#line 611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
	_String_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_String_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Alloc_proxy();
		}

	~_String_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 679 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_String_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _String_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	typedef typename _String_val<_Val_types>::_Bxty _Bxty;

	_Bxty& _Bx() noexcept
		{	
		return (_Get_data()._Bx);
		}

	const _Bxty& _Bx() const noexcept
		{	
		return (_Get_data()._Bx);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

	size_type& _Myres() noexcept
		{	
		return (_Get_data()._Myres);
		}

	const size_type& _Myres() const noexcept
		{	
		return (_Get_data()._Myres);
		}

private:
	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 868);
		_Tidy();
		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		size_type _Count = ::std:: distance(_First, _Last);
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem *_First,
		_Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	void _Construct(const _Elem *_First,
		const _Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 928 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) noexcept
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres())
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres() < this->_BUF_SIZE)
			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
				_Right._Mysize() + 1);
		else
			{	
			this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);
			_Right._Bx()._Ptr = pointer();
			}
		this->_Mysize() = _Right._Mysize();
		this->_Myres() = _Right._Myres();
		_Right._Tidy();
		}

	basic_string(::std:: initializer_list<_Elem> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& assign(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& append(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
		}

	~basic_string() noexcept
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Copy_alloc(_Right._Getal());
				}

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1088);
		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1106);
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Chassign(this->_Mysize(), _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

		if (this == &_Right)
			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	
		else if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1166);
		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1181);
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1251);
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		_Check_offset(_Off);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1272);
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		_Check_offset(_Off);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		_Check_offset(_Off);
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		_Check_offset(_Off);
		if (this->_Mysize() - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize() - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Where - begin();
		erase(_Count, 1);
		return (begin() + _Count);
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1370);
		size_type _Count = _First - begin();
		erase(_Count, _Last - _First);
		return (begin() + _Count);
		}

	void clear() noexcept
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff,
			size_type _Count = npos)
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	

		const size_type _Nm = this->_Mysize() - _N0 - _Off;	
		const size_type _Newsize = this->_Mysize() + _Count - _N0;
		if (this->_Mysize() < _Newsize)
			_Grow(_Newsize);

		if (_Count == _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count < _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1454);
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		_Check_offset(_Off);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		const size_type _Num = this->_Mysize() + _Count - _N0;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1484);
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		_Check_offset(_Off);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		const size_type _Num = this->_Mysize() + _Count - _N0;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(_First - begin(), _Last - _First, _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
		}

	const_iterator begin() const noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
		}

	iterator end() noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
		}

	const_iterator end() const noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	reference at(size_type _Off)
		{	
		_Check_offset_exclusive(_Off);
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		_Check_offset_exclusive(_Off);
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1682);

 

#line 1687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1695);

 

#line 1700 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		auto& _Dx = this->_Get_data();
		auto& _Sz = _Dx._Mysize;
		if (_Sz == _Dx._Myres)
			_Grow(_Sz + 1); 
		auto _Ptr = _Dx._Myptr();
		_Traits::assign(_Ptr[_Sz], _Ch);
		++_Sz;
		_Traits::assign(_Ptr[_Sz], _Elem());
		}

	void pop_back()
		{	
		erase(this->_Mysize() - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	const _Elem *c_str() const noexcept
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const noexcept
		{	
		return (this->_Myptr());
		}






#line 1757 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	size_type length() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		const size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize())
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize(), _Ch);
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myres());
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
			{	
			size_type _Size = this->_Mysize();
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const noexcept
		{	
		return (this->_Mysize() == 0);
		}

	__declspec(deprecated("Call to 'std::" "basic_string::copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'"))
	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1811);
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1821);
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres())
			if (this->_BUF_SIZE <= _Right._Myres())
				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx()._Ptr;
				this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
				_Traits::copy(this->_Bx()._Buf,
					_Right._Bx()._Buf, _Right._Mysize() + 1);
				this->_Getal().construct(::std:: addressof(_Right._Bx()._Ptr), _Ptr);
				}
		else
			if (_Right._Myres() < this->_BUF_SIZE)
				::std:: swap(this->_Bx()._Buf, _Right._Bx()._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx()._Ptr;
				this->_Getal().destroy(::std:: addressof(_Right._Bx()._Ptr));
				_Traits::copy(_Right._Bx()._Buf,
					this->_Bx()._Buf, this->_Mysize() + 1);
				this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
				}
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1857 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1876);
		if (_Count == 0 && _Off <= this->_Mysize())
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1896);
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1913);
		if (_Count == 0)
			return (_Off < this->_Mysize() ? _Off
				: this->_Mysize());	
		if (_Count <= this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize() - _Count ? _Off
					: this->_Mysize() - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1935);
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1953);
		if (0 < _Count && _Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1969);
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1988);
		if (0 < _Count && 0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2006);
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2026);
		if (_Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2041);
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2060);
		if (0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2077);
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size,
		const _Elem * const _Right, const size_type _Right_size)
		{	
		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

		if (_Ans != 0)
			return (_Ans);

		if (_Left_size < _Right_size)
			return (-1);

		if (_Left_size > _Right_size)
			return (1);

		return (0);
		}

	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
		{	
		const size_type _Max_effective_size = this->_Mysize() - _Off;
		if (_Size <= _Max_effective_size)
			return (_Size);
		else
			return (_Max_effective_size);
		}

	int compare(const _Myt& _Right) const noexcept
		{	
		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
			_Right._Myptr(), _Right._Mysize()));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right) const
		{	
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Right._Myptr(), _Right._Mysize()));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count = npos) const
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
		}

	int compare(const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2145);
		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
			_Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2152);
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2161);
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Ptr, _Count));
		}

	allocator_type get_allocator() const noexcept
		{	
		allocator_type _Ret(this->_Getal());
		return (_Ret);
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres() / 2 <= _Newres / 3)
			;
		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
			_Newres = this->_Myres()
				+ this->_Myres() / 2;	
		else
			_Newres = max_size();	

		pointer _Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
		this->_Myres() = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		auto& _Dx = this->_Get_data();
		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres() < _Newsize)
			_Copy(_Newsize, this->_Mysize());	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize() <= _Ptr)
			return (false);	
		else
			return (true);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres())
			{	
			pointer _Ptr = this->_Bx()._Ptr;
			this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
			if (0 < _Newsize)
				_Traits::copy(this->_Bx()._Buf,
					_Unfancy(_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
			}
		this->_Myres() = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	void _Check_offset(const size_type _Off) const
		{	
		if (this->_Mysize() < _Off)
			_Xran();
		}

	void _Check_offset_exclusive(const size_type _Off) const
		{	
		if (this->_Mysize() <= _Off)
			_Xran();
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
		size_type;
	return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2664 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
#line 2665 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 68 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 124 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 180 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 208 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 236 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 271 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"














#pragma once







#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"


#pragma pack(push, 8)






#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610) 
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const  _DecoratedName[1];
};
#pragma warning(pop)

__declspec(dllimport) int __cdecl __std_type_info_compare(
      __std_type_info_data const* _Lhs,
      __std_type_info_data const* _Rhs
    );

__declspec(dllimport) size_t __cdecl __std_type_info_hash(
      __std_type_info_data const* _Data
    );

__declspec(dllimport) char const* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))



class type_info
{
public:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const throw()
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    }

    char const* raw_name() const throw()
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    mutable __std_type_info_data _Data;
};

namespace std {
	using ::type_info;
}



namespace std {

class bad_cast
    : public exception
{
public:

    bad_cast() throw()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() throw()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message) throw()
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int) throw()
        : bad_typeid(_Message, 1)
    {
    }
};

} 

#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"

 























































#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)
#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"
#line 94 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"







#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {









  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);










    
    
    






















    
    
    
        __declspec(dllimport) int __cdecl _chvalidator(  int _Ch,   int _Mask);
        
    

#line 115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"



    
    
    
    
    
    
    
    



    












#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    
    __declspec(dllimport) int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    #line 153 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"

    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        
        return _chvalidator_l(_Locale, _C, _Mask);
        






#line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 221 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"



    
    
    
    
#line 229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"



#line 233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\locale.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;























    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
          int _Flag
        );

    
    __declspec(dllimport) char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
          _locale_t _Locale
        );

    
    
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    
     
     
    __declspec(dllimport) char*    __cdecl _Getdays(void);

     
     
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

     
    __declspec(dllimport) size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
    __declspec(dllimport) size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );

#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\locale.h"


} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 
  
extern "C" {
  #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll(void);
__declspec(dllimport) _Ctypevec __cdecl _Getctype(void);
__declspec(dllimport) _Cvtvec __cdecl _Getcvt(void);
__declspec(dllimport) int __cdecl _Getdateorder(void);

 








__declspec(dllimport) int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

__declspec(dllimport) float __cdecl _Stof(const char *,
	    char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
	    char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
	    char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

 
  
}
  #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"


extern "C" {
 
 
__declspec(dllimport) char *__cdecl _Getdays(void);

 
 
__declspec(dllimport) char *__cdecl _Getmonths(void);

__declspec(dllimport) void *__cdecl _Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,   const char *,   const struct tm *,
	  void *);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getdays(void);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths(void);

__declspec(dllimport) void *__cdecl _W_Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,   const wchar_t *,   const struct tm *,
	  void *);
}

 







__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 174 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 180 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() noexcept
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() noexcept
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	
 #line 227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
#line 302 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class __declspec(dllimport) _Facet_base
	{	
public:
	virtual  ~_Facet_base() noexcept
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

 



#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

struct __declspec(dllimport) _Crt_new_delete
	{	
  
	void * __cdecl operator new(size_t _Size)
		{	
		void * _Ptr = operator new(_Size, nothrow);
		if (!_Ptr)
			_Xbad_alloc();
		return (_Ptr);
		}

	void * __cdecl operator new(size_t _Size, const nothrow_t&) noexcept
		{	
		return (_malloc_dbg(_Size > 0 ? _Size : 1, 2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 74));
		}

	void __cdecl operator delete(void * _Ptr) noexcept
		{	
		:: free(_Ptr);
		}

	void __cdecl operator delete(void * _Ptr, const nothrow_t&) noexcept
		{	
		operator delete(_Ptr);
		}

	void * __cdecl operator new(size_t, void *_Ptr) noexcept
		{	
		return (_Ptr);
		}

	void __cdecl operator delete(void *, void *) noexcept
		{	
		}
  #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		: public _Facet_base, public _Crt_new_delete
		{	
	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

		virtual void  _Incref()
			{	
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
			}

		virtual _Facet_base * _Decref()
			{	
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Myrefs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() noexcept
			{	
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() noexcept
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 237 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet< ::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 323 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	locale(const locale& _Right) noexcept
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() noexcept
		: _Ptr(_Init(true))
		{	
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj;
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj(_Cat, _Str.c_str());
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}

		if (_Bad)
			{	
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		_Construct(_Str, _Cat);
		}
 #line 428 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	~locale() noexcept
		{	
		if (_Ptr != 0)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) noexcept
		{	
		if (_Ptr != _Right._Ptr)
			{	
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 446 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static __declspec(dllimport) const locale& __cdecl
		classic();	

	static __declspec(dllimport) locale __cdecl
		global(const locale&);	

	static __declspec(dllimport) locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

	static __declspec(dllimport) _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static __declspec(dllimport) _Locimp *__cdecl
		_Getgloballocale();
	static __declspec(dllimport) void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 534 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 559 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 579 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 592 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			_Facet_Register(_Pfmod);
 #line 594 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 599 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 678 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 711 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 723);

	if (!_Ptrdest)
		_Xbad_alloc();

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 756);

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 796);

	if (!_Ptrdest)
		_Xbad_alloc();

	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 811 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const noexcept
		{	
		return (do_always_noconv());
		}

	int  max_length() const noexcept
		{	
		return (do_max_length());
		}

	int  encoding() const noexcept
		{	
		return (do_encoding());
		}

	 ~codecvt_base() noexcept
		{	
		}

protected:
	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (1);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

		
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		
template<>
	class __declspec(dllimport) codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate <= 1)
				;	
			else if (_By < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				{	
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			_Nskip = _Nextra < 3 ? 0 : 1;	
			_First1 = _Mid1;	

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				break;	
			else
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);
			if (0 < _Nskip)
				_Ch <<= 6;	

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				return (_Mybase::error);	
			else if (0xffff < _Ch)
				{	
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip == 0)
				;
			else if (_Mid1 == _Last1)
				{	
				_Mid1 = _First1;
				break;
				}
			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				_Ch |= _By & 0x3f;	

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned long _Ch;
			unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	
				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	
				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
				_Save = true;	
				}
			else
				_Ch = _Ch1;	

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x10000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				break;	
			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
				;	
			else if (_Last2 - _Mid2 < 3 + _Nput)
				break;	
			else
				{	
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	
				*_Mid2++ = _By;
				--_Nput;
				}
			for (; 0 < _Nput; --_Nput)
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		for (; _Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & _Consume_header) != 0 ? 9	
			: (_Mode & _Generate_header) != 0 ? 7	
			: 6);	
		}

	virtual int do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1)
				break;	
			else
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				return (_Mybase::error);	
			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x00010000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else if (_Ch < 0x00200000)
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
			else if (_Ch < 0x04000000)
				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
			else
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;
				if ((_Mode & _Generate_header) == 0)
					;
				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
					return (_Mybase::partial);	
				else
					{	
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				break;	

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		_Mid2 = _First2;
		return (_Mybase::ok);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		int _Wchars = 0;
		_Statype _Mystate = _State;

		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (int)(_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int  do_encoding() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1674);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1675);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1710);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1711);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1747);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1772);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1908);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1909);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1944);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1945);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1981);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2006);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2060 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname() noexcept
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
		cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
		lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
		punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
		xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() noexcept
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2235);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2244);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2253);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2271);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2293);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2311);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2336);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2370);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2379);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2388);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const noexcept
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() noexcept
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() noexcept
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			:: free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] _Ctype._Table;

		:: free(_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2518);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2532);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2546);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2559);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2692);
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2699);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2708);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2722);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2736);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2758);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2780);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2916);
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2924);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2933);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2947);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2961);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2983);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 3005);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3016 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

 

  
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
  #line 3066 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
 #line 3067 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3072 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 3073 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"

#pragma once











 
#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"




#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"
#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 




namespace std {
		

enum class errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};

typedef errc _Errc;

		

enum class io_errc {	
	stream = 1
	};

typedef io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;
 #line 132 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<_Errc>
		: public true_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;
 #line 150 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;

		
class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
	{	
public:
	 error_category() noexcept	
		{	
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() noexcept
		{	
		}

	virtual const char *name() const noexcept = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const noexcept;

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const noexcept;

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const noexcept;

	bool operator==(const error_category& _Right) const noexcept
		{	
		return (_Addr == _Right._Addr);
		}

	bool operator!=(const error_category& _Right) const noexcept
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const noexcept
		{	
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code() noexcept
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_code_enum<_Enum>::value,
			void>::type>
		error_code(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const noexcept;

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() noexcept
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_condition_enum<_Enum>::value,
			void>::type>
		error_condition(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline bool operator==(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
inline bool operator<(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

inline bool operator<(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		
inline error_condition
	error_category::default_error_condition(int _Errval) const noexcept
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const noexcept
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const noexcept
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const noexcept
	{	
	return (category().default_error_condition(value()));
	}

		
inline error_code make_error_code(_Errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(_Errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
	{	
	typedef error_code argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class _System_error
	: public runtime_error
	{	
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	
		if (!_Message.empty())
			_Message.append(": ");
		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
		{	
		}

	error_code _Mycode;	
	};

class system_error
	: public _System_error
	{	
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	const error_code& code() const noexcept
		{	
		return (_Mycode);
		}

 

 





#line 582 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
	};

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) int __cdecl _Winerror_map(int);
__declspec(dllimport) unsigned long __cdecl _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category() noexcept
		{	
		_Addr = _Generic_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		return (_Syserror_map(_Errcode));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category() noexcept
		{	
		_Addr = _Iostream_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public error_category
	{	
public:
	_System_error_category() noexcept
		{	
		_Addr = _System_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(
			static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

		if (_Val == 0)
			return ("unknown error");

		_Narrow.resize(_Val);
		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	virtual error_condition
		default_error_condition(int _Errval) const noexcept
		{	
		int _Posv = _Winerror_map(_Errval);

		if (_Posv != 0)
			return (error_condition(_Posv, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Ty>
	struct _Immortalizer
	{	
	_Immortalizer()
		{	
		::new (static_cast<void *>(&_Storage)) _Ty();
		}

	~_Immortalizer() noexcept
		{	
		}

	_Immortalizer(const _Immortalizer&) = delete;
	_Immortalizer& operator=(const _Immortalizer&) = delete;

	typename aligned_union<1, _Ty>::type _Storage;
	};

template<class _Ty> inline
	_Ty& _Immortalize()
	{	
	 static _Immortalizer<_Ty> _Static;
	return (*reinterpret_cast<_Ty *>(&_Static._Storage));
	}

inline const error_category& generic_category() noexcept
	{	
	return (_Immortalize<_Generic_error_category>());
	}

inline const error_category& iostream_category() noexcept
	{	
	return (_Immortalize<_Iostream_error_category>());
	}

inline const error_category& system_category() noexcept
	{	
	return (_Immortalize<_System_error_category>());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 721 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
#line 722 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\ucrt\\share.h"







#pragma once



#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
	static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
	static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
	static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
	static constexpr _Fmtflags left = (_Fmtflags)0x0040;
	static constexpr _Fmtflags right = (_Fmtflags)0x0080;
	static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
	static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
	static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
	static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
	static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
	static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)0x40;
	static constexpr _Openmode _Noreplace = (_Openmode)0x80;
	static constexpr _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

 
	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;
 #line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);

 
	typedef unsigned int io_state, open_mode, seek_dir;
 #line 222 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

			
	class failure

		: public system_error
		{	
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}


 

 





#line 251 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() noexcept
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	
		return (!fail());
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

 
	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}
 #line 312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

 
	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}
 #line 336 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

 
	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}
 #line 375 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() noexcept	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			
	struct _Iosarray
		: public _Crt_new_delete
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		: public _Crt_new_delete
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 658 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
#line 659 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() noexcept
		{	
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

 
	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}
 #line 103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

 
	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
 #line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

 
	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}
 #line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 

  
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
  #line 476 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

  



 #line 482 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()
		{	
		}

	istreambuf_iterator(istream_type& _Istr) noexcept
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem operator*() const
		{	
		if (!_Got)
			_Peek();

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 517);
 #line 519 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 532);
 #line 534 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) noexcept
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) noexcept
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const noexcept
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 682 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"
#line 683 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

extern __declspec(dllimport) float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) long long __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long long __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

namespace std {

	
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	
	int& _Errno_ref = (*_errno());	
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	double _Val = :: strtod(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: pow(10.0, static_cast<double>(_Pten));

	return (_Val);
	}

	
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	
	int& _Errno_ref = (*_errno());	
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	float _Val = :: strtof(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: powf(10.0f, static_cast<float>(_Pten));

	return (_Val);
	}


template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 102);

	if (!_Ptrdest)
		_Xbad_alloc();
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() noexcept
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 213 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		:: free((void *)_Grouping);
		:: free((void *)_Falsename);
		:: free((void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname() noexcept
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 427);
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 464);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 487);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 509);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 529);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 549);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long long _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 569);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long long _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}







	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 595);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		float _Ans = _Stofx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 619);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 643);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		long double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}



	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 669);
		char _Ac[32], *_Ep;
		int _Errno = 0;

		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned long long _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned long long):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		char *_Leading = _Ptr;	
		*_Ptr++ = '0';	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (_Max_sig_dig <= _Significant)
					{	
					++_Pten;
					if (0 < _Idx)
						_Sticky = true;
					}
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						{	
						++_Pten;
						if (0 < _Idx)
							_Sticky = true;
						}
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (*_Phexexp != 1000000000 && _Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < _Max_sig_dig)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	

		if (_Sticky)
			{	
			char *_Px = _Ptr;
			for (; --_Px != _Leading; )
				{	
				if (*_Px == localeconv()->decimal_point[0])
					;	
				else if (*_Px != '9')
					{	
					++*_Px;
					break;
					}
				else
					*_Px = '0';	
				}

			if (_Px == _Leading)
				{	
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				|| *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (_Max_sig_dig <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < _Max_sig_dig)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}



	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1256);
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabs(_Val))
			{	
			int _Ptwo;
			(void):: frexp(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabsl(_Val))
			{	
			int _Ptwo;
			(void):: frexpl(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1414);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1516);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, (void)++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

  
template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  #line 1610 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

  






 #line 1619 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1624 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
#line 1625 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() noexcept
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

 
	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}
 #line 55 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

 
	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}
 #line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) noexcept
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

public:
	 basic_ios(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;
	};

 

  
template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;
  #line 205 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

  



 #line 211 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}


namespace tr1 {	
using ::std:: hexfloat;
}	
#line 254 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 368 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"
#line 369 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_ostream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() noexcept
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 198);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 204);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 211);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 562);
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	

	

  

















































 

  
template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  #line 681 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

  



 #line 687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1030 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
#line 1031 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_istream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 199);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 205);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 212);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 572);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 675);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 732);
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Count && 0 < _Num)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 758);
			read(_Str, _Num < _Count ? _Num : _Count);	
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

 #pragma vtordisp(pop)	

  






















 

  
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
  #line 926 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

  



 #line 932 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_iostream() noexcept
		{	
		}
	};

	

 

  
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
  #line 995 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

  



 #line 1001 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 1009);
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"
#line 1152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
  











		
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

		
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;
private:
	 static int _Init_cnt;
	};
  #line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"





#line 3 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\vec2.h"

namespace spork { namespace maths {
		struct vec2 
		{
			float x, y;
				
			vec2();
			vec2(const float& x, const float& y);

			vec2& add(const vec2& other);
			vec2& subtract(const vec2& other);
			vec2& multiply(const vec2& other);
			vec2& divide(const vec2& other);

			
			friend vec2 operator+(vec2 left, const vec2& right);
			friend vec2 operator-(vec2 left, const vec2& right);
			friend vec2 operator*(vec2 left, const vec2& right);
			friend vec2 operator/(vec2 left, const vec2& right);
			
			
			bool operator==(const vec2& other);
			bool operator!=(const vec2& other);
			
			
			vec2& operator+=(const vec2& other);
			vec2& operator-=(const vec2& other);
			vec2& operator*=(const vec2& other);
			vec2& operator/=(const vec2& other);

			friend std::ostream& operator<<(std::ostream& stream, const vec2& vec);
		};
	}
}
#line 5 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\vec3.h"
#pragma once


namespace spork { namespace maths {
		struct vec3 
		{
			float x, y, z;
				
			vec3();
			vec3(const float& x, const float& y, const float& z);

			static vec3 up();
			static vec3 down();
			static vec3 left();
			static vec3 right();
			static vec3 zero();

			static vec3 xAxis();
			static vec3 yAxis();
			static vec3 zAxis();

			vec3& add(const vec3& other);
			vec3& subtract(const vec3& other);
			vec3& multiply(const vec3& other);
			vec3& divide(const vec3& other);

			vec3& add(float other);
			vec3& subtract(float other);
			vec3& multiply(float other);
			vec3& divide(float other);

			
			friend vec3 operator+(vec3 left, const vec3& right);
			friend vec3 operator-(vec3 left, const vec3& right);
			friend vec3 operator*(vec3 left, const vec3& right);
			friend vec3 operator/(vec3 left, const vec3& right);

			friend vec3 operator+(vec3 left, float right);
			friend vec3 operator-(vec3 left, float right);
			friend vec3 operator*(vec3 left, float right);
			friend vec3 operator/(vec3 left, float right);

			
			
			bool operator==(const vec3& other);
			bool operator!=(const vec3& other);

			
			vec3& operator+=(const vec3& other);
			vec3& operator-=(const vec3& other);
			vec3& operator*=(const vec3& other);
			vec3& operator/=(const vec3& other);

			float magnitude() const;
			vec3 normalize() const;
			float dot(const vec3& other) const;
			vec3 cross(const vec3& other) const;

			friend std::ostream& operator<<(std::ostream& stream, const vec3& vec);
		};
	}
}
#line 6 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\vec4.h"
#pragma once


namespace spork { namespace maths {
		struct vec4 
		{
			float x, y, z, w;
				
			vec4();
			vec4(const float& x, const float& y, const float& z, const float& w);

			vec4& add(const vec4& other);
			vec4& subtract(const vec4& other);
			vec4& multiply(const vec4& other);
			vec4& divide(const vec4& other);

			
			friend vec4 operator+(vec4 left, const vec4& right);
			friend vec4 operator-(vec4 left, const vec4& right);
			friend vec4 operator*(vec4 left, const vec4& right);
			friend vec4 operator/(vec4 left, const vec4& right);
			
			
			bool operator==(const vec4& other);
			bool operator!=(const vec4& other);

			
			vec4& operator+=(const vec4& other);
			vec4& operator-=(const vec4& other);
			vec4& operator*=(const vec4& other);
			vec4& operator/=(const vec4& other);

			friend std::ostream& operator<<(std::ostream& stream, const vec4& vec);
		};
}	}
#line 7 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\mat4.h"
#pragma once





namespace spork { namespace maths {
	
	struct mat4
	{
	public:
		union {
			float elements[4 * 4];
			vec4 columns[3];
		};

		mat4();
		mat4(float diagonal);

		static mat4 identity();
		
		mat4& multiply(const mat4& other);
		friend mat4 operator*(mat4 left, const mat4& right);
		mat4& operator*=(const mat4& other);

		
		mat4& invert();

		
		vec3 multiply(const vec3& other) const;
		friend vec3 operator*(const mat4& left, const vec3& right);

		
		vec4 multiply(const vec4& other) const;
		friend vec4 operator*(const mat4& left, const vec4& right);

		
		static mat4 orthographic(float left, float right, float bottom, float top, float near, float far);
		static mat4 perspective(float fov, float aspectRatio, float near, float far);
		
		static mat4 translate(const vec3& translate);
		static mat4 rotation(float angle, const vec3& axis);
		static mat4 scale(const vec3& scale);

	};	

}	}
#line 8 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\quaternion.h"
#pragma once



namespace spork { namespace maths {

	struct Quaternion 
	{
		float x, y, z, w;

		Quaternion();
		Quaternion(const Quaternion& quat);
		Quaternion(float x, float y, float z, float w);
		Quaternion(const vec3& xyz, float w);
		Quaternion(vec4& vec);
		Quaternion(float scalar);

		Quaternion setXYZ(const vec3& vec);
		const vec3 getXYZ() const;

		vec3 getAxis() const;
		vec3 toEuler() const;
		static Quaternion identity();
		static Quaternion fromEuler(const vec3& right);

		Quaternion& operator=(const Quaternion& quat);
		const Quaternion operator+(const Quaternion& quaternion) const;
		const Quaternion operator-(const Quaternion& quaternion) const;
		const Quaternion operator*(const Quaternion& quaternion) const;
		const Quaternion operator*(float scalar) const;
		const Quaternion operator/(float scalar) const;
		const Quaternion operator-() const;

		static vec3 rotate(const Quaternion &quat, const vec3& vec);
		static const Quaternion rotation(const vec3& unitVec0, const vec3& unitVec1);
		static const Quaternion rotation(float radians, const vec3& unitVec);

		static const Quaternion rotationX(float radians)
		{
			float angle = radians * 0.5f;
			return Quaternion(sin(angle), 0.0f, 0.0f, cos(angle));
		}

		static const Quaternion rotationY(float radians)
		{
			float angle = radians * 0.5f;
			return Quaternion(0.0f, sin(angle), 0.0f, cos(angle));
		}

		static const Quaternion rotationZ(float radians)
		{
			float angle = radians * 0.5f;
			return Quaternion(0.0f, 0.0f, sin(angle), cos(angle));
		}

		float dot(const Quaternion& other) const;
		Quaternion conjugate() const;

	};

} }
#line 9 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\maths\\maths.h"
#line 3 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\buffer.h"
#pragma once

#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















































































#line 87 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 90 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 93 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 96 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 99 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 102 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

































#line 136 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 139 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


#line 142 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 143 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



#line 147 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 148 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





#line 154 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



#line 158 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 159 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 164 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 169 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"







#line 177 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 186 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 191 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

#line 193 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 194 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 209 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















































#line 257 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













extern "C" {
#line 272 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;



#line 298 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
typedef signed long long GLint64EXT;
typedef unsigned long long GLuint64EXT;






#line 307 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
typedef GLint64EXT  GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
























































































































































































































































































































































































































































































































































__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const void *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, void* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const void *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);



#line 1188 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 1199 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





#line 1205 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"





















#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"
#pragma once
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"



















#pragma warning(push)
#pragma warning(disable:4001) 
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"
#pragma once
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"



#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"


























































#pragma warning(pop)
#line 89 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"
#line 90 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"

#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winpackagefamily.h"
#line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"





























































#line 89 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"

















































#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"



#line 147 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"






#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"





#line 160 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"



#line 164 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"











#line 176 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"






































 

















#line 233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"



#pragma warning(pop)
#line 238 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"
#line 239 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"

#line 241 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\shared\\winapifamily.h"
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"


extern "C" {
#line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"


















#pragma region Desktop Family















#line 63 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"

const GLubyte* __stdcall gluErrorString (
    GLenum   errCode);

const wchar_t* __stdcall gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* __stdcall gluGetString (
    GLenum   name);

void __stdcall gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void __stdcall gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void __stdcall gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void __stdcall gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int __stdcall gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int __stdcall gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int __stdcall gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int __stdcall gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int __stdcall gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);



class GLUnurbs;
class GLUquadric;
class GLUtesselator;


typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;













#line 180 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"


GLUquadric* __stdcall gluNewQuadric (void);
void __stdcall gluDeleteQuadric (
    GLUquadric          *state);

void __stdcall gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void __stdcall gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void __stdcall gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void __stdcall gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void __stdcall gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void __stdcall gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void __stdcall gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (__stdcall* fn)());

GLUtesselator* __stdcall  gluNewTess(          
    void );

void __stdcall  gluDeleteTess(       
    GLUtesselator       *tess );

void __stdcall  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void __stdcall  gluTessBeginContour( 
    GLUtesselator       *tess );

void __stdcall  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void __stdcall  gluTessEndContour(   
    GLUtesselator       *tess );

void __stdcall  gluTessEndPolygon(   
    GLUtesselator       *tess );

void __stdcall  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void __stdcall  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void __stdcall  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (__stdcall *fn)());

void __stdcall  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* __stdcall gluNewNurbsRenderer (void);

void __stdcall gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void __stdcall gluBeginSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginTrim (
    GLUnurbs            *nobj);

void __stdcall gluEndTrim (
    GLUnurbs            *nobj);

void __stdcall gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void __stdcall gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void __stdcall 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void __stdcall 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void __stdcall 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void __stdcall 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void __stdcall 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (__stdcall* fn)() );





typedef void (__stdcall* GLUquadricErrorProc) (GLenum);


typedef void (__stdcall* GLUtessBeginProc)        (GLenum);
typedef void (__stdcall* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (__stdcall* GLUtessVertexProc)       (void *);
typedef void (__stdcall* GLUtessEndProc)          (void);
typedef void (__stdcall* GLUtessErrorProc)        (GLenum);
typedef void (__stdcall* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (__stdcall* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (__stdcall* GLUtessVertexDataProc)   (void *, void *);
typedef void (__stdcall* GLUtessEndDataProc)      (void *);
typedef void (__stdcall* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );


typedef void (__stdcall* GLUnurbsErrorProc)   (GLenum);













































































































































































void __stdcall   gluBeginPolygon( GLUtesselator *tess );

void __stdcall   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void __stdcall   gluEndPolygon(   GLUtesselator *tess );















#line 584 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"
#pragma endregion


}
#line 589 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"

#line 591 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"
#line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\glu.h"
#line 1206 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 1207 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
#line 1208 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















































typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void (__stdcall * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);








#line 1268 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 1277 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"







































































































typedef void (__stdcall * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, void *img);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);


















































#line 1477 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














































typedef void (__stdcall * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void (__stdcall * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (__stdcall * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void (__stdcall * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);



















































#line 1622 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

























































typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void (__stdcall * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
typedef void (__stdcall * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (__stdcall * PFNGLISQUERYPROC) (GLuint id);
typedef void* (__stdcall * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERPROC) (GLenum target);























#line 1725 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



























































































typedef void (__stdcall * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint (__stdcall * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROC) (GLenum type);
typedef void (__stdcall * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void (__stdcall * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (__stdcall * PFNGLISSHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const* string, const GLint* length);
typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);

































































































#line 2007 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






























typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);










#line 2054 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















































































































typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void (__stdcall * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void (__stdcall * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void (__stdcall * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (__stdcall * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* (__stdcall * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (__stdcall * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);



























































#line 2281 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









































typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);








#line 2335 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void (__stdcall * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);







#line 2375 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);





#line 2391 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);









#line 2425 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2434 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 2452 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 2464 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 2477 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETNTEXIMAGEPROC) (GLenum tex, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels);
typedef void (__stdcall * PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);








#line 2498 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLSPECIALIZESHADERPROC) (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);







#line 2538 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 2552 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);





#line 2565 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 2577 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 2589 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 2601 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 2614 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2623 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);








#line 2659 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 2671 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);








#line 2690 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values);








#line 2714 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2723 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















#line 2746 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2755 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2764 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);





#line 2787 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 2802 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void (__stdcall * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean (__stdcall * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);







#line 2825 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);





#line 2845 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void (__stdcall * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);















#line 2886 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 2897 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 2908 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 2921 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);





#line 2936 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 2947 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2956 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2965 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2974 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2983 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 2992 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3001 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);






#line 3026 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);





#line 3044 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3053 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3062 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3071 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3082 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3091 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);






#line 3114 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3123 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3132 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3141 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 3159 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 3176 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);







#line 3195 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3206 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3217 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 3231 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 3245 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 3259 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 3271 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void (__stdcall * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);















#line 3311 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);





#line 3326 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3337 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3348 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















#line 3367 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3376 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYTEXTURELEVELSAPPLEPROC) (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);





#line 3389 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);









#line 3414 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void (__stdcall * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean (__stdcall * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);












#line 3444 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























#line 3468 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);






#line 3486 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC) (void);






#line 3509 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (__stdcall * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);







#line 3533 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3544 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 3558 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 3570 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3581 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCAPPLEPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCAPPLEPROC) (GLenum condition, GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VAPPLEPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVAPPLEPROC) (GLsync GLsync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCAPPLEPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);











#line 3623 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3632 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 3644 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3655 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 3669 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void (__stdcall * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);






#line 3691 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3702 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);








#line 3723 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void (__stdcall * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);







#line 3749 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean (__stdcall * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);











#line 3785 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 3796 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef int GLfixed;

typedef void (__stdcall * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void (__stdcall * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void (__stdcall * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (__stdcall * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);









#line 3836 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);





#line 3849 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);





#line 3866 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























#line 3890 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 3899 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);







#line 3916 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);




















#line 3961 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);






#line 3981 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);





#line 4004 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync (__stdcall * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);





#line 4023 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);








#line 4042 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);






#line 4059 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);





#line 4079 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);





#line 4098 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4107 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 4125 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

























typedef void (__stdcall * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (__stdcall * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);






#line 4159 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);





#line 4177 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 4191 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4200 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 4216 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 4229 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 4241 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);








#line 4285 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 4298 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 4309 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 4324 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4333 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void (__stdcall * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void (__stdcall * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void (__stdcall * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);





































































































#line 4541 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);





#line 4572 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);








#line 4591 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei* count, GLenum type, void**indices, GLsizei primcount, GLint *basevertex);








#line 4610 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void (__stdcall * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);






#line 4628 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4637 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 4650 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4659 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 4670 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4679 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4688 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























#line 4713 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4722 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 4735 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 4744 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);








#line 4773 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















































































typedef void (__stdcall * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
























#line 4899 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 4910 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);








#line 4949 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void (__stdcall * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);







#line 4971 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);






#line 4986 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);





#line 5002 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 5018 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void (__stdcall * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void (__stdcall * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);






















#line 5078 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
typedef void (__stdcall * PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
typedef void (__stdcall * PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
typedef void (__stdcall * PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void (__stdcall * PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void (__stdcall * PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);








































#line 5170 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 5181 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 5192 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















































































typedef void (__stdcall * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);




































#line 5345 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);






#line 5363 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);







#line 5382 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);





#line 5397 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










































































































typedef void (__stdcall * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);





#line 5510 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void (__stdcall * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);










#line 5533 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 5544 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * (__stdcall * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 5566 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void (__stdcall * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);









#line 5598 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void (__stdcall * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void (__stdcall * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void (__stdcall * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);










#line 5621 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 5636 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);





#line 5659 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










































typedef void (__stdcall * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);






































#line 5774 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYARBPROC) (GLuint id);












#line 5807 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 5818 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);





#line 5834 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















#line 5855 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 5869 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);






#line 5889 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 5901 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLPOLYGONOFFSETCLAMPPROC) (GLfloat factor, GLfloat units, GLfloat clamp);





#line 5916 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 5925 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint (__stdcall * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);










#line 5996 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);





#line 6014 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 6028 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6037 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void (__stdcall * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void (__stdcall * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void (__stdcall * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void (__stdcall * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void (__stdcall * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void (__stdcall * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void (__stdcall * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void (__stdcall * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void (__stdcall * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
























#line 6096 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6105 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6114 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);






#line 6138 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);





#line 6154 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (__stdcall * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void (__stdcall * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);


















#line 6195 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 6206 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 6217 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void (__stdcall * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void (__stdcall * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void (__stdcall * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
































































#line 6358 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6367 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);





#line 6410 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6419 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6428 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6437 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6446 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6455 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"







































































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (__stdcall * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);






#line 6535 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6544 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









































typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void (__stdcall * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void (__stdcall * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB (__stdcall * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB (__stdcall * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void (__stdcall * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void (__stdcall * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void (__stdcall * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB (__stdcall * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void (__stdcall * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void (__stdcall * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void (__stdcall * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);











































#line 6671 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6680 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6689 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);





#line 6719 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void (__stdcall * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint (__stdcall * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);












#line 6756 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6765 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6774 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6783 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 6794 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6803 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void (__stdcall * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean (__stdcall * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);










#line 6830 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6839 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 6852 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 6863 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);





#line 6879 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);





#line 6904 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6913 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 6922 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 6934 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 6945 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);











#line 6986 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"







































typedef void (__stdcall * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void (__stdcall * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);






#line 7034 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREBARRIERPROC) (void);





#line 7047 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 7058 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 7077 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7086 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);






#line 7105 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);











#line 7142 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 7156 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 7170 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















#line 7192 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















#line 7209 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7218 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"































#line 7250 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7259 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 7271 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 7283 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 7295 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























#line 7325 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 7338 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 7349 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 7360 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 7401 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7410 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7419 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 7428 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 7444 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

































#line 7478 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 7489 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 7501 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);







#line 7520 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 7539 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 7554 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 7573 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);







#line 7593 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);











#line 7623 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void (__stdcall * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);








#line 7645 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);






#line 7660 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 7672 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);








#line 7696 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint (__stdcall * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void (__stdcall * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);














#line 7761 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 7772 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYPROC) (GLuint array);








#line 7793 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);














#line 7824 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
















#line 7868 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















































typedef void (__stdcall * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void (__stdcall * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void (__stdcall * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void (__stdcall * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void (__stdcall * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void (__stdcall * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void (__stdcall * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void (__stdcall * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void (__stdcall * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);














#line 7942 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






































typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void (__stdcall * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void (__stdcall * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean (__stdcall * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * (__stdcall * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERARBPROC) (GLenum target);















#line 8010 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















































































typedef void (__stdcall * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void (__stdcall * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);


































































#line 8225 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);







#line 8250 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8261 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);










































#line 8351 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void (__stdcall * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void (__stdcall * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void (__stdcall * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);














#line 8396 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);




















#line 8439 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8450 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8461 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8472 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 8484 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 8493 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 8509 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 8522 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 8535 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8546 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);





#line 8577 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);







#line 8598 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);








#line 8626 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























































typedef void (__stdcall * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void (__stdcall * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint (__stdcall * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void (__stdcall * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void (__stdcall * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void (__stdcall * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);


















#line 8720 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void * (__stdcall * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);






#line 8735 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 8748 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);






#line 8773 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);






#line 8793 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 8802 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8813 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 8824 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 8837 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















#line 8859 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 8871 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint (__stdcall * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void (__stdcall * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void (__stdcall * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
















#line 8915 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);







#line 8932 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void (__stdcall * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void (__stdcall * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);

















































#line 9044 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9053 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 9065 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 9079 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 9091 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9100 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 9111 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 9122 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);







#line 9139 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 9151 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef GLint (__stdcall * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr (__stdcall * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void (__stdcall * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);







#line 9175 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);





#line 9194 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);





#line 9210 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXEXTPROC) (GLuint program, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC) (GLuint program, GLenum programInterface, const GLchar* name);







#line 9235 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);





#line 9253 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9262 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);





#line 9280 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 9292 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLBUFFERSTORAGEEXTPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);






#line 9317 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARTEXIMAGEEXTPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);






#line 9332 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















#line 9353 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 9364 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 9378 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9387 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 9403 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);






#line 9418 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void (__stdcall * PFNGLUNLOCKARRAYSEXTPROC) (void);






#line 9436 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9445 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 9454 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);

















#line 9512 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);






#line 9542 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAEXTPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 9555 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);









#line 9576 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);






#line 9595 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);






#line 9617 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void (__stdcall * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void (__stdcall * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);







#line 9634 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);





#line 9650 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void (__stdcall * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (__stdcall * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);


























































































































































































































#line 10093 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDISCARDFRAMEBUFFEREXTPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);





#line 10110 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









































typedef void (__stdcall * PFNGLDRAWBUFFERSEXTPROC) (GLsizei n, const GLenum* bufs);





#line 10158 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void (__stdcall * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);










#line 10181 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIEXTPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIEXTPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIEXTPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIEXTPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLCOLORMASKIEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEIEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEIEXTPROC) (GLenum target, GLuint index);
typedef GLboolean (__stdcall * PFNGLISENABLEDIEXTPROC) (GLenum target, GLuint index);












#line 10208 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);








#line 10227 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);






#line 10242 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);





#line 10258 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void* GLeglClientBufferEXT;

typedef void (__stdcall * PFNGLBUFFERSTORAGEEXTERNALEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);






#line 10275 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 10284 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);









#line 10314 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 10323 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);






















#line 10385 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 10403 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 10420 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 10432 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);





















#line 10529 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 10541 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










































#line 10584 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










































#line 10627 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);







#line 10665 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);






#line 10680 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

































typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);






































#line 10786 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 10795 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXEXTPROC) (GLenum target);














#line 10840 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 10849 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);





#line 10862 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);





#line 10875 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 10884 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);





#line 10899 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void (__stdcall * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void (__stdcall * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);







#line 10926 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * (__stdcall * PFNGLMAPBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 10948 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

























typedef void (__stdcall * PFNGLBUFFERSTORAGEMEMEXTPROC) (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLCREATEMEMORYOBJECTSEXTPROC) (GLsizei n, GLuint* memoryObjects);
typedef void (__stdcall * PFNGLDELETEMEMORYOBJECTSEXTPROC) (GLsizei n, const GLuint* memoryObjects);
typedef void (__stdcall * PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETUNSIGNEDBYTEI_VEXTPROC) (GLenum target, GLuint index, GLubyte* data);
typedef void (__stdcall * PFNGLGETUNSIGNEDBYTEVEXTPROC) (GLenum pname, GLubyte* data);
typedef GLboolean (__stdcall * PFNGLISMEMORYOBJECTEXTPROC) (GLuint memoryObject);
typedef void (__stdcall * PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM1DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM2DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM3DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void (__stdcall * PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);























#line 11016 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLIMPORTMEMORYFDEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, GLint fd);





#line 11031 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, void *handle);
typedef void (__stdcall * PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, const void *name);






#line 11058 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11067 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);






#line 11082 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC) (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);






#line 11097 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11106 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);






#line 11139 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 11151 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);





#line 11169 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11178 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLDRAWBUFFERSINDEXEDEXTPROC) (GLint n, const GLenum* location, const GLint *indices);
typedef void (__stdcall * PFNGLGETINTEGERI_VEXTPROC) (GLenum target, GLuint index, GLint* data);
typedef void (__stdcall * PFNGLREADBUFFERINDEXEDEXTPROC) (GLenum src, GLint index);







#line 11201 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 11215 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 11228 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 11243 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);








#line 11284 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 11298 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);










#line 11331 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11340 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);






#line 11360 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);





#line 11377 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);





#line 11392 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11401 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);





#line 11419 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 11433 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
typedef void (__stdcall * PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufsize, GLfloat* v);
typedef void (__stdcall * PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);








#line 11467 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 11480 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 11498 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 11509 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 11523 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 11534 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINSCENEEXTPROC) (void);
typedef void (__stdcall * PFNGLENDSCENEEXTPROC) (void);






#line 11549 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);





















#line 11602 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDELETESEMAPHORESEXTPROC) (GLsizei n, const GLuint* semaphores);
typedef void (__stdcall * PFNGLGENSEMAPHORESEXTPROC) (GLsizei n, GLuint* semaphores);
typedef void (__stdcall * PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, GLuint64* params);
typedef GLboolean (__stdcall * PFNGLISSEMAPHOREEXTPROC) (GLuint semaphore);
typedef void (__stdcall * PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, const GLuint64* params);
typedef void (__stdcall * PFNGLSIGNALSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts);
typedef void (__stdcall * PFNGLWAITSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts);











#line 11627 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLIMPORTSEMAPHOREFDEXTPROC) (GLuint semaphore, GLenum handleType, GLint fd);





#line 11640 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) (GLuint semaphore, GLenum handleType, void *handle);
typedef void (__stdcall * PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) (GLuint semaphore, GLenum handleType, const void *name);






#line 11655 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void (__stdcall * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);







#line 11674 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 11687 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 11698 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11707 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11716 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






























































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (__stdcall * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);






#line 11787 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11796 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11805 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11814 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11823 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 11836 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC) (GLsizei offset, GLsizei n, const GLuint* values);
typedef void (__stdcall * PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target, GLsizei size);
typedef GLsizei (__stdcall * PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target);







#line 11857 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11866 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11875 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 11889 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 11900 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);






#line 11932 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 11941 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 11953 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);





#line 11969 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 11981 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);







#line 11998 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















































#line 12050 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);





#line 12073 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);





#line 12095 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 12114 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12125 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12136 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12150 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 12159 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12173 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12187 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12201 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















#line 12223 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















#line 12242 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12253 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 12262 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 12271 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






























#line 12302 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 12314 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 12326 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 12338 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12349 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void (__stdcall * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);










#line 12420 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 12433 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 12446 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 12464 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef GLboolean (__stdcall * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void (__stdcall * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean (__stdcall * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void (__stdcall * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);










#line 12493 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);





#line 12509 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12523 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 12537 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

























#line 12563 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12574 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12585 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 12598 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 12611 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


































#line 12646 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"































typedef void (__stdcall * PFNGLTEXSTORAGE1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);










#line 12694 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 12709 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12720 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXTUREVIEWEXTPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 12739 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);






#line 12756 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






















typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);











#line 12797 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 12810 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);












#line 12871 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 12882 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBINDARRAYSETEXTPROC) (const void *arrayset);
typedef const void * (__stdcall * PFNGLCREATEARRAYSETEXTPROC) (void);
typedef void (__stdcall * PFNGLDELETEARRAYSETSEXTPROC) (GLsizei n, const void *arrayset[]);







#line 12899 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);















#line 12945 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















































































































typedef void (__stdcall * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint (__stdcall * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void (__stdcall * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void (__stdcall * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint (__stdcall * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint (__stdcall * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void (__stdcall * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void (__stdcall * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean (__stdcall * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void (__stdcall * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void (__stdcall * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (__stdcall * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (__stdcall * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (__stdcall * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void (__stdcall * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void (__stdcall * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void (__stdcall * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void (__stdcall * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void (__stdcall * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void (__stdcall * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void (__stdcall * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void (__stdcall * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void (__stdcall * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);














































#line 13151 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);







#line 13182 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef GLboolean (__stdcall * PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key, GLuint timeout);
typedef GLboolean (__stdcall * PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key);






#line 13197 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint box[]);





#line 13217 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef GLsync (__stdcall * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);





#line 13232 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMETERMINATORGREMEDYPROC) (void);





#line 13245 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);





#line 13258 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13267 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);










#line 13290 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13299 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13308 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13319 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void (__stdcall * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);






#line 13334 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13345 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 13357 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13368 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);












#line 13412 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 13430 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13441 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13452 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13461 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13470 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void * (__stdcall * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void (__stdcall * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void (__stdcall * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);







#line 13492 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);








#line 13517 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void (__stdcall * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void (__stdcall * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void (__stdcall * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void (__stdcall * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void (__stdcall * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);














#line 13569 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void (__stdcall * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);






#line 13584 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLBLENDBARRIERKHRPROC) (void);





#line 13614 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13623 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13632 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















































typedef void (__stdcall *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void (__stdcall * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void (__stdcall * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);














#line 13706 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13717 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) (GLuint count);





#line 13733 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13742 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);








#line 13770 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





































#line 13808 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





































#line 13846 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13855 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef GLuint (__stdcall * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void (__stdcall * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint (__stdcall * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);









#line 13881 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 13897 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 13908 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLRESIZEBUFFERSMESAPROC) (void);





#line 13921 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 13930 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void (__stdcall * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);




























#line 13989 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 14002 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14011 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVXPROC) (void);






#line 14026 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 14041 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLLGPUCOPYIMAGESUBDATANVXPROC) (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLLGPUINTERLOCKNVXPROC) (void);
typedef void (__stdcall * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);







#line 14061 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLSTEREOPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSTEREOPARAMETERINVPROC) (GLenum pname, GLint param);






#line 14084 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 14098 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 14112 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 14123 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);






#line 14138 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);






#line 14153 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);

















#line 14190 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

























































typedef void (__stdcall * PFNGLBLENDBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);






#line 14256 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14265 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 14277 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14286 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);





#line 14303 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























typedef void (__stdcall * PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
typedef void (__stdcall * PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
typedef void (__stdcall * PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
typedef void (__stdcall * PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
typedef void (__stdcall * PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
typedef void (__stdcall * PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
typedef void (__stdcall * PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
typedef void (__stdcall * PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void (__stdcall * PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef GLuint (__stdcall * PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
typedef GLushort (__stdcall * PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
typedef GLboolean (__stdcall * PFNGLISCOMMANDLISTNVPROC) (GLuint list);
typedef GLboolean (__stdcall * PFNGLISSTATENVPROC) (GLuint state);
typedef void (__stdcall * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void (__stdcall * PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);





















#line 14368 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 14380 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVPROC) (void);






#line 14400 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);





#line 14418 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);





#line 14435 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);





#line 14452 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATANVPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 14468 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 14480 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);





#line 14493 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 14505 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void (__stdcall * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void (__stdcall * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);







#line 14527 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 14538 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 14553 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLDRAWBUFFERSNVPROC) (GLsizei n, const GLenum* bufs);





#line 14600 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDNVPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDNVPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);






#line 14615 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);





#line 14628 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall *GLVULKANPROCNV)(void);

typedef void (__stdcall * PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef GLVULKANPROCNV (__stdcall * PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
typedef void (__stdcall * PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
typedef void (__stdcall * PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
typedef void (__stdcall * PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);









#line 14651 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"































typedef void (__stdcall * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void (__stdcall * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void (__stdcall * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);













#line 14705 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14714 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);







#line 14742 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























#line 14769 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void (__stdcall * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean (__stdcall * PFNGLTESTFENCENVPROC) (GLuint fence);











#line 14798 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 14809 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























#line 14834 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 14847 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);





#line 14863 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);










#line 14893 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 14908 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14917 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14926 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 14935 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFERNVPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 14953 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























#line 14977 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 14994 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);





#line 15012 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15021 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);





#line 15038 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15047 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15056 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLMULTICASTBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (__stdcall * PFNGLMULTICASTBUFFERSUBDATANVPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void (__stdcall * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLMULTICASTWAITSYNCNVPROC) (GLuint signalGpu, GLbitfield waitGpuMask);
typedef void (__stdcall * PFNGLRENDERGPUMASKNVPROC) (GLbitfield mask);
















#line 15097 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
















#line 15141 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 15157 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15166 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15175 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



































typedef void (__stdcall * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);






































#line 15283 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef unsigned short GLhalf;

typedef void (__stdcall * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void (__stdcall * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void (__stdcall * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void (__stdcall * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void (__stdcall * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);


















































#line 15390 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15399 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORNVPROC) (GLuint index, GLuint divisor);





#line 15414 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params);





#line 15432 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 15444 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 15455 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 15466 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);










#line 15496 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void (__stdcall * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);











#line 15526 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 15539 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 15551 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 15563 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 15575 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);







#line 15598 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 15607 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




























































































































































typedef void (__stdcall * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void (__stdcall * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint (__stdcall * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void (__stdcall * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
typedef void (__stdcall * PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
typedef void (__stdcall * PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
typedef GLfloat (__stdcall * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (__stdcall * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void (__stdcall * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void (__stdcall * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void (__stdcall * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLfloat *params);
typedef void (__stdcall * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean (__stdcall * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean (__stdcall * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void (__stdcall * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void (__stdcall * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void (__stdcall * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef GLenum (__stdcall * PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall * PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
typedef void (__stdcall * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum (__stdcall * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void (__stdcall * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void (__stdcall * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void (__stdcall * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void (__stdcall * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void (__stdcall * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
typedef void (__stdcall * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void (__stdcall * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean (__stdcall * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void (__stdcall * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void (__stdcall * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void (__stdcall * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);




































































#line 15896 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 15907 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 15921 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void (__stdcall * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);






#line 15943 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 15954 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);






#line 15973 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLPOLYGONMODENVPROC) (GLenum face, GLenum mode);





#line 15993 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (__stdcall * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);










#line 16023 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTNVPROC) (void);






#line 16041 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16050 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16059 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16068 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);

















#line 16157 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);






#line 16174 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 16186 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















#line 16206 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);






#line 16230 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16239 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16248 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16257 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16266 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16275 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16284 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean (__stdcall * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void (__stdcall * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);

















#line 16325 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16334 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16343 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 16356 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16365 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 16376 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 16387 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16396 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 16411 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 16424 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 16436 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERNVPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);










#line 16467 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREBARRIERNVPROC) (void);





#line 16480 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 16492 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 16506 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 16520 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16529 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16538 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 16553 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 16564 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);










#line 16590 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16599 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 16613 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 16622 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















































































#line 16705 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





































#line 16743 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























#line 16770 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint (__stdcall * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);















#line 16829 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);











#line 16859 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 16872 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef GLintptr GLvdpauSurfaceNV;

typedef void (__stdcall * PFNGLVDPAUFININVPROC) (void);
typedef void (__stdcall * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void (__stdcall * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void (__stdcall * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void (__stdcall * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void (__stdcall * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void (__stdcall * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void (__stdcall * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);














#line 16910 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);






#line 16931 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 16942 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);























#line 16994 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (__stdcall * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void (__stdcall * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void (__stdcall * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
















#line 17055 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


























































































typedef GLboolean (__stdcall * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void (__stdcall * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void (__stdcall * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void (__stdcall * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void (__stdcall * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);




































































#line 17278 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 17287 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 17296 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 17308 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 17319 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 17330 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
















#line 17395 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLDEPTHRANGEARRAYFVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDFNVPROC) (GLuint index, GLfloat n, GLfloat f);
typedef void (__stdcall * PFNGLDISABLEINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETFLOATI_VNVPROC) (GLenum target, GLuint index, GLfloat* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINVPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLSCISSORARRAYVNVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDNVPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVNVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVNVPROC) (GLuint index, const GLfloat * v);
















#line 17439 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 17448 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);





#line 17474 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 17483 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 17495 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 17511 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 17523 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);





#line 17541 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 17550 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews);





#line 17563 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























#line 17593 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"































#line 17625 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLALPHAFUNCQCOMPROC) (GLenum func, GLclampf ref);





#line 17642 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 17657 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDISABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void (__stdcall * PFNGLENABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void (__stdcall * PFNGLGETDRIVERCONTROLSTRINGQCOMPROC) (GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar *driverControlString);
typedef void (__stdcall * PFNGLGETDRIVERCONTROLSQCOMPROC) (GLint* num, GLsizei size, GLuint *driverControls);








#line 17676 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLEXTGETBUFFERPOINTERVQCOMPROC) (GLenum target, void** params);
typedef void (__stdcall * PFNGLEXTGETBUFFERSQCOMPROC) (GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
typedef void (__stdcall * PFNGLEXTGETFRAMEBUFFERSQCOMPROC) (GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
typedef void (__stdcall * PFNGLEXTGETRENDERBUFFERSQCOMPROC) (GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
typedef void (__stdcall * PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC) (GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLEXTGETTEXSUBIMAGEQCOMPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels);
typedef void (__stdcall * PFNGLEXTGETTEXTURESQCOMPROC) (GLuint* textures, GLint maxTextures, GLint* numTextures);
typedef void (__stdcall * PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC) (GLenum target, GLenum pname, GLint param);












#line 17715 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC) (GLuint program, GLenum shadertype, GLchar* source, GLint* length);
typedef void (__stdcall * PFNGLEXTGETPROGRAMSQCOMPROC) (GLuint* programs, GLint maxPrograms, GLint* numPrograms);
typedef void (__stdcall * PFNGLEXTGETSHADERSQCOMPROC) (GLuint* shaders, GLint maxShaders, GLint* numShaders);
typedef GLboolean (__stdcall * PFNGLEXTISPROGRAMBINARYQCOMPROC) (GLuint program);








#line 17734 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC) (GLuint fbo, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint* providedFeatures);
typedef void (__stdcall * PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC) (GLuint fbo, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);






#line 17752 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 17763 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC) (void);





#line 17778 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"







































typedef void (__stdcall * PFNGLENDTILINGQCOMPROC) (GLbitfield preserveMask);
typedef void (__stdcall * PFNGLSTARTTILINGQCOMPROC) (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);






#line 17826 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 17837 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef int GLclampx;

typedef void (__stdcall * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void (__stdcall * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void (__stdcall * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void (__stdcall * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void (__stdcall * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void (__stdcall * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void (__stdcall * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void (__stdcall * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void (__stdcall * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void (__stdcall * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);



































#line 17912 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void (__stdcall * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void (__stdcall * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void (__stdcall * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);

















#line 17949 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



















#line 17969 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef const GLchar* (__stdcall * PFNGLERRORSTRINGREGALPROC) (GLenum error);





#line 17982 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef GLboolean (__stdcall * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean (__stdcall * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);






#line 17997 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















typedef void (__stdcall *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void (__stdcall * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);





#line 18022 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void * (__stdcall * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);





#line 18035 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18047 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 18063 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18072 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















#line 18091 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);






#line 18106 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);






#line 18121 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18133 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18142 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);






#line 18174 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC) (GLint factor);
typedef void (__stdcall * PFNGLSELECTTEXTURECOORDSETSGISPROC) (GLenum target);
typedef void (__stdcall * PFNGLSELECTTEXTURESGISPROC) (GLenum target);
typedef void (__stdcall * PFNGLSELECTTEXTURETRANSFORMSGISPROC) (GLenum target);








#line 18205 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18214 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

















#line 18232 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTISAMPLESUBRECTPOSSGISPROC) (GLint x, GLint y);





#line 18245 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void (__stdcall * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);






#line 18260 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);






#line 18275 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18286 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18297 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void (__stdcall * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);






#line 18312 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 18326 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18335 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void (__stdcall * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint (__stdcall * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint (__stdcall * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean (__stdcall * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint (__stdcall * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);










#line 18360 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18372 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















#line 18388 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 18402 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 18415 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18424 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18436 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18447 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18458 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18467 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18476 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18487 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18496 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18505 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18516 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"


















#line 18535 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18544 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLADDRESSSPACEPROC) (GLenum space, GLbitfield mask);
typedef GLint (__stdcall * PFNGLDATAPIPEPROC) (GLenum space);






#line 18562 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18571 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 18584 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 18597 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18606 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFLUSHRASTERSGIXPROC) (void);





#line 18619 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18631 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18640 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFOGLAYERSSGIXPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGLAYERSSGIXPROC) (GLfloat* points);






#line 18662 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18674 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18683 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 18695 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);





#line 18708 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 18722 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);





















#line 18767 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 18780 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);





#line 18793 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





















#line 18815 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, void *param);





#line 18837 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18846 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18855 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18864 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18875 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18884 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 18895 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18904 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLALLOCMPEGPREDICTORSSGIXPROC) (GLsizei width, GLsizei height, GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLDELETEMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLGENMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void (__stdcall * PFNGLGETMPEGPARAMETERFVSGIXPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMPEGPARAMETERIVSGIXPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef GLboolean (__stdcall * PFNGLISMPEGPREDICTORSGIXPROC) (GLuint predictor);
typedef void (__stdcall * PFNGLMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef void (__stdcall * PFNGLSWAPMPEGPREDICTORSSGIXPROC) (GLenum target0, GLenum target1);















#line 18937 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 18946 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint* terms, GLfloat *data);
typedef void (__stdcall * PFNGLGETNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint* terms, const GLfloat *data);
typedef void (__stdcall * PFNGLNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint terms, GLfloat* params);
typedef void (__stdcall * PFNGLNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint terms, const GLfloat* params);








#line 18965 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





























#line 18995 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19006 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19015 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);





#line 19028 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19037 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19046 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19055 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);






#line 19073 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMESHBREADTHSGIXPROC) (GLint breadth);
typedef void (__stdcall * PFNGLMESHSTRIDESGIXPROC) (GLint stride);






#line 19088 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);





#line 19101 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 19116 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19127 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 19141 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19152 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 19166 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19177 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);








#line 19196 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19205 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"














#line 19220 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);





#line 19233 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19242 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












#line 19255 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19264 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19276 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19287 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19298 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





































#line 19336 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"













#line 19350 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19359 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVECTOROPERATIONSGIXPROC) (GLenum operation);
typedef void (__stdcall * PFNGLVECTOROPERATIONSGIXPROC) (GLenum operation);






#line 19374 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef GLboolean (__stdcall * PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC) (GLsizei n, const GLuint* arrays, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDVERTEXARRAYSGIXPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSSGIXPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYSGIXPROC) (GLuint array);
typedef void (__stdcall * PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays, const GLclampf* priorities);










#line 19397 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19409 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19421 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19430 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19439 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19451 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




















#line 19472 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);











#line 19514 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19523 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
















#line 19540 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFSGIPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERISGIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMSGIPROC) (GLenum target);











#line 19571 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19583 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLFINISHTEXTURESUNXPROC) (void);





#line 19599 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19610 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);












#line 19640 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19652 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);





#line 19665 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19676 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);











#line 19719 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);












































#line 19810 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"











#line 19822 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"








#line 19831 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"










#line 19842 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);





#line 19855 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"





extern PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern PFNGLBLENDCOLORPROC __glewBlendColor;
extern PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern PFNGLFOGCOORDDPROC __glewFogCoordd;
extern PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern PFNGLFOGCOORDFPROC __glewFogCoordf;
extern PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern PFNGLBEGINQUERYPROC __glewBeginQuery;
extern PFNGLBINDBUFFERPROC __glewBindBuffer;
extern PFNGLBUFFERDATAPROC __glewBufferData;
extern PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern PFNGLENDQUERYPROC __glewEndQuery;
extern PFNGLGENBUFFERSPROC __glewGenBuffers;
extern PFNGLGENQUERIESPROC __glewGenQueries;
extern PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern PFNGLISBUFFERPROC __glewIsBuffer;
extern PFNGLISQUERYPROC __glewIsQuery;
extern PFNGLMAPBUFFERPROC __glewMapBuffer;
extern PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern PFNGLATTACHSHADERPROC __glewAttachShader;
extern PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern PFNGLCOMPILESHADERPROC __glewCompileShader;
extern PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern PFNGLCREATESHADERPROC __glewCreateShader;
extern PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern PFNGLDELETESHADERPROC __glewDeleteShader;
extern PFNGLDETACHSHADERPROC __glewDetachShader;
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern PFNGLISPROGRAMPROC __glewIsProgram;
extern PFNGLISSHADERPROC __glewIsShader;
extern PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern PFNGLSHADERSOURCEPROC __glewShaderSource;
extern PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern PFNGLUNIFORM1FPROC __glewUniform1f;
extern PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern PFNGLUNIFORM1IPROC __glewUniform1i;
extern PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern PFNGLUNIFORM2FPROC __glewUniform2f;
extern PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern PFNGLUNIFORM2IPROC __glewUniform2i;
extern PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern PFNGLUNIFORM3FPROC __glewUniform3f;
extern PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern PFNGLUNIFORM3IPROC __glewUniform3i;
extern PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern PFNGLUNIFORM4FPROC __glewUniform4f;
extern PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern PFNGLUNIFORM4IPROC __glewUniform4i;
extern PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern PFNGLUSEPROGRAMPROC __glewUseProgram;
extern PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern PFNGLCLAMPCOLORPROC __glewClampColor;
extern PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern PFNGLCOLORMASKIPROC __glewColorMaski;
extern PFNGLDISABLEIPROC __glewDisablei;
extern PFNGLENABLEIPROC __glewEnablei;
extern PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern PFNGLGETSTRINGIPROC __glewGetStringi;
extern PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern PFNGLISENABLEDIPROC __glewIsEnabledi;
extern PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern PFNGLTEXBUFFERPROC __glewTexBuffer;

extern PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern PFNGLGETGRAPHICSRESETSTATUSPROC __glewGetGraphicsResetStatus;
extern PFNGLGETNCOMPRESSEDTEXIMAGEPROC __glewGetnCompressedTexImage;
extern PFNGLGETNTEXIMAGEPROC __glewGetnTexImage;
extern PFNGLGETNUNIFORMDVPROC __glewGetnUniformdv;

extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC __glewMultiDrawArraysIndirectCount;
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC __glewMultiDrawElementsIndirectCount;
extern PFNGLSPECIALIZESHADERPROC __glewSpecializeShader;

extern PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewFramebufferSamplePositionsfvAMD;
extern PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC __glewGetFramebufferParameterfvAMD;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC __glewGetNamedFramebufferParameterfvAMD;
extern PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewNamedFramebufferSamplePositionsfvAMD;

extern PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern PFNGLCOPYTEXTURELEVELSAPPLEPROC __glewCopyTextureLevelsAPPLE;

extern PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC __glewRenderbufferStorageMultisampleAPPLE;
extern PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC __glewResolveMultisampleFramebufferAPPLE;

extern PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern PFNGLCLIENTWAITSYNCAPPLEPROC __glewClientWaitSyncAPPLE;
extern PFNGLDELETESYNCAPPLEPROC __glewDeleteSyncAPPLE;
extern PFNGLFENCESYNCAPPLEPROC __glewFenceSyncAPPLE;
extern PFNGLGETINTEGER64VAPPLEPROC __glewGetInteger64vAPPLE;
extern PFNGLGETSYNCIVAPPLEPROC __glewGetSyncivAPPLE;
extern PFNGLISSYNCAPPLEPROC __glewIsSyncAPPLE;
extern PFNGLWAITSYNCAPPLEPROC __glewWaitSyncAPPLE;

extern PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern PFNGLSHADERBINARYPROC __glewShaderBinary;

extern PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern PFNGLPRIMITIVEBOUNDINGBOXARBPROC __glewPrimitiveBoundingBoxARB;

extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern PFNGLBUFFERSTORAGEPROC __glewBufferStorage;

extern PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern PFNGLCLIPCONTROLPROC __glewClipControl;

extern PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern PFNGLGETQUERYBUFFEROBJECTI64VPROC __glewGetQueryBufferObjecti64v;
extern PFNGLGETQUERYBUFFEROBJECTIVPROC __glewGetQueryBufferObjectiv;
extern PFNGLGETQUERYBUFFEROBJECTUI64VPROC __glewGetQueryBufferObjectui64v;
extern PFNGLGETQUERYBUFFEROBJECTUIVPROC __glewGetQueryBufferObjectuiv;
extern PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern PFNGLSPECIALIZESHADERARBPROC __glewSpecializeShaderARB;

extern PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern PFNGLUNIFORM1DPROC __glewUniform1d;
extern PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern PFNGLUNIFORM2DPROC __glewUniform2d;
extern PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern PFNGLUNIFORM3DPROC __glewUniform3d;
extern PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern PFNGLUNIFORM4DPROC __glewUniform4d;
extern PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern PFNGLGETUNIFORMI64VARBPROC __glewGetUniformi64vARB;
extern PFNGLGETUNIFORMUI64VARBPROC __glewGetUniformui64vARB;
extern PFNGLGETNUNIFORMI64VARBPROC __glewGetnUniformi64vARB;
extern PFNGLGETNUNIFORMUI64VARBPROC __glewGetnUniformui64vARB;
extern PFNGLPROGRAMUNIFORM1I64ARBPROC __glewProgramUniform1i64ARB;
extern PFNGLPROGRAMUNIFORM1I64VARBPROC __glewProgramUniform1i64vARB;
extern PFNGLPROGRAMUNIFORM1UI64ARBPROC __glewProgramUniform1ui64ARB;
extern PFNGLPROGRAMUNIFORM1UI64VARBPROC __glewProgramUniform1ui64vARB;
extern PFNGLPROGRAMUNIFORM2I64ARBPROC __glewProgramUniform2i64ARB;
extern PFNGLPROGRAMUNIFORM2I64VARBPROC __glewProgramUniform2i64vARB;
extern PFNGLPROGRAMUNIFORM2UI64ARBPROC __glewProgramUniform2ui64ARB;
extern PFNGLPROGRAMUNIFORM2UI64VARBPROC __glewProgramUniform2ui64vARB;
extern PFNGLPROGRAMUNIFORM3I64ARBPROC __glewProgramUniform3i64ARB;
extern PFNGLPROGRAMUNIFORM3I64VARBPROC __glewProgramUniform3i64vARB;
extern PFNGLPROGRAMUNIFORM3UI64ARBPROC __glewProgramUniform3ui64ARB;
extern PFNGLPROGRAMUNIFORM3UI64VARBPROC __glewProgramUniform3ui64vARB;
extern PFNGLPROGRAMUNIFORM4I64ARBPROC __glewProgramUniform4i64ARB;
extern PFNGLPROGRAMUNIFORM4I64VARBPROC __glewProgramUniform4i64vARB;
extern PFNGLPROGRAMUNIFORM4UI64ARBPROC __glewProgramUniform4ui64ARB;
extern PFNGLPROGRAMUNIFORM4UI64VARBPROC __glewProgramUniform4ui64vARB;
extern PFNGLUNIFORM1I64ARBPROC __glewUniform1i64ARB;
extern PFNGLUNIFORM1I64VARBPROC __glewUniform1i64vARB;
extern PFNGLUNIFORM1UI64ARBPROC __glewUniform1ui64ARB;
extern PFNGLUNIFORM1UI64VARBPROC __glewUniform1ui64vARB;
extern PFNGLUNIFORM2I64ARBPROC __glewUniform2i64ARB;
extern PFNGLUNIFORM2I64VARBPROC __glewUniform2i64vARB;
extern PFNGLUNIFORM2UI64ARBPROC __glewUniform2ui64ARB;
extern PFNGLUNIFORM2UI64VARBPROC __glewUniform2ui64vARB;
extern PFNGLUNIFORM3I64ARBPROC __glewUniform3i64ARB;
extern PFNGLUNIFORM3I64VARBPROC __glewUniform3i64vARB;
extern PFNGLUNIFORM3UI64ARBPROC __glewUniform3ui64ARB;
extern PFNGLUNIFORM3UI64VARBPROC __glewUniform3ui64vARB;
extern PFNGLUNIFORM4I64ARBPROC __glewUniform4i64ARB;
extern PFNGLUNIFORM4I64VARBPROC __glewUniform4i64vARB;
extern PFNGLUNIFORM4UI64ARBPROC __glewUniform4ui64ARB;
extern PFNGLUNIFORM4UI64VARBPROC __glewUniform4ui64vARB;

extern PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern PFNGLCOLORTABLEPROC __glewColorTable;
extern PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern PFNGLGETMINMAXPROC __glewGetMinmax;
extern PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern PFNGLHISTOGRAMPROC __glewHistogram;
extern PFNGLMINMAXPROC __glewMinmax;
extern PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern PFNGLRESETMINMAXPROC __glewResetMinmax;
extern PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern PFNGLBINDTEXTURESPROC __glewBindTextures;
extern PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern PFNGLISQUERYARBPROC __glewIsQueryARB;

extern PFNGLMAXSHADERCOMPILERTHREADSARBPROC __glewMaxShaderCompilerThreadsARB;

extern PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern PFNGLPOLYGONOFFSETCLAMPPROC __glewPolygonOffsetClamp;

extern PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewFramebufferSampleLocationsfvARB;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewNamedFramebufferSampleLocationsfvARB;

extern PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern PFNGLBINDSAMPLERPROC __glewBindSampler;
extern PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern PFNGLISSAMPLERPROC __glewIsSampler;
extern PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;

extern PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern PFNGLDELETESYNCPROC __glewDeleteSync;
extern PFNGLFENCESYNCPROC __glewFenceSync;
extern PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern PFNGLGETSYNCIVPROC __glewGetSynciv;
extern PFNGLISSYNCPROC __glewIsSync;
extern PFNGLWAITSYNCPROC __glewWaitSync;

extern PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;

extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern PFNGLTEXTUREVIEWPROC __glewTextureView;

extern PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern PFNGLCOLORP3UIPROC __glewColorP3ui;
extern PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern PFNGLCOLORP4UIPROC __glewColorP4ui;
extern PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC __glewDrawArraysInstancedBaseInstanceEXT;
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseInstanceEXT;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseVertexBaseInstanceEXT;

extern PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC __glewBindFragDataLocationIndexedEXT;
extern PFNGLGETFRAGDATAINDEXEXTPROC __glewGetFragDataIndexEXT;
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC __glewGetProgramResourceLocationIndexEXT;

extern PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern PFNGLBUFFERSTORAGEEXTPROC __glewBufferStorageEXT;
extern PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern PFNGLCLEARTEXIMAGEEXTPROC __glewClearTexImageEXT;
extern PFNGLCLEARTEXSUBIMAGEEXTPROC __glewClearTexSubImageEXT;

extern PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern PFNGLCOPYIMAGESUBDATAEXTPROC __glewCopyImageSubDataEXT;

extern PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern PFNGLDISCARDFRAMEBUFFEREXTPROC __glewDiscardFramebufferEXT;

extern PFNGLDRAWBUFFERSEXTPROC __glewDrawBuffersEXT;

extern PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern PFNGLBLENDEQUATIONSEPARATEIEXTPROC __glewBlendEquationSeparateiEXT;
extern PFNGLBLENDEQUATIONIEXTPROC __glewBlendEquationiEXT;
extern PFNGLBLENDFUNCSEPARATEIEXTPROC __glewBlendFuncSeparateiEXT;
extern PFNGLBLENDFUNCIEXTPROC __glewBlendFunciEXT;
extern PFNGLCOLORMASKIEXTPROC __glewColorMaskiEXT;
extern PFNGLDISABLEIEXTPROC __glewDisableiEXT;
extern PFNGLENABLEIEXTPROC __glewEnableiEXT;
extern PFNGLISENABLEDIEXTPROC __glewIsEnablediEXT;

extern PFNGLDRAWELEMENTSBASEVERTEXEXTPROC __glewDrawElementsBaseVertexEXT;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC __glewDrawElementsInstancedBaseVertexEXT;
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC __glewDrawRangeElementsBaseVertexEXT;
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC __glewMultiDrawElementsBaseVertexEXT;

extern PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern PFNGLBUFFERSTORAGEEXTERNALEXTPROC __glewBufferStorageExternalEXT;
extern PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC __glewNamedBufferStorageExternalEXT;

extern PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern PFNGLVERTEXATTRIBDIVISOREXTPROC __glewVertexAttribDivisorEXT;

extern PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC __glewFlushMappedBufferRangeEXT;
extern PFNGLMAPBUFFERRANGEEXTPROC __glewMapBufferRangeEXT;

extern PFNGLBUFFERSTORAGEMEMEXTPROC __glewBufferStorageMemEXT;
extern PFNGLCREATEMEMORYOBJECTSEXTPROC __glewCreateMemoryObjectsEXT;
extern PFNGLDELETEMEMORYOBJECTSEXTPROC __glewDeleteMemoryObjectsEXT;
extern PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC __glewGetMemoryObjectParameterivEXT;
extern PFNGLGETUNSIGNEDBYTEI_VEXTPROC __glewGetUnsignedBytei_vEXT;
extern PFNGLGETUNSIGNEDBYTEVEXTPROC __glewGetUnsignedBytevEXT;
extern PFNGLISMEMORYOBJECTEXTPROC __glewIsMemoryObjectEXT;
extern PFNGLMEMORYOBJECTPARAMETERIVEXTPROC __glewMemoryObjectParameterivEXT;
extern PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC __glewNamedBufferStorageMemEXT;
extern PFNGLTEXSTORAGEMEM1DEXTPROC __glewTexStorageMem1DEXT;
extern PFNGLTEXSTORAGEMEM2DEXTPROC __glewTexStorageMem2DEXT;
extern PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC __glewTexStorageMem2DMultisampleEXT;
extern PFNGLTEXSTORAGEMEM3DEXTPROC __glewTexStorageMem3DEXT;
extern PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC __glewTexStorageMem3DMultisampleEXT;
extern PFNGLTEXTURESTORAGEMEM1DEXTPROC __glewTextureStorageMem1DEXT;
extern PFNGLTEXTURESTORAGEMEM2DEXTPROC __glewTextureStorageMem2DEXT;
extern PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC __glewTextureStorageMem2DMultisampleEXT;
extern PFNGLTEXTURESTORAGEMEM3DEXTPROC __glewTextureStorageMem3DEXT;
extern PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC __glewTextureStorageMem3DMultisampleEXT;

extern PFNGLIMPORTMEMORYFDEXTPROC __glewImportMemoryFdEXT;

extern PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC __glewImportMemoryWin32HandleEXT;
extern PFNGLIMPORTMEMORYWIN32NAMEEXTPROC __glewImportMemoryWin32NameEXT;

extern PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC __glewMultiDrawArraysIndirectEXT;
extern PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC __glewMultiDrawElementsIndirectEXT;

extern PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC __glewFramebufferTexture2DMultisampleEXT;

extern PFNGLDRAWBUFFERSINDEXEDEXTPROC __glewDrawBuffersIndexedEXT;
extern PFNGLGETINTEGERI_VEXTPROC __glewGetIntegeri_vEXT;
extern PFNGLREADBUFFERINDEXEDEXTPROC __glewReadBufferIndexedEXT;

extern PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern PFNGLPOLYGONOFFSETCLAMPEXTPROC __glewPolygonOffsetClampEXT;

extern PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern PFNGLCOVERAGEMODULATIONNVPROC __glewCoverageModulationNV;
extern PFNGLCOVERAGEMODULATIONTABLENVPROC __glewCoverageModulationTableNV;
extern PFNGLGETCOVERAGEMODULATIONTABLENVPROC __glewGetCoverageModulationTableNV;
extern PFNGLRASTERSAMPLESEXTPROC __glewRasterSamplesEXT;

extern PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern PFNGLDELETESEMAPHORESEXTPROC __glewDeleteSemaphoresEXT;
extern PFNGLGENSEMAPHORESEXTPROC __glewGenSemaphoresEXT;
extern PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC __glewGetSemaphoreParameterui64vEXT;
extern PFNGLISSEMAPHOREEXTPROC __glewIsSemaphoreEXT;
extern PFNGLSEMAPHOREPARAMETERUI64VEXTPROC __glewSemaphoreParameterui64vEXT;
extern PFNGLSIGNALSEMAPHOREEXTPROC __glewSignalSemaphoreEXT;
extern PFNGLWAITSEMAPHOREEXTPROC __glewWaitSemaphoreEXT;

extern PFNGLIMPORTSEMAPHOREFDEXTPROC __glewImportSemaphoreFdEXT;

extern PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC __glewImportSemaphoreWin32HandleEXT;
extern PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC __glewImportSemaphoreWin32NameEXT;

extern PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC __glewClearPixelLocalStorageuiEXT;
extern PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewFramebufferPixelLocalStorageSizeEXT;
extern PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewGetFramebufferPixelLocalStorageSizeEXT;

extern PFNGLTEXPAGECOMMITMENTEXTPROC __glewTexPageCommitmentEXT;
extern PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern PFNGLTEXSTORAGE1DEXTPROC __glewTexStorage1DEXT;
extern PFNGLTEXSTORAGE2DEXTPROC __glewTexStorage2DEXT;
extern PFNGLTEXSTORAGE3DEXTPROC __glewTexStorage3DEXT;
extern PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern PFNGLTEXTUREVIEWEXTPROC __glewTextureViewEXT;

extern PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern PFNGLBINDARRAYSETEXTPROC __glewBindArraySetEXT;
extern PFNGLCREATEARRAYSETEXTPROC __glewCreateArraySetExt;
extern PFNGLDELETEARRAYSETSEXTPROC __glewDeleteArraySetsEXT;

extern PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC __glewAcquireKeyedMutexWin32EXT;
extern PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC __glewReleaseKeyedMutexWin32EXT;

extern PFNGLWINDOWRECTANGLESEXTPROC __glewWindowRectanglesEXT;

extern PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern PFNGLOBJECTLABELPROC __glewObjectLabel;
extern PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern PFNGLMAXSHADERCOMPILERTHREADSKHRPROC __glewMaxShaderCompilerThreadsKHR;

extern PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern PFNGLREADNPIXELSPROC __glewReadnPixels;

extern PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern PFNGLLGPUCOPYIMAGESUBDATANVXPROC __glewLGPUCopyImageSubDataNVX;
extern PFNGLLGPUINTERLOCKNVXPROC __glewLGPUInterlockNVX;
extern PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC __glewLGPUNamedBufferSubDataNVX;

extern PFNGLSTEREOPARAMETERFNVPROC __glewStereoParameterfNV;
extern PFNGLSTEREOPARAMETERINVPROC __glewStereoParameteriNV;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern PFNGLVIEWPORTPOSITIONWSCALENVPROC __glewViewportPositionWScaleNV;

extern PFNGLCALLCOMMANDLISTNVPROC __glewCallCommandListNV;
extern PFNGLCOMMANDLISTSEGMENTSNVPROC __glewCommandListSegmentsNV;
extern PFNGLCOMPILECOMMANDLISTNVPROC __glewCompileCommandListNV;
extern PFNGLCREATECOMMANDLISTSNVPROC __glewCreateCommandListsNV;
extern PFNGLCREATESTATESNVPROC __glewCreateStatesNV;
extern PFNGLDELETECOMMANDLISTSNVPROC __glewDeleteCommandListsNV;
extern PFNGLDELETESTATESNVPROC __glewDeleteStatesNV;
extern PFNGLDRAWCOMMANDSADDRESSNVPROC __glewDrawCommandsAddressNV;
extern PFNGLDRAWCOMMANDSNVPROC __glewDrawCommandsNV;
extern PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC __glewDrawCommandsStatesAddressNV;
extern PFNGLDRAWCOMMANDSSTATESNVPROC __glewDrawCommandsStatesNV;
extern PFNGLGETCOMMANDHEADERNVPROC __glewGetCommandHeaderNV;
extern PFNGLGETSTAGEINDEXNVPROC __glewGetStageIndexNV;
extern PFNGLISCOMMANDLISTNVPROC __glewIsCommandListNV;
extern PFNGLISSTATENVPROC __glewIsStateNV;
extern PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC __glewListDrawCommandsStatesClientNV;
extern PFNGLSTATECAPTURENVPROC __glewStateCaptureNV;

extern PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern PFNGLSUBPIXELPRECISIONBIASNVPROC __glewSubpixelPrecisionBiasNV;

extern PFNGLCONSERVATIVERASTERPARAMETERFNVPROC __glewConservativeRasterParameterfNV;

extern PFNGLCONSERVATIVERASTERPARAMETERINVPROC __glewConservativeRasterParameteriNV;

extern PFNGLCOPYBUFFERSUBDATANVPROC __glewCopyBufferSubDataNV;

extern PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern PFNGLDRAWBUFFERSNVPROC __glewDrawBuffersNV;

extern PFNGLDRAWARRAYSINSTANCEDNVPROC __glewDrawArraysInstancedNV;
extern PFNGLDRAWELEMENTSINSTANCEDNVPROC __glewDrawElementsInstancedNV;

extern PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern PFNGLDRAWVKIMAGENVPROC __glewDrawVkImageNV;
extern PFNGLGETVKPROCADDRNVPROC __glewGetVkProcAddrNV;
extern PFNGLSIGNALVKFENCENVPROC __glewSignalVkFenceNV;
extern PFNGLSIGNALVKSEMAPHORENVPROC __glewSignalVkSemaphoreNV;
extern PFNGLWAITVKSEMAPHORENVPROC __glewWaitVkSemaphoreNV;

extern PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern PFNGLISFENCENVPROC __glewIsFenceNV;
extern PFNGLSETFENCENVPROC __glewSetFenceNV;
extern PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern PFNGLFRAGMENTCOVERAGECOLORNVPROC __glewFragmentCoverageColorNV;

extern PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern PFNGLBLITFRAMEBUFFERNVPROC __glewBlitFramebufferNV;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC __glewRenderbufferStorageMultisampleNV;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern PFNGLMULTICASTBARRIERNVPROC __glewMulticastBarrierNV;
extern PFNGLMULTICASTBLITFRAMEBUFFERNVPROC __glewMulticastBlitFramebufferNV;
extern PFNGLMULTICASTBUFFERSUBDATANVPROC __glewMulticastBufferSubDataNV;
extern PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC __glewMulticastCopyBufferSubDataNV;
extern PFNGLMULTICASTCOPYIMAGESUBDATANVPROC __glewMulticastCopyImageSubDataNV;
extern PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewMulticastFramebufferSampleLocationsfvNV;
extern PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC __glewMulticastGetQueryObjecti64vNV;
extern PFNGLMULTICASTGETQUERYOBJECTIVNVPROC __glewMulticastGetQueryObjectivNV;
extern PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC __glewMulticastGetQueryObjectui64vNV;
extern PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC __glewMulticastGetQueryObjectuivNV;
extern PFNGLMULTICASTWAITSYNCNVPROC __glewMulticastWaitSyncNV;
extern PFNGLRENDERGPUMASKNVPROC __glewRenderGpuMaskNV;

extern PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern PFNGLVERTEXATTRIBDIVISORNVPROC __glewVertexAttribDivisorNV;

extern PFNGLGETINTERNALFORMATSAMPLEIVNVPROC __glewGetInternalformatSampleivNV;

extern PFNGLUNIFORMMATRIX2X3FVNVPROC __glewUniformMatrix2x3fvNV;
extern PFNGLUNIFORMMATRIX2X4FVNVPROC __glewUniformMatrix2x4fvNV;
extern PFNGLUNIFORMMATRIX3X2FVNVPROC __glewUniformMatrix3x2fvNV;
extern PFNGLUNIFORMMATRIX3X4FVNVPROC __glewUniformMatrix3x4fvNV;
extern PFNGLUNIFORMMATRIX4X2FVNVPROC __glewUniformMatrix4x2fvNV;
extern PFNGLUNIFORMMATRIX4X3FVNVPROC __glewUniformMatrix4x3fvNV;

extern PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern PFNGLGETPROGRAMRESOURCEFVNVPROC __glewGetProgramResourcefvNV;
extern PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern PFNGLISPATHNVPROC __glewIsPathNV;
extern PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern PFNGLMATRIXLOAD3X2FNVPROC __glewMatrixLoad3x2fNV;
extern PFNGLMATRIXLOAD3X3FNVPROC __glewMatrixLoad3x3fNV;
extern PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC __glewMatrixLoadTranspose3x3fNV;
extern PFNGLMATRIXMULT3X2FNVPROC __glewMatrixMult3x2fNV;
extern PFNGLMATRIXMULT3X3FNVPROC __glewMatrixMult3x3fNV;
extern PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC __glewMatrixMultTranspose3x3fNV;
extern PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern PFNGLPATHGLYPHINDEXARRAYNVPROC __glewPathGlyphIndexArrayNV;
extern PFNGLPATHGLYPHINDEXRANGENVPROC __glewPathGlyphIndexRangeNV;
extern PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC __glewPathMemoryGlyphIndexArrayNV;
extern PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC __glewProgramPathFragmentInputGenNV;
extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC __glewStencilThenCoverFillPathInstancedNV;
extern PFNGLSTENCILTHENCOVERFILLPATHNVPROC __glewStencilThenCoverFillPathNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC __glewStencilThenCoverStrokePathInstancedNV;
extern PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC __glewStencilThenCoverStrokePathNV;
extern PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern PFNGLPOLYGONMODENVPROC __glewPolygonModeNV;

extern PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewFramebufferSampleLocationsfvNV;
extern PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewNamedFramebufferSampleLocationsfvNV;

extern PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern PFNGLCOMPRESSEDTEXIMAGE3DNVPROC __glewCompressedTexImage3DNV;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC __glewCompressedTexSubImage3DNV;
extern PFNGLCOPYTEXSUBIMAGE3DNVPROC __glewCopyTexSubImage3DNV;
extern PFNGLFRAMEBUFFERTEXTURELAYERNVPROC __glewFramebufferTextureLayerNV;
extern PFNGLTEXIMAGE3DNVPROC __glewTexImage3DNV;
extern PFNGLTEXSUBIMAGE3DNVPROC __glewTexSubImage3DNV;

extern PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern PFNGLDEPTHRANGEARRAYFVNVPROC __glewDepthRangeArrayfvNV;
extern PFNGLDEPTHRANGEINDEXEDFNVPROC __glewDepthRangeIndexedfNV;
extern PFNGLDISABLEINVPROC __glewDisableiNV;
extern PFNGLENABLEINVPROC __glewEnableiNV;
extern PFNGLGETFLOATI_VNVPROC __glewGetFloati_vNV;
extern PFNGLISENABLEDINVPROC __glewIsEnablediNV;
extern PFNGLSCISSORARRAYVNVPROC __glewScissorArrayvNV;
extern PFNGLSCISSORINDEXEDNVPROC __glewScissorIndexedNV;
extern PFNGLSCISSORINDEXEDVNVPROC __glewScissorIndexedvNV;
extern PFNGLVIEWPORTARRAYVNVPROC __glewViewportArrayvNV;
extern PFNGLVIEWPORTINDEXEDFNVPROC __glewViewportIndexedfNV;
extern PFNGLVIEWPORTINDEXEDFVNVPROC __glewViewportIndexedfvNV;

extern PFNGLVIEWPORTSWIZZLENVPROC __glewViewportSwizzleNV;

extern PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewFramebufferTextureMultiviewOVR;

extern PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC __glewFramebufferTextureMultisampleMultiviewOVR;

extern PFNGLALPHAFUNCQCOMPROC __glewAlphaFuncQCOM;

extern PFNGLDISABLEDRIVERCONTROLQCOMPROC __glewDisableDriverControlQCOM;
extern PFNGLENABLEDRIVERCONTROLQCOMPROC __glewEnableDriverControlQCOM;
extern PFNGLGETDRIVERCONTROLSTRINGQCOMPROC __glewGetDriverControlStringQCOM;
extern PFNGLGETDRIVERCONTROLSQCOMPROC __glewGetDriverControlsQCOM;

extern PFNGLEXTGETBUFFERPOINTERVQCOMPROC __glewExtGetBufferPointervQCOM;
extern PFNGLEXTGETBUFFERSQCOMPROC __glewExtGetBuffersQCOM;
extern PFNGLEXTGETFRAMEBUFFERSQCOMPROC __glewExtGetFramebuffersQCOM;
extern PFNGLEXTGETRENDERBUFFERSQCOMPROC __glewExtGetRenderbuffersQCOM;
extern PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC __glewExtGetTexLevelParameterivQCOM;
extern PFNGLEXTGETTEXSUBIMAGEQCOMPROC __glewExtGetTexSubImageQCOM;
extern PFNGLEXTGETTEXTURESQCOMPROC __glewExtGetTexturesQCOM;
extern PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC __glewExtTexObjectStateOverrideiQCOM;

extern PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC __glewExtGetProgramBinarySourceQCOM;
extern PFNGLEXTGETPROGRAMSQCOMPROC __glewExtGetProgramsQCOM;
extern PFNGLEXTGETSHADERSQCOMPROC __glewExtGetShadersQCOM;
extern PFNGLEXTISPROGRAMBINARYQCOMPROC __glewExtIsProgramBinaryQCOM;

extern PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC __glewFramebufferFoveationConfigQCOM;
extern PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC __glewFramebufferFoveationParametersQCOM;

extern PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC __glewFramebufferFetchBarrierQCOM;

extern PFNGLENDTILINGQCOMPROC __glewEndTilingQCOM;
extern PFNGLSTARTTILINGQCOMPROC __glewStartTilingQCOM;

extern PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern PFNGLCLEARCOLORXPROC __glewClearColorx;
extern PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern PFNGLCOLOR4XPROC __glewColor4x;
extern PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern PFNGLFOGXPROC __glewFogx;
extern PFNGLFOGXVPROC __glewFogxv;
extern PFNGLFRUSTUMFPROC __glewFrustumf;
extern PFNGLFRUSTUMXPROC __glewFrustumx;
extern PFNGLLIGHTMODELXPROC __glewLightModelx;
extern PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern PFNGLLIGHTXPROC __glewLightx;
extern PFNGLLIGHTXVPROC __glewLightxv;
extern PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern PFNGLMATERIALXPROC __glewMaterialx;
extern PFNGLMATERIALXVPROC __glewMaterialxv;
extern PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern PFNGLNORMAL3XPROC __glewNormal3x;
extern PFNGLORTHOFPROC __glewOrthof;
extern PFNGLORTHOXPROC __glewOrthox;
extern PFNGLPOINTSIZEXPROC __glewPointSizex;
extern PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern PFNGLROTATEXPROC __glewRotatex;
extern PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern PFNGLSCALEXPROC __glewScalex;
extern PFNGLTEXENVXPROC __glewTexEnvx;
extern PFNGLTEXENVXVPROC __glewTexEnvxv;
extern PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern PFNGLTRANSLATEXPROC __glewTranslatex;

extern PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern PFNGLGETFIXEDVPROC __glewGetFixedv;
extern PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC __glewInterleavedTextureCoordSetsSGIS;
extern PFNGLSELECTTEXTURECOORDSETSGISPROC __glewSelectTextureCoordSetSGIS;
extern PFNGLSELECTTEXTURESGISPROC __glewSelectTextureSGIS;
extern PFNGLSELECTTEXTURETRANSFORMSGISPROC __glewSelectTextureTransformSGIS;

extern PFNGLMULTISAMPLESUBRECTPOSSGISPROC __glewMultisampleSubRectPosSGIS;

extern PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern PFNGLADDRESSSPACEPROC __glewAddressSpace;
extern PFNGLDATAPIPEPROC __glewDataPipe;

extern PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern PFNGLFOGLAYERSSGIXPROC __glewFogLayersSGIX;
extern PFNGLGETFOGLAYERSSGIXPROC __glewGetFogLayersSGIX;

extern PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern PFNGLIGLOOINTERFACESGIXPROC __glewIglooInterfaceSGIX;

extern PFNGLALLOCMPEGPREDICTORSSGIXPROC __glewAllocMPEGPredictorsSGIX;
extern PFNGLDELETEMPEGPREDICTORSSGIXPROC __glewDeleteMPEGPredictorsSGIX;
extern PFNGLGENMPEGPREDICTORSSGIXPROC __glewGenMPEGPredictorsSGIX;
extern PFNGLGETMPEGPARAMETERFVSGIXPROC __glewGetMPEGParameterfvSGIX;
extern PFNGLGETMPEGPARAMETERIVSGIXPROC __glewGetMPEGParameterivSGIX;
extern PFNGLGETMPEGPREDICTORSGIXPROC __glewGetMPEGPredictorSGIX;
extern PFNGLGETMPEGQUANTTABLEUBVPROC __glewGetMPEGQuantTableubv;
extern PFNGLISMPEGPREDICTORSGIXPROC __glewIsMPEGPredictorSGIX;
extern PFNGLMPEGPREDICTORSGIXPROC __glewMPEGPredictorSGIX;
extern PFNGLMPEGQUANTTABLEUBVPROC __glewMPEGQuantTableubv;
extern PFNGLSWAPMPEGPREDICTORSSGIXPROC __glewSwapMPEGPredictorsSGIX;

extern PFNGLGETNONLINLIGHTFVSGIXPROC __glewGetNonlinLightfvSGIX;
extern PFNGLGETNONLINMATERIALFVSGIXPROC __glewGetNonlinMaterialfvSGIX;
extern PFNGLNONLINLIGHTFVSGIXPROC __glewNonlinLightfvSGIX;
extern PFNGLNONLINMATERIALFVSGIXPROC __glewNonlinMaterialfvSGIX;

extern PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern PFNGLDEFORMSGIXPROC __glewDeformSGIX;
extern PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC __glewLoadIdentityDeformationMapSGIX;

extern PFNGLMESHBREADTHSGIXPROC __glewMeshBreadthSGIX;
extern PFNGLMESHSTRIDESGIXPROC __glewMeshStrideSGIX;

extern PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern PFNGLGETVECTOROPERATIONSGIXPROC __glewGetVectorOperationSGIX;
extern PFNGLVECTOROPERATIONSGIXPROC __glewVectorOperationSGIX;

extern PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC __glewAreVertexArraysResidentSGIX;
extern PFNGLBINDVERTEXARRAYSGIXPROC __glewBindVertexArraySGIX;
extern PFNGLDELETEVERTEXARRAYSSGIXPROC __glewDeleteVertexArraysSGIX;
extern PFNGLGENVERTEXARRAYSSGIXPROC __glewGenVertexArraysSGIX;
extern PFNGLISVERTEXARRAYSGIXPROC __glewIsVertexArraySGIX;
extern PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC __glewPrioritizeVertexArraysSGIX;

extern PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC __glewGetPixelTransformParameterfvSGI;
extern PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC __glewGetPixelTransformParameterivSGI;
extern PFNGLPIXELTRANSFORMPARAMETERFSGIPROC __glewPixelTransformParameterfSGI;
extern PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC __glewPixelTransformParameterfvSGI;
extern PFNGLPIXELTRANSFORMPARAMETERISGIPROC __glewPixelTransformParameteriSGI;
extern PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC __glewPixelTransformParameterivSGI;
extern PFNGLPIXELTRANSFORMSGIPROC __glewPixelTransformSGI;

extern PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
extern GLboolean __GLEW_VERSION_1_1;
extern GLboolean __GLEW_VERSION_1_2;
extern GLboolean __GLEW_VERSION_1_2_1;
extern GLboolean __GLEW_VERSION_1_3;
extern GLboolean __GLEW_VERSION_1_4;
extern GLboolean __GLEW_VERSION_1_5;
extern GLboolean __GLEW_VERSION_2_0;
extern GLboolean __GLEW_VERSION_2_1;
extern GLboolean __GLEW_VERSION_3_0;
extern GLboolean __GLEW_VERSION_3_1;
extern GLboolean __GLEW_VERSION_3_2;
extern GLboolean __GLEW_VERSION_3_3;
extern GLboolean __GLEW_VERSION_4_0;
extern GLboolean __GLEW_VERSION_4_1;
extern GLboolean __GLEW_VERSION_4_2;
extern GLboolean __GLEW_VERSION_4_3;
extern GLboolean __GLEW_VERSION_4_4;
extern GLboolean __GLEW_VERSION_4_5;
extern GLboolean __GLEW_VERSION_4_6;
extern GLboolean __GLEW_3DFX_multisample;
extern GLboolean __GLEW_3DFX_tbuffer;
extern GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern GLboolean __GLEW_AMD_blend_minmax_factor;
extern GLboolean __GLEW_AMD_compressed_3DC_texture;
extern GLboolean __GLEW_AMD_compressed_ATC_texture;
extern GLboolean __GLEW_AMD_conservative_depth;
extern GLboolean __GLEW_AMD_debug_output;
extern GLboolean __GLEW_AMD_depth_clamp_separate;
extern GLboolean __GLEW_AMD_draw_buffers_blend;
extern GLboolean __GLEW_AMD_framebuffer_sample_positions;
extern GLboolean __GLEW_AMD_gcn_shader;
extern GLboolean __GLEW_AMD_gpu_shader_half_float;
extern GLboolean __GLEW_AMD_gpu_shader_int16;
extern GLboolean __GLEW_AMD_gpu_shader_int64;
extern GLboolean __GLEW_AMD_interleaved_elements;
extern GLboolean __GLEW_AMD_multi_draw_indirect;
extern GLboolean __GLEW_AMD_name_gen_delete;
extern GLboolean __GLEW_AMD_occlusion_query_event;
extern GLboolean __GLEW_AMD_performance_monitor;
extern GLboolean __GLEW_AMD_pinned_memory;
extern GLboolean __GLEW_AMD_program_binary_Z400;
extern GLboolean __GLEW_AMD_query_buffer_object;
extern GLboolean __GLEW_AMD_sample_positions;
extern GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern GLboolean __GLEW_AMD_shader_ballot;
extern GLboolean __GLEW_AMD_shader_explicit_vertex_parameter;
extern GLboolean __GLEW_AMD_shader_stencil_export;
extern GLboolean __GLEW_AMD_shader_stencil_value_export;
extern GLboolean __GLEW_AMD_shader_trinary_minmax;
extern GLboolean __GLEW_AMD_sparse_texture;
extern GLboolean __GLEW_AMD_stencil_operation_extended;
extern GLboolean __GLEW_AMD_texture_gather_bias_lod;
extern GLboolean __GLEW_AMD_texture_texture4;
extern GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern GLboolean __GLEW_AMD_transform_feedback4;
extern GLboolean __GLEW_AMD_vertex_shader_layer;
extern GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern GLboolean __GLEW_ANDROID_extension_pack_es31a;
extern GLboolean __GLEW_ANGLE_depth_texture;
extern GLboolean __GLEW_ANGLE_framebuffer_blit;
extern GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern GLboolean __GLEW_ANGLE_instanced_arrays;
extern GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern GLboolean __GLEW_ANGLE_program_binary;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern GLboolean __GLEW_ANGLE_texture_usage;
extern GLboolean __GLEW_ANGLE_timer_query;
extern GLboolean __GLEW_ANGLE_translated_shader_source;
extern GLboolean __GLEW_APPLE_aux_depth_stencil;
extern GLboolean __GLEW_APPLE_client_storage;
extern GLboolean __GLEW_APPLE_clip_distance;
extern GLboolean __GLEW_APPLE_color_buffer_packed_float;
extern GLboolean __GLEW_APPLE_copy_texture_levels;
extern GLboolean __GLEW_APPLE_element_array;
extern GLboolean __GLEW_APPLE_fence;
extern GLboolean __GLEW_APPLE_float_pixels;
extern GLboolean __GLEW_APPLE_flush_buffer_range;
extern GLboolean __GLEW_APPLE_framebuffer_multisample;
extern GLboolean __GLEW_APPLE_object_purgeable;
extern GLboolean __GLEW_APPLE_pixel_buffer;
extern GLboolean __GLEW_APPLE_rgb_422;
extern GLboolean __GLEW_APPLE_row_bytes;
extern GLboolean __GLEW_APPLE_specular_vector;
extern GLboolean __GLEW_APPLE_sync;
extern GLboolean __GLEW_APPLE_texture_2D_limited_npot;
extern GLboolean __GLEW_APPLE_texture_format_BGRA8888;
extern GLboolean __GLEW_APPLE_texture_max_level;
extern GLboolean __GLEW_APPLE_texture_packed_float;
extern GLboolean __GLEW_APPLE_texture_range;
extern GLboolean __GLEW_APPLE_transform_hint;
extern GLboolean __GLEW_APPLE_vertex_array_object;
extern GLboolean __GLEW_APPLE_vertex_array_range;
extern GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern GLboolean __GLEW_APPLE_ycbcr_422;
extern GLboolean __GLEW_ARB_ES2_compatibility;
extern GLboolean __GLEW_ARB_ES3_1_compatibility;
extern GLboolean __GLEW_ARB_ES3_2_compatibility;
extern GLboolean __GLEW_ARB_ES3_compatibility;
extern GLboolean __GLEW_ARB_arrays_of_arrays;
extern GLboolean __GLEW_ARB_base_instance;
extern GLboolean __GLEW_ARB_bindless_texture;
extern GLboolean __GLEW_ARB_blend_func_extended;
extern GLboolean __GLEW_ARB_buffer_storage;
extern GLboolean __GLEW_ARB_cl_event;
extern GLboolean __GLEW_ARB_clear_buffer_object;
extern GLboolean __GLEW_ARB_clear_texture;
extern GLboolean __GLEW_ARB_clip_control;
extern GLboolean __GLEW_ARB_color_buffer_float;
extern GLboolean __GLEW_ARB_compatibility;
extern GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern GLboolean __GLEW_ARB_compute_shader;
extern GLboolean __GLEW_ARB_compute_variable_group_size;
extern GLboolean __GLEW_ARB_conditional_render_inverted;
extern GLboolean __GLEW_ARB_conservative_depth;
extern GLboolean __GLEW_ARB_copy_buffer;
extern GLboolean __GLEW_ARB_copy_image;
extern GLboolean __GLEW_ARB_cull_distance;
extern GLboolean __GLEW_ARB_debug_output;
extern GLboolean __GLEW_ARB_depth_buffer_float;
extern GLboolean __GLEW_ARB_depth_clamp;
extern GLboolean __GLEW_ARB_depth_texture;
extern GLboolean __GLEW_ARB_derivative_control;
extern GLboolean __GLEW_ARB_direct_state_access;
extern GLboolean __GLEW_ARB_draw_buffers;
extern GLboolean __GLEW_ARB_draw_buffers_blend;
extern GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern GLboolean __GLEW_ARB_draw_indirect;
extern GLboolean __GLEW_ARB_draw_instanced;
extern GLboolean __GLEW_ARB_enhanced_layouts;
extern GLboolean __GLEW_ARB_explicit_attrib_location;
extern GLboolean __GLEW_ARB_explicit_uniform_location;
extern GLboolean __GLEW_ARB_fragment_coord_conventions;
extern GLboolean __GLEW_ARB_fragment_layer_viewport;
extern GLboolean __GLEW_ARB_fragment_program;
extern GLboolean __GLEW_ARB_fragment_program_shadow;
extern GLboolean __GLEW_ARB_fragment_shader;
extern GLboolean __GLEW_ARB_fragment_shader_interlock;
extern GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern GLboolean __GLEW_ARB_framebuffer_object;
extern GLboolean __GLEW_ARB_framebuffer_sRGB;
extern GLboolean __GLEW_ARB_geometry_shader4;
extern GLboolean __GLEW_ARB_get_program_binary;
extern GLboolean __GLEW_ARB_get_texture_sub_image;
extern GLboolean __GLEW_ARB_gl_spirv;
extern GLboolean __GLEW_ARB_gpu_shader5;
extern GLboolean __GLEW_ARB_gpu_shader_fp64;
extern GLboolean __GLEW_ARB_gpu_shader_int64;
extern GLboolean __GLEW_ARB_half_float_pixel;
extern GLboolean __GLEW_ARB_half_float_vertex;
extern GLboolean __GLEW_ARB_imaging;
extern GLboolean __GLEW_ARB_indirect_parameters;
extern GLboolean __GLEW_ARB_instanced_arrays;
extern GLboolean __GLEW_ARB_internalformat_query;
extern GLboolean __GLEW_ARB_internalformat_query2;
extern GLboolean __GLEW_ARB_invalidate_subdata;
extern GLboolean __GLEW_ARB_map_buffer_alignment;
extern GLboolean __GLEW_ARB_map_buffer_range;
extern GLboolean __GLEW_ARB_matrix_palette;
extern GLboolean __GLEW_ARB_multi_bind;
extern GLboolean __GLEW_ARB_multi_draw_indirect;
extern GLboolean __GLEW_ARB_multisample;
extern GLboolean __GLEW_ARB_multitexture;
extern GLboolean __GLEW_ARB_occlusion_query;
extern GLboolean __GLEW_ARB_occlusion_query2;
extern GLboolean __GLEW_ARB_parallel_shader_compile;
extern GLboolean __GLEW_ARB_pipeline_statistics_query;
extern GLboolean __GLEW_ARB_pixel_buffer_object;
extern GLboolean __GLEW_ARB_point_parameters;
extern GLboolean __GLEW_ARB_point_sprite;
extern GLboolean __GLEW_ARB_polygon_offset_clamp;
extern GLboolean __GLEW_ARB_post_depth_coverage;
extern GLboolean __GLEW_ARB_program_interface_query;
extern GLboolean __GLEW_ARB_provoking_vertex;
extern GLboolean __GLEW_ARB_query_buffer_object;
extern GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern GLboolean __GLEW_ARB_robustness;
extern GLboolean __GLEW_ARB_robustness_application_isolation;
extern GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern GLboolean __GLEW_ARB_sample_locations;
extern GLboolean __GLEW_ARB_sample_shading;
extern GLboolean __GLEW_ARB_sampler_objects;
extern GLboolean __GLEW_ARB_seamless_cube_map;
extern GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern GLboolean __GLEW_ARB_separate_shader_objects;
extern GLboolean __GLEW_ARB_shader_atomic_counter_ops;
extern GLboolean __GLEW_ARB_shader_atomic_counters;
extern GLboolean __GLEW_ARB_shader_ballot;
extern GLboolean __GLEW_ARB_shader_bit_encoding;
extern GLboolean __GLEW_ARB_shader_clock;
extern GLboolean __GLEW_ARB_shader_draw_parameters;
extern GLboolean __GLEW_ARB_shader_group_vote;
extern GLboolean __GLEW_ARB_shader_image_load_store;
extern GLboolean __GLEW_ARB_shader_image_size;
extern GLboolean __GLEW_ARB_shader_objects;
extern GLboolean __GLEW_ARB_shader_precision;
extern GLboolean __GLEW_ARB_shader_stencil_export;
extern GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern GLboolean __GLEW_ARB_shader_subroutine;
extern GLboolean __GLEW_ARB_shader_texture_image_samples;
extern GLboolean __GLEW_ARB_shader_texture_lod;
extern GLboolean __GLEW_ARB_shader_viewport_layer_array;
extern GLboolean __GLEW_ARB_shading_language_100;
extern GLboolean __GLEW_ARB_shading_language_420pack;
extern GLboolean __GLEW_ARB_shading_language_include;
extern GLboolean __GLEW_ARB_shading_language_packing;
extern GLboolean __GLEW_ARB_shadow;
extern GLboolean __GLEW_ARB_shadow_ambient;
extern GLboolean __GLEW_ARB_sparse_buffer;
extern GLboolean __GLEW_ARB_sparse_texture;
extern GLboolean __GLEW_ARB_sparse_texture2;
extern GLboolean __GLEW_ARB_sparse_texture_clamp;
extern GLboolean __GLEW_ARB_spirv_extensions;
extern GLboolean __GLEW_ARB_stencil_texturing;
extern GLboolean __GLEW_ARB_sync;
extern GLboolean __GLEW_ARB_tessellation_shader;
extern GLboolean __GLEW_ARB_texture_barrier;
extern GLboolean __GLEW_ARB_texture_border_clamp;
extern GLboolean __GLEW_ARB_texture_buffer_object;
extern GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern GLboolean __GLEW_ARB_texture_buffer_range;
extern GLboolean __GLEW_ARB_texture_compression;
extern GLboolean __GLEW_ARB_texture_compression_bptc;
extern GLboolean __GLEW_ARB_texture_compression_rgtc;
extern GLboolean __GLEW_ARB_texture_cube_map;
extern GLboolean __GLEW_ARB_texture_cube_map_array;
extern GLboolean __GLEW_ARB_texture_env_add;
extern GLboolean __GLEW_ARB_texture_env_combine;
extern GLboolean __GLEW_ARB_texture_env_crossbar;
extern GLboolean __GLEW_ARB_texture_env_dot3;
extern GLboolean __GLEW_ARB_texture_filter_anisotropic;
extern GLboolean __GLEW_ARB_texture_filter_minmax;
extern GLboolean __GLEW_ARB_texture_float;
extern GLboolean __GLEW_ARB_texture_gather;
extern GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern GLboolean __GLEW_ARB_texture_multisample;
extern GLboolean __GLEW_ARB_texture_non_power_of_two;
extern GLboolean __GLEW_ARB_texture_query_levels;
extern GLboolean __GLEW_ARB_texture_query_lod;
extern GLboolean __GLEW_ARB_texture_rectangle;
extern GLboolean __GLEW_ARB_texture_rg;
extern GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern GLboolean __GLEW_ARB_texture_stencil8;
extern GLboolean __GLEW_ARB_texture_storage;
extern GLboolean __GLEW_ARB_texture_storage_multisample;
extern GLboolean __GLEW_ARB_texture_swizzle;
extern GLboolean __GLEW_ARB_texture_view;
extern GLboolean __GLEW_ARB_timer_query;
extern GLboolean __GLEW_ARB_transform_feedback2;
extern GLboolean __GLEW_ARB_transform_feedback3;
extern GLboolean __GLEW_ARB_transform_feedback_instanced;
extern GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern GLboolean __GLEW_ARB_transpose_matrix;
extern GLboolean __GLEW_ARB_uniform_buffer_object;
extern GLboolean __GLEW_ARB_vertex_array_bgra;
extern GLboolean __GLEW_ARB_vertex_array_object;
extern GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern GLboolean __GLEW_ARB_vertex_attrib_binding;
extern GLboolean __GLEW_ARB_vertex_blend;
extern GLboolean __GLEW_ARB_vertex_buffer_object;
extern GLboolean __GLEW_ARB_vertex_program;
extern GLboolean __GLEW_ARB_vertex_shader;
extern GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern GLboolean __GLEW_ARB_viewport_array;
extern GLboolean __GLEW_ARB_window_pos;
extern GLboolean __GLEW_ARM_mali_program_binary;
extern GLboolean __GLEW_ARM_mali_shader_binary;
extern GLboolean __GLEW_ARM_rgba8;
extern GLboolean __GLEW_ARM_shader_framebuffer_fetch;
extern GLboolean __GLEW_ARM_shader_framebuffer_fetch_depth_stencil;
extern GLboolean __GLEW_ATIX_point_sprites;
extern GLboolean __GLEW_ATIX_texture_env_combine3;
extern GLboolean __GLEW_ATIX_texture_env_route;
extern GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern GLboolean __GLEW_ATI_draw_buffers;
extern GLboolean __GLEW_ATI_element_array;
extern GLboolean __GLEW_ATI_envmap_bumpmap;
extern GLboolean __GLEW_ATI_fragment_shader;
extern GLboolean __GLEW_ATI_map_object_buffer;
extern GLboolean __GLEW_ATI_meminfo;
extern GLboolean __GLEW_ATI_pn_triangles;
extern GLboolean __GLEW_ATI_separate_stencil;
extern GLboolean __GLEW_ATI_shader_texture_lod;
extern GLboolean __GLEW_ATI_text_fragment_shader;
extern GLboolean __GLEW_ATI_texture_compression_3dc;
extern GLboolean __GLEW_ATI_texture_env_combine3;
extern GLboolean __GLEW_ATI_texture_float;
extern GLboolean __GLEW_ATI_texture_mirror_once;
extern GLboolean __GLEW_ATI_vertex_array_object;
extern GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern GLboolean __GLEW_ATI_vertex_streams;
extern GLboolean __GLEW_EGL_KHR_context_flush_control;
extern GLboolean __GLEW_EGL_NV_robustness_video_memory_purge;
extern GLboolean __GLEW_EXT_422_pixels;
extern GLboolean __GLEW_EXT_Cg_shader;
extern GLboolean __GLEW_EXT_EGL_image_array;
extern GLboolean __GLEW_EXT_YUV_target;
extern GLboolean __GLEW_EXT_abgr;
extern GLboolean __GLEW_EXT_base_instance;
extern GLboolean __GLEW_EXT_bgra;
extern GLboolean __GLEW_EXT_bindable_uniform;
extern GLboolean __GLEW_EXT_blend_color;
extern GLboolean __GLEW_EXT_blend_equation_separate;
extern GLboolean __GLEW_EXT_blend_func_extended;
extern GLboolean __GLEW_EXT_blend_func_separate;
extern GLboolean __GLEW_EXT_blend_logic_op;
extern GLboolean __GLEW_EXT_blend_minmax;
extern GLboolean __GLEW_EXT_blend_subtract;
extern GLboolean __GLEW_EXT_buffer_storage;
extern GLboolean __GLEW_EXT_clear_texture;
extern GLboolean __GLEW_EXT_clip_cull_distance;
extern GLboolean __GLEW_EXT_clip_volume_hint;
extern GLboolean __GLEW_EXT_cmyka;
extern GLboolean __GLEW_EXT_color_buffer_float;
extern GLboolean __GLEW_EXT_color_buffer_half_float;
extern GLboolean __GLEW_EXT_color_subtable;
extern GLboolean __GLEW_EXT_compiled_vertex_array;
extern GLboolean __GLEW_EXT_compressed_ETC1_RGB8_sub_texture;
extern GLboolean __GLEW_EXT_conservative_depth;
extern GLboolean __GLEW_EXT_convolution;
extern GLboolean __GLEW_EXT_coordinate_frame;
extern GLboolean __GLEW_EXT_copy_image;
extern GLboolean __GLEW_EXT_copy_texture;
extern GLboolean __GLEW_EXT_cull_vertex;
extern GLboolean __GLEW_EXT_debug_label;
extern GLboolean __GLEW_EXT_debug_marker;
extern GLboolean __GLEW_EXT_depth_bounds_test;
extern GLboolean __GLEW_EXT_direct_state_access;
extern GLboolean __GLEW_EXT_discard_framebuffer;
extern GLboolean __GLEW_EXT_draw_buffers;
extern GLboolean __GLEW_EXT_draw_buffers2;
extern GLboolean __GLEW_EXT_draw_buffers_indexed;
extern GLboolean __GLEW_EXT_draw_elements_base_vertex;
extern GLboolean __GLEW_EXT_draw_instanced;
extern GLboolean __GLEW_EXT_draw_range_elements;
extern GLboolean __GLEW_EXT_external_buffer;
extern GLboolean __GLEW_EXT_float_blend;
extern GLboolean __GLEW_EXT_fog_coord;
extern GLboolean __GLEW_EXT_frag_depth;
extern GLboolean __GLEW_EXT_fragment_lighting;
extern GLboolean __GLEW_EXT_framebuffer_blit;
extern GLboolean __GLEW_EXT_framebuffer_multisample;
extern GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern GLboolean __GLEW_EXT_framebuffer_object;
extern GLboolean __GLEW_EXT_framebuffer_sRGB;
extern GLboolean __GLEW_EXT_geometry_point_size;
extern GLboolean __GLEW_EXT_geometry_shader;
extern GLboolean __GLEW_EXT_geometry_shader4;
extern GLboolean __GLEW_EXT_gpu_program_parameters;
extern GLboolean __GLEW_EXT_gpu_shader4;
extern GLboolean __GLEW_EXT_gpu_shader5;
extern GLboolean __GLEW_EXT_histogram;
extern GLboolean __GLEW_EXT_index_array_formats;
extern GLboolean __GLEW_EXT_index_func;
extern GLboolean __GLEW_EXT_index_material;
extern GLboolean __GLEW_EXT_index_texture;
extern GLboolean __GLEW_EXT_instanced_arrays;
extern GLboolean __GLEW_EXT_light_texture;
extern GLboolean __GLEW_EXT_map_buffer_range;
extern GLboolean __GLEW_EXT_memory_object;
extern GLboolean __GLEW_EXT_memory_object_fd;
extern GLboolean __GLEW_EXT_memory_object_win32;
extern GLboolean __GLEW_EXT_misc_attribute;
extern GLboolean __GLEW_EXT_multi_draw_arrays;
extern GLboolean __GLEW_EXT_multi_draw_indirect;
extern GLboolean __GLEW_EXT_multiple_textures;
extern GLboolean __GLEW_EXT_multisample;
extern GLboolean __GLEW_EXT_multisample_compatibility;
extern GLboolean __GLEW_EXT_multisampled_render_to_texture;
extern GLboolean __GLEW_EXT_multisampled_render_to_texture2;
extern GLboolean __GLEW_EXT_multiview_draw_buffers;
extern GLboolean __GLEW_EXT_packed_depth_stencil;
extern GLboolean __GLEW_EXT_packed_float;
extern GLboolean __GLEW_EXT_packed_pixels;
extern GLboolean __GLEW_EXT_paletted_texture;
extern GLboolean __GLEW_EXT_pixel_buffer_object;
extern GLboolean __GLEW_EXT_pixel_transform;
extern GLboolean __GLEW_EXT_pixel_transform_color_table;
extern GLboolean __GLEW_EXT_point_parameters;
extern GLboolean __GLEW_EXT_polygon_offset;
extern GLboolean __GLEW_EXT_polygon_offset_clamp;
extern GLboolean __GLEW_EXT_post_depth_coverage;
extern GLboolean __GLEW_EXT_provoking_vertex;
extern GLboolean __GLEW_EXT_pvrtc_sRGB;
extern GLboolean __GLEW_EXT_raster_multisample;
extern GLboolean __GLEW_EXT_read_format_bgra;
extern GLboolean __GLEW_EXT_render_snorm;
extern GLboolean __GLEW_EXT_rescale_normal;
extern GLboolean __GLEW_EXT_sRGB;
extern GLboolean __GLEW_EXT_sRGB_write_control;
extern GLboolean __GLEW_EXT_scene_marker;
extern GLboolean __GLEW_EXT_secondary_color;
extern GLboolean __GLEW_EXT_semaphore;
extern GLboolean __GLEW_EXT_semaphore_fd;
extern GLboolean __GLEW_EXT_semaphore_win32;
extern GLboolean __GLEW_EXT_separate_shader_objects;
extern GLboolean __GLEW_EXT_separate_specular_color;
extern GLboolean __GLEW_EXT_shader_framebuffer_fetch;
extern GLboolean __GLEW_EXT_shader_group_vote;
extern GLboolean __GLEW_EXT_shader_image_load_formatted;
extern GLboolean __GLEW_EXT_shader_image_load_store;
extern GLboolean __GLEW_EXT_shader_implicit_conversions;
extern GLboolean __GLEW_EXT_shader_integer_mix;
extern GLboolean __GLEW_EXT_shader_io_blocks;
extern GLboolean __GLEW_EXT_shader_non_constant_global_initializers;
extern GLboolean __GLEW_EXT_shader_pixel_local_storage;
extern GLboolean __GLEW_EXT_shader_pixel_local_storage2;
extern GLboolean __GLEW_EXT_shader_texture_lod;
extern GLboolean __GLEW_EXT_shadow_funcs;
extern GLboolean __GLEW_EXT_shadow_samplers;
extern GLboolean __GLEW_EXT_shared_texture_palette;
extern GLboolean __GLEW_EXT_sparse_texture;
extern GLboolean __GLEW_EXT_sparse_texture2;
extern GLboolean __GLEW_EXT_stencil_clear_tag;
extern GLboolean __GLEW_EXT_stencil_two_side;
extern GLboolean __GLEW_EXT_stencil_wrap;
extern GLboolean __GLEW_EXT_subtexture;
extern GLboolean __GLEW_EXT_texture;
extern GLboolean __GLEW_EXT_texture3D;
extern GLboolean __GLEW_EXT_texture_array;
extern GLboolean __GLEW_EXT_texture_buffer_object;
extern GLboolean __GLEW_EXT_texture_compression_astc_decode_mode;
extern GLboolean __GLEW_EXT_texture_compression_astc_decode_mode_rgb9e5;
extern GLboolean __GLEW_EXT_texture_compression_bptc;
extern GLboolean __GLEW_EXT_texture_compression_dxt1;
extern GLboolean __GLEW_EXT_texture_compression_latc;
extern GLboolean __GLEW_EXT_texture_compression_rgtc;
extern GLboolean __GLEW_EXT_texture_compression_s3tc;
extern GLboolean __GLEW_EXT_texture_cube_map;
extern GLboolean __GLEW_EXT_texture_cube_map_array;
extern GLboolean __GLEW_EXT_texture_edge_clamp;
extern GLboolean __GLEW_EXT_texture_env;
extern GLboolean __GLEW_EXT_texture_env_add;
extern GLboolean __GLEW_EXT_texture_env_combine;
extern GLboolean __GLEW_EXT_texture_env_dot3;
extern GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern GLboolean __GLEW_EXT_texture_filter_minmax;
extern GLboolean __GLEW_EXT_texture_format_BGRA8888;
extern GLboolean __GLEW_EXT_texture_integer;
extern GLboolean __GLEW_EXT_texture_lod_bias;
extern GLboolean __GLEW_EXT_texture_mirror_clamp;
extern GLboolean __GLEW_EXT_texture_norm16;
extern GLboolean __GLEW_EXT_texture_object;
extern GLboolean __GLEW_EXT_texture_perturb_normal;
extern GLboolean __GLEW_EXT_texture_rectangle;
extern GLboolean __GLEW_EXT_texture_rg;
extern GLboolean __GLEW_EXT_texture_sRGB;
extern GLboolean __GLEW_EXT_texture_sRGB_R8;
extern GLboolean __GLEW_EXT_texture_sRGB_RG8;
extern GLboolean __GLEW_EXT_texture_sRGB_decode;
extern GLboolean __GLEW_EXT_texture_shared_exponent;
extern GLboolean __GLEW_EXT_texture_snorm;
extern GLboolean __GLEW_EXT_texture_storage;
extern GLboolean __GLEW_EXT_texture_swizzle;
extern GLboolean __GLEW_EXT_texture_type_2_10_10_10_REV;
extern GLboolean __GLEW_EXT_texture_view;
extern GLboolean __GLEW_EXT_timer_query;
extern GLboolean __GLEW_EXT_transform_feedback;
extern GLboolean __GLEW_EXT_unpack_subimage;
extern GLboolean __GLEW_EXT_vertex_array;
extern GLboolean __GLEW_EXT_vertex_array_bgra;
extern GLboolean __GLEW_EXT_vertex_array_setXXX;
extern GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern GLboolean __GLEW_EXT_vertex_shader;
extern GLboolean __GLEW_EXT_vertex_weighting;
extern GLboolean __GLEW_EXT_win32_keyed_mutex;
extern GLboolean __GLEW_EXT_window_rectangles;
extern GLboolean __GLEW_EXT_x11_sync_object;
extern GLboolean __GLEW_GREMEDY_frame_terminator;
extern GLboolean __GLEW_GREMEDY_string_marker;
extern GLboolean __GLEW_HP_convolution_border_modes;
extern GLboolean __GLEW_HP_image_transform;
extern GLboolean __GLEW_HP_occlusion_test;
extern GLboolean __GLEW_HP_texture_lighting;
extern GLboolean __GLEW_IBM_cull_vertex;
extern GLboolean __GLEW_IBM_multimode_draw_arrays;
extern GLboolean __GLEW_IBM_rasterpos_clip;
extern GLboolean __GLEW_IBM_static_data;
extern GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern GLboolean __GLEW_IBM_vertex_array_lists;
extern GLboolean __GLEW_INGR_color_clamp;
extern GLboolean __GLEW_INGR_interlace_read;
extern GLboolean __GLEW_INTEL_conservative_rasterization;
extern GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern GLboolean __GLEW_INTEL_framebuffer_CMAA;
extern GLboolean __GLEW_INTEL_map_texture;
extern GLboolean __GLEW_INTEL_parallel_arrays;
extern GLboolean __GLEW_INTEL_performance_query;
extern GLboolean __GLEW_INTEL_texture_scissor;
extern GLboolean __GLEW_KHR_blend_equation_advanced;
extern GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern GLboolean __GLEW_KHR_context_flush_control;
extern GLboolean __GLEW_KHR_debug;
extern GLboolean __GLEW_KHR_no_error;
extern GLboolean __GLEW_KHR_parallel_shader_compile;
extern GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern GLboolean __GLEW_KHR_robustness;
extern GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern GLboolean __GLEW_KHR_texture_compression_astc_sliced_3d;
extern GLboolean __GLEW_KTX_buffer_region;
extern GLboolean __GLEW_MESAX_texture_stack;
extern GLboolean __GLEW_MESA_pack_invert;
extern GLboolean __GLEW_MESA_resize_buffers;
extern GLboolean __GLEW_MESA_shader_integer_functions;
extern GLboolean __GLEW_MESA_window_pos;
extern GLboolean __GLEW_MESA_ycbcr_texture;
extern GLboolean __GLEW_NVX_blend_equation_advanced_multi_draw_buffers;
extern GLboolean __GLEW_NVX_conditional_render;
extern GLboolean __GLEW_NVX_gpu_memory_info;
extern GLboolean __GLEW_NVX_linked_gpu_multicast;
extern GLboolean __GLEW_NV_3dvision_settings;
extern GLboolean __GLEW_NV_EGL_stream_consumer_external;
extern GLboolean __GLEW_NV_alpha_to_coverage_dither_control;
extern GLboolean __GLEW_NV_bgr;
extern GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern GLboolean __GLEW_NV_bindless_texture;
extern GLboolean __GLEW_NV_blend_equation_advanced;
extern GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern GLboolean __GLEW_NV_blend_minmax_factor;
extern GLboolean __GLEW_NV_blend_square;
extern GLboolean __GLEW_NV_clip_space_w_scaling;
extern GLboolean __GLEW_NV_command_list;
extern GLboolean __GLEW_NV_compute_program5;
extern GLboolean __GLEW_NV_conditional_render;
extern GLboolean __GLEW_NV_conservative_raster;
extern GLboolean __GLEW_NV_conservative_raster_dilate;
extern GLboolean __GLEW_NV_conservative_raster_pre_snap_triangles;
extern GLboolean __GLEW_NV_copy_buffer;
extern GLboolean __GLEW_NV_copy_depth_to_color;
extern GLboolean __GLEW_NV_copy_image;
extern GLboolean __GLEW_NV_deep_texture3D;
extern GLboolean __GLEW_NV_depth_buffer_float;
extern GLboolean __GLEW_NV_depth_clamp;
extern GLboolean __GLEW_NV_depth_range_unclamped;
extern GLboolean __GLEW_NV_draw_buffers;
extern GLboolean __GLEW_NV_draw_instanced;
extern GLboolean __GLEW_NV_draw_texture;
extern GLboolean __GLEW_NV_draw_vulkan_image;
extern GLboolean __GLEW_NV_evaluators;
extern GLboolean __GLEW_NV_explicit_attrib_location;
extern GLboolean __GLEW_NV_explicit_multisample;
extern GLboolean __GLEW_NV_fbo_color_attachments;
extern GLboolean __GLEW_NV_fence;
extern GLboolean __GLEW_NV_fill_rectangle;
extern GLboolean __GLEW_NV_float_buffer;
extern GLboolean __GLEW_NV_fog_distance;
extern GLboolean __GLEW_NV_fragment_coverage_to_color;
extern GLboolean __GLEW_NV_fragment_program;
extern GLboolean __GLEW_NV_fragment_program2;
extern GLboolean __GLEW_NV_fragment_program4;
extern GLboolean __GLEW_NV_fragment_program_option;
extern GLboolean __GLEW_NV_fragment_shader_interlock;
extern GLboolean __GLEW_NV_framebuffer_blit;
extern GLboolean __GLEW_NV_framebuffer_mixed_samples;
extern GLboolean __GLEW_NV_framebuffer_multisample;
extern GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern GLboolean __GLEW_NV_generate_mipmap_sRGB;
extern GLboolean __GLEW_NV_geometry_program4;
extern GLboolean __GLEW_NV_geometry_shader4;
extern GLboolean __GLEW_NV_geometry_shader_passthrough;
extern GLboolean __GLEW_NV_gpu_multicast;
extern GLboolean __GLEW_NV_gpu_program4;
extern GLboolean __GLEW_NV_gpu_program5;
extern GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern GLboolean __GLEW_NV_gpu_program_fp64;
extern GLboolean __GLEW_NV_gpu_shader5;
extern GLboolean __GLEW_NV_half_float;
extern GLboolean __GLEW_NV_image_formats;
extern GLboolean __GLEW_NV_instanced_arrays;
extern GLboolean __GLEW_NV_internalformat_sample_query;
extern GLboolean __GLEW_NV_light_max_exponent;
extern GLboolean __GLEW_NV_multisample_coverage;
extern GLboolean __GLEW_NV_multisample_filter_hint;
extern GLboolean __GLEW_NV_non_square_matrices;
extern GLboolean __GLEW_NV_occlusion_query;
extern GLboolean __GLEW_NV_pack_subimage;
extern GLboolean __GLEW_NV_packed_depth_stencil;
extern GLboolean __GLEW_NV_packed_float;
extern GLboolean __GLEW_NV_packed_float_linear;
extern GLboolean __GLEW_NV_parameter_buffer_object;
extern GLboolean __GLEW_NV_parameter_buffer_object2;
extern GLboolean __GLEW_NV_path_rendering;
extern GLboolean __GLEW_NV_path_rendering_shared_edge;
extern GLboolean __GLEW_NV_pixel_buffer_object;
extern GLboolean __GLEW_NV_pixel_data_range;
extern GLboolean __GLEW_NV_platform_binary;
extern GLboolean __GLEW_NV_point_sprite;
extern GLboolean __GLEW_NV_polygon_mode;
extern GLboolean __GLEW_NV_present_video;
extern GLboolean __GLEW_NV_primitive_restart;
extern GLboolean __GLEW_NV_read_depth;
extern GLboolean __GLEW_NV_read_depth_stencil;
extern GLboolean __GLEW_NV_read_stencil;
extern GLboolean __GLEW_NV_register_combiners;
extern GLboolean __GLEW_NV_register_combiners2;
extern GLboolean __GLEW_NV_robustness_video_memory_purge;
extern GLboolean __GLEW_NV_sRGB_formats;
extern GLboolean __GLEW_NV_sample_locations;
extern GLboolean __GLEW_NV_sample_mask_override_coverage;
extern GLboolean __GLEW_NV_shader_atomic_counters;
extern GLboolean __GLEW_NV_shader_atomic_float;
extern GLboolean __GLEW_NV_shader_atomic_float64;
extern GLboolean __GLEW_NV_shader_atomic_fp16_vector;
extern GLboolean __GLEW_NV_shader_atomic_int64;
extern GLboolean __GLEW_NV_shader_buffer_load;
extern GLboolean __GLEW_NV_shader_noperspective_interpolation;
extern GLboolean __GLEW_NV_shader_storage_buffer_object;
extern GLboolean __GLEW_NV_shader_thread_group;
extern GLboolean __GLEW_NV_shader_thread_shuffle;
extern GLboolean __GLEW_NV_shadow_samplers_array;
extern GLboolean __GLEW_NV_shadow_samplers_cube;
extern GLboolean __GLEW_NV_stereo_view_rendering;
extern GLboolean __GLEW_NV_tessellation_program5;
extern GLboolean __GLEW_NV_texgen_emboss;
extern GLboolean __GLEW_NV_texgen_reflection;
extern GLboolean __GLEW_NV_texture_array;
extern GLboolean __GLEW_NV_texture_barrier;
extern GLboolean __GLEW_NV_texture_border_clamp;
extern GLboolean __GLEW_NV_texture_compression_latc;
extern GLboolean __GLEW_NV_texture_compression_s3tc;
extern GLboolean __GLEW_NV_texture_compression_s3tc_update;
extern GLboolean __GLEW_NV_texture_compression_vtc;
extern GLboolean __GLEW_NV_texture_env_combine4;
extern GLboolean __GLEW_NV_texture_expand_normal;
extern GLboolean __GLEW_NV_texture_multisample;
extern GLboolean __GLEW_NV_texture_npot_2D_mipmap;
extern GLboolean __GLEW_NV_texture_rectangle;
extern GLboolean __GLEW_NV_texture_rectangle_compressed;
extern GLboolean __GLEW_NV_texture_shader;
extern GLboolean __GLEW_NV_texture_shader2;
extern GLboolean __GLEW_NV_texture_shader3;
extern GLboolean __GLEW_NV_transform_feedback;
extern GLboolean __GLEW_NV_transform_feedback2;
extern GLboolean __GLEW_NV_uniform_buffer_unified_memory;
extern GLboolean __GLEW_NV_vdpau_interop;
extern GLboolean __GLEW_NV_vertex_array_range;
extern GLboolean __GLEW_NV_vertex_array_range2;
extern GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern GLboolean __GLEW_NV_vertex_program;
extern GLboolean __GLEW_NV_vertex_program1_1;
extern GLboolean __GLEW_NV_vertex_program2;
extern GLboolean __GLEW_NV_vertex_program2_option;
extern GLboolean __GLEW_NV_vertex_program3;
extern GLboolean __GLEW_NV_vertex_program4;
extern GLboolean __GLEW_NV_video_capture;
extern GLboolean __GLEW_NV_viewport_array;
extern GLboolean __GLEW_NV_viewport_array2;
extern GLboolean __GLEW_NV_viewport_swizzle;
extern GLboolean __GLEW_OES_byte_coordinates;
extern GLboolean __GLEW_OML_interlace;
extern GLboolean __GLEW_OML_resample;
extern GLboolean __GLEW_OML_subsample;
extern GLboolean __GLEW_OVR_multiview;
extern GLboolean __GLEW_OVR_multiview2;
extern GLboolean __GLEW_OVR_multiview_multisampled_render_to_texture;
extern GLboolean __GLEW_PGI_misc_hints;
extern GLboolean __GLEW_PGI_vertex_hints;
extern GLboolean __GLEW_QCOM_alpha_test;
extern GLboolean __GLEW_QCOM_binning_control;
extern GLboolean __GLEW_QCOM_driver_control;
extern GLboolean __GLEW_QCOM_extended_get;
extern GLboolean __GLEW_QCOM_extended_get2;
extern GLboolean __GLEW_QCOM_framebuffer_foveated;
extern GLboolean __GLEW_QCOM_perfmon_global_mode;
extern GLboolean __GLEW_QCOM_shader_framebuffer_fetch_noncoherent;
extern GLboolean __GLEW_QCOM_tiled_rendering;
extern GLboolean __GLEW_QCOM_writeonly_rendering;
extern GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern GLboolean __GLEW_REGAL_enable;
extern GLboolean __GLEW_REGAL_error_string;
extern GLboolean __GLEW_REGAL_extension_query;
extern GLboolean __GLEW_REGAL_log;
extern GLboolean __GLEW_REGAL_proc_address;
extern GLboolean __GLEW_REND_screen_coordinates;
extern GLboolean __GLEW_S3_s3tc;
extern GLboolean __GLEW_SGIS_clip_band_hint;
extern GLboolean __GLEW_SGIS_color_range;
extern GLboolean __GLEW_SGIS_detail_texture;
extern GLboolean __GLEW_SGIS_fog_function;
extern GLboolean __GLEW_SGIS_generate_mipmap;
extern GLboolean __GLEW_SGIS_line_texgen;
extern GLboolean __GLEW_SGIS_multisample;
extern GLboolean __GLEW_SGIS_multitexture;
extern GLboolean __GLEW_SGIS_pixel_texture;
extern GLboolean __GLEW_SGIS_point_line_texgen;
extern GLboolean __GLEW_SGIS_shared_multisample;
extern GLboolean __GLEW_SGIS_sharpen_texture;
extern GLboolean __GLEW_SGIS_texture4D;
extern GLboolean __GLEW_SGIS_texture_border_clamp;
extern GLboolean __GLEW_SGIS_texture_edge_clamp;
extern GLboolean __GLEW_SGIS_texture_filter4;
extern GLboolean __GLEW_SGIS_texture_lod;
extern GLboolean __GLEW_SGIS_texture_select;
extern GLboolean __GLEW_SGIX_async;
extern GLboolean __GLEW_SGIX_async_histogram;
extern GLboolean __GLEW_SGIX_async_pixel;
extern GLboolean __GLEW_SGIX_bali_g_instruments;
extern GLboolean __GLEW_SGIX_bali_r_instruments;
extern GLboolean __GLEW_SGIX_bali_timer_instruments;
extern GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern GLboolean __GLEW_SGIX_blend_cadd;
extern GLboolean __GLEW_SGIX_blend_cmultiply;
extern GLboolean __GLEW_SGIX_calligraphic_fragment;
extern GLboolean __GLEW_SGIX_clipmap;
extern GLboolean __GLEW_SGIX_color_matrix_accuracy;
extern GLboolean __GLEW_SGIX_color_table_index_mode;
extern GLboolean __GLEW_SGIX_complex_polar;
extern GLboolean __GLEW_SGIX_convolution_accuracy;
extern GLboolean __GLEW_SGIX_cube_map;
extern GLboolean __GLEW_SGIX_cylinder_texgen;
extern GLboolean __GLEW_SGIX_datapipe;
extern GLboolean __GLEW_SGIX_decimation;
extern GLboolean __GLEW_SGIX_depth_pass_instrument;
extern GLboolean __GLEW_SGIX_depth_texture;
extern GLboolean __GLEW_SGIX_dvc;
extern GLboolean __GLEW_SGIX_flush_raster;
extern GLboolean __GLEW_SGIX_fog_blend;
extern GLboolean __GLEW_SGIX_fog_factor_to_alpha;
extern GLboolean __GLEW_SGIX_fog_layers;
extern GLboolean __GLEW_SGIX_fog_offset;
extern GLboolean __GLEW_SGIX_fog_patchy;
extern GLboolean __GLEW_SGIX_fog_scale;
extern GLboolean __GLEW_SGIX_fog_texture;
extern GLboolean __GLEW_SGIX_fragment_lighting_space;
extern GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern GLboolean __GLEW_SGIX_fragments_instrument;
extern GLboolean __GLEW_SGIX_framezoom;
extern GLboolean __GLEW_SGIX_icc_texture;
extern GLboolean __GLEW_SGIX_igloo_interface;
extern GLboolean __GLEW_SGIX_image_compression;
extern GLboolean __GLEW_SGIX_impact_pixel_texture;
extern GLboolean __GLEW_SGIX_instrument_error;
extern GLboolean __GLEW_SGIX_interlace;
extern GLboolean __GLEW_SGIX_ir_instrument1;
extern GLboolean __GLEW_SGIX_line_quality_hint;
extern GLboolean __GLEW_SGIX_list_priority;
extern GLboolean __GLEW_SGIX_mpeg1;
extern GLboolean __GLEW_SGIX_mpeg2;
extern GLboolean __GLEW_SGIX_nonlinear_lighting_pervertex;
extern GLboolean __GLEW_SGIX_nurbs_eval;
extern GLboolean __GLEW_SGIX_occlusion_instrument;
extern GLboolean __GLEW_SGIX_packed_6bytes;
extern GLboolean __GLEW_SGIX_pixel_texture;
extern GLboolean __GLEW_SGIX_pixel_texture_bits;
extern GLboolean __GLEW_SGIX_pixel_texture_lod;
extern GLboolean __GLEW_SGIX_pixel_tiles;
extern GLboolean __GLEW_SGIX_polynomial_ffd;
extern GLboolean __GLEW_SGIX_quad_mesh;
extern GLboolean __GLEW_SGIX_reference_plane;
extern GLboolean __GLEW_SGIX_resample;
extern GLboolean __GLEW_SGIX_scalebias_hint;
extern GLboolean __GLEW_SGIX_shadow;
extern GLboolean __GLEW_SGIX_shadow_ambient;
extern GLboolean __GLEW_SGIX_slim;
extern GLboolean __GLEW_SGIX_spotlight_cutoff;
extern GLboolean __GLEW_SGIX_sprite;
extern GLboolean __GLEW_SGIX_subdiv_patch;
extern GLboolean __GLEW_SGIX_subsample;
extern GLboolean __GLEW_SGIX_tag_sample_buffer;
extern GLboolean __GLEW_SGIX_texture_add_env;
extern GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern GLboolean __GLEW_SGIX_texture_lod_bias;
extern GLboolean __GLEW_SGIX_texture_mipmap_anisotropic;
extern GLboolean __GLEW_SGIX_texture_multi_buffer;
extern GLboolean __GLEW_SGIX_texture_phase;
extern GLboolean __GLEW_SGIX_texture_range;
extern GLboolean __GLEW_SGIX_texture_scale_bias;
extern GLboolean __GLEW_SGIX_texture_supersample;
extern GLboolean __GLEW_SGIX_vector_ops;
extern GLboolean __GLEW_SGIX_vertex_array_object;
extern GLboolean __GLEW_SGIX_vertex_preclip;
extern GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern GLboolean __GLEW_SGIX_ycrcb;
extern GLboolean __GLEW_SGIX_ycrcb_subsample;
extern GLboolean __GLEW_SGIX_ycrcba;
extern GLboolean __GLEW_SGI_color_matrix;
extern GLboolean __GLEW_SGI_color_table;
extern GLboolean __GLEW_SGI_complex;
extern GLboolean __GLEW_SGI_complex_type;
extern GLboolean __GLEW_SGI_fft;
extern GLboolean __GLEW_SGI_texture_color_table;
extern GLboolean __GLEW_SUNX_constant_data;
extern GLboolean __GLEW_SUN_convolution_border_modes;
extern GLboolean __GLEW_SUN_global_alpha;
extern GLboolean __GLEW_SUN_mesh_array;
extern GLboolean __GLEW_SUN_read_video_pixels;
extern GLboolean __GLEW_SUN_slice_accum;
extern GLboolean __GLEW_SUN_triangle_list;
extern GLboolean __GLEW_SUN_vertex;
extern GLboolean __GLEW_WIN_phong_shading;
extern GLboolean __GLEW_WIN_scene_markerXXX;
extern GLboolean __GLEW_WIN_specular_fog;
extern GLboolean __GLEW_WIN_swap_hint;




























extern GLenum __stdcall glewInit (void);
extern GLboolean __stdcall glewIsSupported (const char *name);




#line 23654 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"



#line 23658 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

extern GLboolean glewExperimental;
extern GLboolean __stdcall glewGetExtension (const char *name);
extern const GLubyte * __stdcall glewGetErrorString (GLenum error);
extern const GLubyte * __stdcall glewGetString (GLenum name);


}
#line 23667 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 23672 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 23677 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 23682 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"




#line 23687 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glew\\include\\gl\\glew.h"

#line 4 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\buffer.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
































extern "C" {
#line 35 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
























































#line 92 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"





 
  
 

#line 102 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
#line 103 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




 
 
#line 110 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




 
 
#line 117 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




























#line 146 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
 

#line 149 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




#line 154 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




#line 159 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




#line 164 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"




#line 169 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"

#line 171 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
  #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.15063.0\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 172 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
  

#line 175 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
 #line 176 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
 

#line 179 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
#line 180 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"







#line 188 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"







#line 196 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"


#line 199 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"


#line 202 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"
 
 
#line 205 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"


































































































































































































































































































































































































































































































































































typedef void (*GLFWglproc)(void);













typedef void (*GLFWvkproc)(void);











typedef struct GLFWmonitor GLFWmonitor;











typedef struct GLFWwindow GLFWwindow;











typedef struct GLFWcursor GLFWcursor;















typedef void (* GLFWerrorfun)(int,const char*);


















typedef void (* GLFWwindowposfun)(GLFWwindow*,int,int);

















typedef void (* GLFWwindowsizefun)(GLFWwindow*,int,int);















typedef void (* GLFWwindowclosefun)(GLFWwindow*);















typedef void (* GLFWwindowrefreshfun)(GLFWwindow*);
















typedef void (* GLFWwindowfocusfun)(GLFWwindow*,int);

















typedef void (* GLFWwindowiconifyfun)(GLFWwindow*,int);

















typedef void (* GLFWframebuffersizefun)(GLFWwindow*,int,int);




















typedef void (* GLFWmousebuttonfun)(GLFWwindow*,int,int,int);


















typedef void (* GLFWcursorposfun)(GLFWwindow*,double,double);
















typedef void (* GLFWcursorenterfun)(GLFWwindow*,int);
















typedef void (* GLFWscrollfun)(GLFWwindow*,double,double);




















typedef void (* GLFWkeyfun)(GLFWwindow*,int,int,int,int);
















typedef void (* GLFWcharfun)(GLFWwindow*,unsigned int);




















typedef void (* GLFWcharmodsfun)(GLFWwindow*,unsigned int,int);
















typedef void (* GLFWdropfun)(GLFWwindow*,int,const char**);















typedef void (* GLFWmonitorfun)(GLFWmonitor*,int);
















typedef void (* GLFWjoystickfun)(int,int);













typedef struct GLFWvidmode
{
    

    int width;
    

    int height;
    

    int redBits;
    

    int greenBits;
    

    int blueBits;
    

    int refreshRate;
} GLFWvidmode;












typedef struct GLFWgammaramp
{
    

    unsigned short* red;
    

    unsigned short* green;
    

    unsigned short* blue;
    

    unsigned int size;
} GLFWgammaramp;









typedef struct GLFWimage
{
    

    int width;
    

    int height;
    

    unsigned char* pixels;
} GLFWimage;






































 int glfwInit(void);































 void glfwTerminate(void);


























 void glfwGetVersion(int* major, int* minor, int* rev);






























 const char* glfwGetVersionString(void);

































 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun);




























 GLFWmonitor** glfwGetMonitors(int* count);























 GLFWmonitor* glfwGetPrimaryMonitor(void);
























 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);

































 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);

























 const char* glfwGetMonitorName(GLFWmonitor* monitor);






















 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun cbfun);
































 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);



























 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);





















 void glfwSetGamma(GLFWmonitor* monitor, float gamma);

























 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);





























 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);

















 void glfwDefaultWindowHints(void);



























 void glfwWindowHint(int hint, int value);
























































































































 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);




























 void glfwDestroyWindow(GLFWwindow* window);



















 int glfwWindowShouldClose(GLFWwindow* window);





















 void glfwSetWindowShouldClose(GLFWwindow* window, int value);
























 void glfwSetWindowTitle(GLFWwindow* window, const char* title);






































 void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);



























 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);






























 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);





























 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);







































 void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);







































 void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);





































 void glfwSetWindowSize(GLFWwindow* window, int width, int height);




























 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);




































 void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);


























 void glfwIconifyWindow(GLFWwindow* window);


























 void glfwRestoreWindow(GLFWwindow* window);
























 void glfwMaximizeWindow(GLFWwindow* window);





















 void glfwShowWindow(GLFWwindow* window);





















 void glfwHideWindow(GLFWwindow* window);



























 void glfwFocusWindow(GLFWwindow* window);





















 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
















































 void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
































 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);






















 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);




















 void* glfwGetWindowUserPointer(GLFWwindow* window);























 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun cbfun);
























 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun cbfun);
































 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun cbfun);




























 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun cbfun);



























 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun cbfun);






















 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun cbfun);






















 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun cbfun);


































 void glfwPollEvents(void);












































 void glfwWaitEvents(void);













































 void glfwWaitEventsTimeout(double timeout);























 void glfwPostEmptyEvent(void);






















 int glfwGetInputMode(GLFWwindow* window, int mode);















































 void glfwSetInputMode(GLFWwindow* window, int mode, int value);
























































 const char* glfwGetKeyName(int key, int scancode);







































 int glfwGetKey(GLFWwindow* window, int key);




























 int glfwGetMouseButton(GLFWwindow* window, int button);





































 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);




































 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);







































 GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);
























 GLFWcursor* glfwCreateStandardCursor(int shape);























 void glfwDestroyCursor(GLFWcursor* cursor);


























 void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);










































 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun cbfun);





































 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun cbfun);
































 GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun cbfun);





























 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun cbfun);
























 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun cbfun);























 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun cbfun);


























 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun cbfun);



























 GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun cbfun);



















 int glfwJoystickPresent(int joy);

































 const float* glfwGetJoystickAxes(int joy, int* count);


































 const unsigned char* glfwGetJoystickButtons(int joy, int* count);































 const char* glfwGetJoystickName(int joy);






















 GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun cbfun);
























 void glfwSetClipboardString(GLFWwindow* window, const char* string);





























 const char* glfwGetClipboardString(GLFWwindow* window);


























 double glfwGetTime(void);


























 void glfwSetTime(double time);





















 uint64_t glfwGetTimerValue(void);



















 uint64_t glfwGetTimerFrequency(void);

































 void glfwMakeContextCurrent(GLFWwindow* window);




















 GLFWwindow* glfwGetCurrentContext(void);

































 void glfwSwapBuffers(GLFWwindow* window);














































 void glfwSwapInterval(int interval);





































 int glfwExtensionSupported(const char* extension);









































 GLFWglproc glfwGetProcAddress(const char* procname);

























 int glfwVulkanSupported(void);











































 const char** glfwGetRequiredInstanceExtensions(uint32_t* count);































































































































#line 4222 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"









 
 
#line 4234 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"


 
 
#line 4239 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"





}
#line 4246 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"

#line 4248 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\glfw\\include\\glfw\\glfw3.h"


#line 5 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\buffer.h"

namespace spork { namespace graphics {
		
	class Buffer
	{
	private:
		GLuint m_BufferID;
		GLuint m_ComponentCount;
	public:
		Buffer(GLfloat* data, GLsizei count, GLuint componenetCount);

		void bind() const;
		void unbind() const;

		inline GLuint getComponenetCount() const { return m_ComponentCount; }

	};

}	}
#line 4 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\indexbuffer.h"
#pragma once




namespace spork { namespace graphics {

		class indexBuffer
		{
		private:
			GLuint m_BufferID;
			GLuint m_Count;
		public:
			indexBuffer(GLuint* data, GLsizei count);

			void bind() const;
			void unbind() const;

			inline GLuint getCount() const { return m_Count; }

		};

}	}

#line 5 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\vertexarray.h"
#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4700)

namespace std {
		
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _Count) noexcept
	{	
	_Ty *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count))
		_Xbad_alloc();	
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest);
	throw;
	}

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
	{	
	return (_Rechecked(_Dest,
		_Uninitialized_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Uninitialized_copy_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 103);
	return (_Uninitialized_copy1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_FwdIt>()));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 120 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		_Construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest);
	throw;
	}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	
	if (0 < _Count)
		return (_Copy_memmove(_First, _First + _Count, _Dest));
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 184);
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 196);
	return (_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 208);
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 209);
	return (_Uninitialized_copy_n_unchecked(_First, _Count, _Dest));
	}
 #line 213 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest, _Al);
	throw;
	}

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_copy_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,
		_Ptr_copy_cat(_First, _Dest),
		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	return (_Rechecked(_Dest,
		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Unfancy(_Dest), ::std:: move(*_First));
	} catch (...) {
	_Destroy_range(_Next, _Dest, _Al);
	throw;
	}

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_move_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	typedef decltype(::std:: move(*_First)) _Src_type; 
	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,
		_Ptr_move_cat(_First, _Dest),
		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	return (_Rechecked(_Dest,
		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(_Unfancy(_First), _Val);
	} catch (...) {
	_Destroy_range(_Next, _First);
	throw;
	}
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, true_type)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninitialized_fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 355);
	_Uninitialized_fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Construct(_Unfancy(_First), _Val);
	} catch (...) {
	_Destroy_range(_Next, _First);
	throw;
	}

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, true_type)
	{	
	if (0 < _Count)
		{
		:: memset(_First, _Val, _Count);
		return (_First + _Count);
		}

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	return (_Uninitialized_fill_n_unchecked1(_First, _Count, _Val, _Fill_memset_is_safe(_First, _Val)));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	
	return (_Rechecked(_First,
		_Uninitialized_fill_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Val)));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
		_Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Al.construct(_Unfancy(_First), *_Pval);
	} catch (...) {
	_Destroy_range(_Next, _First, _Al);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
		_Wrap_alloc<_Alloc>&, true_type)
	{	
	:: memset(_First, *_Pval, _Count);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Iter_value_t<_FwdIt> * _Pval, _Wrap_alloc<_Alloc>& _Al)
	{	
	_Uninit_alloc_fill_n1(_First, _Count, _Pval, _Al,
		typename conjunction<decltype(_Fill_memset_is_safe(_First, *_Pval)),
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(*_Pval)>>::type());
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Al.construct(_Unfancy(_First));
	} catch (...) {
	_Destroy_range(_Next, _First, _Al);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>&, true_type)
	{	
	:: memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	typedef _Iter_value_t<_FwdIt> _Ty;
	_Uninitialized_default_fill_n1(_First, _Count, _Al,
		typename conjunction<
			is_pointer<_FwdIt>,
			is_scalar<_Ty>,
			negation<is_volatile<_Ty>>,
			negation<is_member_pointer<_Ty>>,
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
	}

		
template<class _OutIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator& operator=(const _Ty& _Val)
		{	
		_Construct(_Unfancy(_Next), _Val);
		return (*this);
		}

	raw_storage_iterator& operator=(_Ty&& _Val)
		{	
		_Construct(_Unfancy(_Next), ::std:: move(_Val));
		return (*this);
		}

	raw_storage_iterator& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator operator++(int)
		{	
		raw_storage_iterator _Ans = *this;
		++_Next;
		return (_Ans);
		}

	_OutIt base() const
		{	
		return (_Next);
		}

private:
	_OutIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator() noexcept
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator& operator=(const _Temp_iterator& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}

		return (*this);
		}

	_Temp_iterator& operator=(_Ty&& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				::std:: forward<_Ty>(_Val);	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, ::std:: forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}

		return (*this);
		}

	_Temp_iterator& operator*()
		{	
		return (*this);
		}

	_Temp_iterator& operator++()
		{	
		return (*this);
		}

	_Temp_iterator& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =

				::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}

		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

 
		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	
		}

	_Ty *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) noexcept
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(_Myt& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() noexcept
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() noexcept
		{	
		_Other *_Cvtptr = _Myptr;	
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	_Myt& operator=(_Myt& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr() noexcept
		{	
		delete _Myptr;
		}

	_Ty& operator*() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 764);
 #line 766 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (*get());
		}

	_Ty *operator->() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 774);
 #line 776 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (get());
		}

	_Ty *get() const noexcept
		{	
		return (_Myptr);
		}

	_Ty *release() noexcept
		{	
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	
	};
 #line 803 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 809 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
#line 810 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
 #pragma warning(disable: 4244)

namespace std {
 

		
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Myvec::value_type,
			typename _Myvec::difference_type,
			typename _Myvec::const_pointer,
			typename _Myvec::const_reference,
			_Iterator_base>
	{	
public:
	typedef _Vector_const_iterator<_Myvec> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::const_pointer pointer;
	typedef typename _Myvec::const_reference reference;
	typedef typename _Myvec::pointer _Tptr;

	_Vector_const_iterator()
		: _Ptr()
		{	
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pvector);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Const_cast(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == _Tptr()
			|| _Ptr < _Mycont->_Myfirst
			|| _Mycont->_Mylast <= _Ptr)
			{	
			_Debug_message(L"vector iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 73);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 74, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 74, 0); };
			}

 




#line 83 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		;

		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Mycont->_Mylast <= _Ptr)
			{	
			_Debug_message(L"vector iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 102);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 103, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 103, 0); };
			}

 




#line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Ptr <= _Mycont->_Myfirst)
			{	
			_Debug_message(L"vector iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 132);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 133, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 133, 0); };
			}

 




#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
			if (_Mycont == 0
				|| _Ptr + _Off < _Mycont->_Myfirst
				|| _Mycont->_Mylast < _Ptr + _Off)
				{
				_Debug_message(L"vector iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 164);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 165, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 165, 0); };
				}
			}

 







#line 178 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			{
			_Debug_message(L"vector iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 248);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 249, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 249, 0); };
			}
		}

 









#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	_Tptr _Ptr;	
	};

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>&
		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
			typename _Vector_const_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;

	_Vector_iterator()
		{	
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (this->_Ptr);
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>&
		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
			typename _Vector_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _Vec_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Vec_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_Vec_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	
public:
	typedef _Vector_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Myt> iterator;
	typedef _Vector_const_iterator<_Myt> const_iterator;

	_Vector_val()
		: _Myfirst(),
		_Mylast(),
		_Myend()
		{	
		}

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

		
template<class _Alloc_types>
	class _Vector_alloc
	{	
public:
	typedef _Vector_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;

 























#line 542 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	_Vector_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_Vector_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Alloc_proxy();
		}

	~_Vector_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 610 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_Vector_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _Vector_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	pointer& _Myfirst() noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	const pointer& _Myfirst() const noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	pointer& _Mylast() noexcept
		{	
		return (_Get_data()._Mylast);
		}

	const pointer& _Mylast() const noexcept
		{	
		return (_Get_data()._Mylast);
		}

	pointer& _Myend() noexcept
		{	
		return (_Get_data()._Myend);
		}

	const pointer& _Myend() const noexcept
		{	
		return (_Get_data()._Myend);
		}

private:
	_Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class vector
		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
	{	
public:
	typedef vector<_Ty, _Alloc> _Myt;
	typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

 
 

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		}

	explicit vector(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		if (_Buy(_Count))
			{	
			try {
			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,
				this->_Getal());
			this->_Mylast() += _Count;
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(size_type _Count, const value_type& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		_Construct(_First, _Last, _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		try {

		for (; _First != _Last; ++_First)
			emplace_back(*_First);

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		if (_Buy(::std:: distance(_First, _Last)))
			{	
			try {
			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	void _Construct_n(size_type _Count, const value_type *_Pval)
		{	
		if (_Buy(_Count))
			{	
			try {
			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 854 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this != &_Right)
			{	
			_Tidy();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all((_Myt&)_Right);
		this->_Myfirst() = _Right._Myfirst();
		this->_Mylast() = _Right._Mylast();
		this->_Myend() = _Right._Myend();

		_Right._Myfirst() = pointer();
		_Right._Mylast() = pointer();
		_Right._Myend() = pointer();
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Construct(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	void push_back(value_type&& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				::std:: forward<value_type>(this->_Myfirst()[_Idx]));
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				::std:: forward<value_type>(_Val));
			++this->_Mylast();
			}
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: move(_Val)));
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		if (this->_Mylast() == this->_Myend())
			_Reserve(1);
		_Orphan_range(this->_Mylast(), this->_Mylast());
		this->_Getal().construct(_Unfancy(this->_Mylast()),
			::std:: forward<_Valty>(_Val)...);
		++this->_Mylast();
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector emplace iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 941);
 #line 943 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		emplace_back(::std:: forward<_Valty>(_Val)...);
		::std:: rotate(begin() + _Off, end() - 1, end());
		return (begin() + _Off);
		}


	vector(::std:: initializer_list<value_type> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Construct(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<value_type> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy();
				this->_Copy_alloc(_Right._Getal());
				}

			this->_Orphan_all();

			if (_Right.empty())
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = _Copy_unchecked(_Right._Myfirst(),
					_Right._Mylast(), this->_Myfirst());	
				_Destroy(_Ptr, this->_Mylast());	
				this->_Mylast() = this->_Myfirst() + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst() + size();
				_Copy_unchecked(_Right._Myfirst(),
					_Ptr, this->_Myfirst());
				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
					this->_Mylast());
				}
			else
				{	
				if (this->_Myfirst() != pointer())
					{	
					_Destroy(this->_Myfirst(), this->_Mylast());
					this->_Getal().deallocate(this->_Myfirst(),
						this->_Myend() - this->_Myfirst());
					}
				if (_Buy(_Right.size()))
					try {
					this->_Mylast() =
						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
						this->_Myfirst());
					} catch (...) {
					_Tidy();
					throw;
					}
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (capacity() < _Count)
			{	
			if (max_size() < _Count)
				_Xlen();
			_Reallocate(_Count);
			}
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myend() - this->_Myfirst());
		}

	size_type _Unused_capacity() const noexcept
		{	
		return (this->_Myend() - this->_Mylast());
		}

	size_type _Has_unused_capacity() const noexcept
		{	
		return (this->_Myend() != this->_Mylast());
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myfirst(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Mylast(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Mylast(), &this->_Get_data()));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (_Has_unused_capacity())
			{	
			if (empty())
				_Tidy();
			else
				_Reallocate(size());
			}
		}

	void resize(size_type _Newsize)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			_Reserve(_Newsize - size());
			try {
			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
				this->_Getal());
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	void resize(size_type _Newsize, const value_type& _Val)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			const value_type *_Ptr = ::std:: addressof(_Val);

			if (_Inside(_Ptr))
				{	
				const difference_type _Idx = _Ptr
					- _Unfancy(this->_Myfirst());
				_Reserve(_Newsize - size());
				_Ptr = _Unfancy(this->_Myfirst()) + _Idx;
				}
			else
				_Reserve(_Newsize - size());

			try {
			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	size_type size() const noexcept
		{	
		return (this->_Mylast() - this->_Myfirst());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (this->_Myfirst() == this->_Mylast());
		}

	_Alloc get_allocator() const noexcept
		{	
		_Alloc _Ret(this->_Getal());
		return (_Ret);
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1218);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1219, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1219, 0); };
			}

 

#line 1225 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	reference operator[](size_type _Pos)
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1234);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1235, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1235, 0); };
			}

 

#line 1241 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	_Ty * data() noexcept
		{	
		return (_Unfancy(this->_Myfirst()));
		}

	const _Ty * data() const noexcept
		{	
		return (_Unfancy(this->_Myfirst()));
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const value_type& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				this->_Myfirst()[_Idx]);
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				_Val);
			++this->_Mylast();
			}
		}

 
	void pop_back()
		{	
		if (empty())
			_Debug_message(L"vector empty before pop", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1302);
		else
			{	
			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
			this->_Getal().destroy(_Unfancy(this->_Mylast() - 1));
			--this->_Mylast();
			}
		}

 





#line 1318 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		clear();
		_Assign(_First, _Last, _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		for (; _First != _Last; ++_First)
			emplace_back(*_First);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		size_type _Newsize = ::std:: distance(_First, _Last);

		if (capacity() < _Newsize)
			{	
			size_type _Newcapacity = _Grow_to(_Newsize);
			_Tidy();
			_Buy(_Newcapacity);
			}

		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
		}

	void assign(size_type _Count, const value_type& _Val)
		{	
		clear();
		insert(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const _Ty& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1388);
 #line 1390 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_First != _Last)
			{	
			size_type _Oldsize = size();

			try {
			for (; _First != _Last; ++_First)
				push_back(*_First);	

			} catch (...) {
			erase(begin() + _Oldsize, end());
			throw;
			}

			::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
			}
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				forward_iterator_tag)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1417);
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1418);
 #line 1420 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Count = ::std:: distance(_First, _Last);
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else
			{	
			_Ucopy(_First, _Last, this->_Mylast());
			::std:: rotate((_Where)._Ptr, this->_Mylast(),
				this->_Mylast() + _Count);
			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			}
		}

 
	iterator erase(const_iterator _Where)
		{	
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() <= (_Where)._Ptr)
			_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1474);
		_Move_unchecked((_Where)._Ptr + 1, this->_Mylast(), (_Where)._Ptr);
		_Destroy(this->_Mylast() - 1, this->_Mylast());
		_Orphan_range((_Where)._Ptr, this->_Mylast());
		--this->_Mylast();
		return (_Make_iter(_Where));
		}

 








#line 1492 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		if (_First_arg == begin() && _Last_arg == end())
			clear();
		else if (_First_arg != _Last_arg)
			{	
			iterator _First = _Make_iter(_First_arg);
			iterator _Last = _Make_iter(_Last_arg);

			if (_First != _Last)
				{	
 
				if (_Last < _First || _First._Getcont() != &this->_Get_data()
					|| (_First)._Ptr < this->_Myfirst()
					|| this->_Mylast() < (_Last)._Ptr)
					_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1509);
				pointer _Ptr = _Move_unchecked((_Last)._Ptr, this->_Mylast(),
					(_First)._Ptr);
				_Orphan_range((_First)._Ptr, this->_Mylast());

 


#line 1518 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

				_Destroy(_Ptr, this->_Mylast());
				this->_Mylast() = _Ptr;
				}
			}
		return (_Make_iter(_First_arg));
		}

	void _Pop_back_n(size_type _Count)
		{	
		pointer _Ptr = this->_Mylast() - _Count;

 
		_Orphan_range(_Ptr, this->_Mylast());
 #line 1533 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Destroy(_Ptr, this->_Mylast());
		this->_Mylast() = _Ptr;
		}

	void clear() noexcept
		{	
		this->_Orphan_all();
		_Destroy(this->_Myfirst(), this->_Mylast());
		this->_Mylast() = this->_Myfirst();
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1548 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}
		}

protected:
	bool _Buy(size_type _Capacity)
		{	
		this->_Myfirst() = pointer();
		this->_Mylast() = pointer();
		this->_Myend() = pointer();

		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			this->_Myfirst() = this->_Getal().allocate(_Capacity);
			this->_Mylast() = this->_Myfirst();
			this->_Myend() = this->_Myfirst() + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Destroy_range(_First, _Last, this->_Getal());
		}

	size_type _Grow_to(size_type _Count) const
		{	
		size_type _Capacity = capacity();

		_Capacity = max_size() - _Capacity / 2 < _Capacity
			? 0 : _Capacity + _Capacity / 2;	
		if (_Capacity < _Count)
			_Capacity = _Count;
		return (_Capacity);
		}

	bool _Inside(const value_type *_Ptr) const
		{	
		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
		}

	void _Reallocate(size_type _Count)
		{	
		pointer _Ptr = this->_Getal().allocate(_Count);

		try {
		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
		} catch (...) {
		this->_Getal().deallocate(_Ptr, _Count);
		throw;
		}

		size_type _Size = size();
		if (this->_Myfirst() != pointer())
			{	
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			}

		this->_Orphan_all();
		this->_Myend() = _Ptr + _Count;
		this->_Mylast() = _Ptr + _Size;
		this->_Myfirst() = _Ptr;
		}

	void _Reserve(size_type _Count)
		{	
		if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();
			_Reallocate(_Grow_to(size() + _Count));
			}
		}

	void _Tidy()
		{	
		if (this->_Myfirst() != pointer())
			{	
			this->_Orphan_all();
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			this->_Myfirst() = pointer();
			this->_Mylast() = pointer();
			this->_Myend() = pointer();
			}
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, this->_Getal()));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_move(_First, _Last,
			_Ptr, this->_Getal()));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const value_type& _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1670);
 #line 1672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			size_type _Whereoff = (_Where)._Ptr - this->_Myfirst();
			int _Ncopied = 0;

			try {
			_Ufill(_Newvec + _Whereoff, _Count,
				::std:: addressof(_Val));	
			++_Ncopied;
			_Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			++_Ncopied;
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Newvec + (_Whereoff + _Count));	
			} catch (...) {
			if (1 < _Ncopied)
				_Destroy(_Newvec, _Newvec + _Whereoff);
			if (0 < _Ncopied)
				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else if ((size_type)(this->_Mylast() - (_Where)._Ptr)
			< _Count)
			{	
			value_type _Tmp = _Val;	

			_Umove((_Where)._Ptr, this->_Mylast(),
				(_Where)._Ptr + _Count);	

			try {
			_Ufill(this->_Mylast(),
				_Count - (this->_Mylast() - (_Where)._Ptr),
				::std:: addressof(_Tmp));	
			} catch (...) {
			_Destroy((_Where)._Ptr + _Count,
				this->_Mylast() + _Count);
			throw;
			}

			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			::std:: fill((_Where)._Ptr, this->_Mylast() - _Count,
				_Tmp);	
			}
		else
			{	
			value_type _Tmp = _Val;	

			pointer _Oldend = this->_Mylast();
			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
				this->_Mylast());	

			_Orphan_range((_Where)._Ptr, this->_Mylast());
			_Move_backward_unchecked((_Where)._Ptr, _Oldend - _Count,
				_Oldend);	
			::std:: fill((_Where)._Ptr,
				(_Where)._Ptr + _Count, _Tmp);	
			}
		return (begin() + _Off);
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
		{	
		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
		return (_Ptr + _Count);
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("vector<T> too long");
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid vector<T> subscript");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			{	
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
			}
		}

 



#line 1796 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}




typedef unsigned int _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _Alloc>
	class _Vb_iter_base
		: public _Iterator012<random_access_iterator_tag,
			bool,
			typename _Alloc::difference_type,
			bool *,
			bool,
			_Iterator_base>
	{	
public:
	typedef typename _Alloc::size_type _Sizet;
	typedef vector<bool, _Alloc> _Mycont;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	
 
		const auto _Cont = static_cast<const _Mycont *>(this->_Getcont());
		_Sizet _Mysize = _Cont->_Mysize;

		_Inc += _Myoff;
		_Inc += _VBITS * (_Myptr - _Cont->_Myvec.data());
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 


#line 1911 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		
template<class _Alloc>
	class _Vb_reference
		: public _Vb_iter_base<_Alloc>
	{	
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_reference<_Alloc> _Mytype;

	_Vb_reference() noexcept
		{	
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	
		}

	_Mytype& operator=(const _Mytype& _Right) noexcept
		{	
		return (*this = bool(_Right));
		}

	_Mytype& operator=(bool _Val) noexcept
		{	
		if (_Val)
			*(_Vbase *)_Getptr() |= _Mask();
		else
			*(_Vbase *)_Getptr() &= (~_Mask());	
		return (*this);
		}

	void flip() noexcept
		{	
		*(_Vbase *)_Getptr() ^= _Mask();
		}

	operator bool() const noexcept
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Myptr == 0
			|| 0 <= this->_Valid(0))
			{	
			_Debug_message(L"vector<bool> iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1966);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1967, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1967, 0); };
			}

 


#line 1974 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1) << this->_Myoff);
		}
	};

template<class _Alloc> inline
	void swap(_Vb_reference<_Alloc> _Left,
		_Vb_reference<_Alloc> _Right)
	{	
	bool _Val = _Left;	
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _Alloc>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alloc>
	{	
public:
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_const_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Mytype& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	bool operator>(const _Mytype& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Mytype& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Mytype& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Mytype& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Debug_message(L"vector<bool> iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2140);
		}

 









#line 2154 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
				{	
				_Debug_message(L"vector<bool> iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2164);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2165, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2165, 0); };
				}

 


#line 2172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
				{	
				_Debug_message(L"vector<bool> iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2187);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2188, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2188, 0); };
				}

 


#line 2195 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alloc> inline
	_Vb_const_iterator<_Alloc> operator+(
		typename _Alloc::difference_type _Off,
		_Vb_const_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
		: public true_type
	{	
	};

	
template<class _Alloc>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alloc>
	{	
public:
	typedef _Vb_const_iterator<_Alloc> _Mybase;
	typedef _Vb_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Alloc> inline
	_Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
		_Vb_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_iterator<_Alloc> >
		: public true_type
	{	
	};

		
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	
public:
	typedef vector<_Vbase, _Alloc> _Vectype;
	typedef typename _Vectype::_Alty _Alty;
	typedef typename _Alty::size_type size_type;

	_Vb_val(size_type _Count, const bool& _Val)
		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, _Al),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() noexcept
		{	
		_Free_proxy();
		}

 








#line 2391 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec._Getal());
		this->_Myproxy = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec._Getal());
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(_Alproxy.address(*this->_Myproxy), 1);
		this->_Myproxy = 0;
		}
 #line 2410 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	
	typename _Alty::size_type _Mysize;	
	};

		

template<class _Alloc>
	class vector<bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	
public:
	typedef vector<bool, _Alloc> _Myt;
	typedef _Vb_val<_Alloc> _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Vectype _Vectype;

	typedef typename _Alty::size_type size_type;
	typedef typename _Alty::difference_type difference_type;
	typedef bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Alty> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Alty> const_iterator;
	typedef _Vb_iterator<_Alty> iterator;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	static const int _VBITS = ::std:: _VBITS;
	enum {_EEN_VBITS = _VBITS};	
	vector()
		: _Mybase(0, false)
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		}

	explicit vector(size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, false, _Al)
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, _Val, _Al)
		{	
		_Trim(_Count);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(0, false, _Al)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	
		insert(begin(), _First, _Last);
		}

	vector(_Myt&& _Right)
		: _Mybase(::std:: forward<_Myt>(_Right))
		{	
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(::std:: forward<_Myt>(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->get_allocator() != _Right.get_allocator())
				{	
				this->_Free_proxy();
				this->_Myvec = ::std:: move(_Right._Myvec);
				this->_Alloc_proxy();
				}
			else
				this->_Myvec = ::std:: move(_Right._Myvec);


			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;
			}
		return (*this);
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		push_back(_Tmp);
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		return (insert(_Where, _Tmp));
		}


	vector(::std:: initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			::std:: initializer_list<bool> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		this->_Mysize = _Right._Mysize;
		this->_Myvec = _Right._Myvec;
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myvec.capacity() * _VBITS);
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myvec.data(), this));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myvec.data(), this));
		}

	iterator end() noexcept
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator end() const noexcept
		{	
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (this->_Myvec._Has_unused_capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize);
		}

	size_type max_size() const noexcept
		{	
		const size_type _Maxsize = this->_Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const noexcept
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const noexcept
		{	
		_Alloc _Ret(this->_Myvec.get_allocator());
		return (_Ret);
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference operator[](size_type _Off)
		{	
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		erase(end() - 1);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const bool& _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const bool& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, (void)++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2816);
		size_type _Count = ::std:: distance(_First, _Last);
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: copy(_First, _Last, begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 
		if (end() <= _Where)
			_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2829);
		::std:: copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, this->_Mysize);

 

#line 2836 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	
 
			if (_Last < _First || end() < _Last)
				_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2852);
			iterator _Next = ::std:: copy(_Last, end(), _First);
			size_type _Newsize = _Next - begin();
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 


#line 2862 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (begin() + _Off);
		}

	void clear() noexcept
		{	
		erase(begin(), end());
		}

	void flip() noexcept
		{	
		for (typename _Vectype::iterator _Next = this->_Myvec.begin();
			_Next != this->_Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(this->_Mysize);
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}
		}

	static void swap(reference _Left, reference _Right) noexcept
		{	
		bool _Val = _Left;	

		_Left = _Right;
		_Right = _Val;
		}

	size_t hash() const
		{	
		return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
			this->_Myvec.size() * sizeof (_Vbase)));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 
		if (end() < _Where)
			_Debug_message(L"vector<bool> insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2917);
		bool _Realloc = capacity() - size() < _Count;
 #line 2920 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}

 
			_Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
 #line 2940 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (_Off);
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	
		typedef _Vb_iter_base<_Alty> _Myiterbase;

		_Lockit _Lock(3);
		auto _Base = const_cast<_Vbase *>(this->_Myvec.data());

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	
				size_type _Off = _VBITS * ((*_Pnext)->_Myptr - _Base)
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 



#line 2973 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("vector<bool> too long");
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc> inline
	bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc> inline
	bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

	
template<class _Alloc>
	struct hash<vector<bool, _Alloc> >
	{	
	typedef vector<bool, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Keyval.hash());
		}
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3034 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
#line 3035 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"






#line 6 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\buffers\\vertexarray.h"

namespace spork { namespace graphics {

	class vertexArray
	{
	private:
		GLuint m_ArrayID;
		std::vector<Buffer*> m_Buffers;
	public:
		vertexArray();
		~vertexArray();

		void addBuffer(Buffer* buffer, GLuint index);
		void bind() const;
		void unbind() const;
	};

}	}
#line 6 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\shader.h"
#pragma once




#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\utils\\fileutil.h"
#pragma once
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)
 #pragma warning(disable: 4455)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		

inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
 #pragma warning(push)
 #pragma warning(disable: 4127) 
template<class _Elem,
	class _UTy> inline
	_Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
	{	
	static_assert(is_unsigned<_UTy>::value, "_UTy must be unsigned");




	if (sizeof(_UTy) > 4)
		{	
		while (_UVal > 0xFFFFFFFFU)
			{
			auto _UVal_chunk = static_cast<_Uint32t>(_UVal % 1000000000);
			_UVal /= 1000000000;

			for (int _Idx = 0; _Idx != 9; ++_Idx)
				{
				*--_RNext = '0' + _UVal_chunk % 10;
				_UVal_chunk /= 10;
				}
			}
		}

	auto _UVal_trunc = static_cast<_Uint32t>(_UVal);
#line 513 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

	do
		{
		*--_RNext = '0' + _UVal_trunc % 10;
		_UVal_trunc /= 10;
		}
	while (_UVal_trunc != 0);
	return (_RNext);
	}
 #pragma warning(pop)

template<class _Elem,
	class _Ty> inline
	basic_string<_Elem> _Integral_to_string(const _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value, "_Ty must be integral");
	using _UTy = make_unsigned_t<_Ty>;
	_Elem _Buff[21]; 
	_Elem* const _Buff_end = ::std:: end(_Buff);
	_Elem* _RNext = _Buff_end;
	auto _UVal = static_cast<_UTy>(_Val);
	if (_Val < 0)
		{
		_RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
		*--_RNext = '-';
		}
	else
		_RNext = _UIntegral_to_buff(_RNext, _UVal);

	return (basic_string<_Elem>(_RNext, _Buff_end));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scprintf(_Fmt, _Val);
	string _Str(_Len + 1, '\0');
	:: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scwprintf(_Fmt, _Val);
	wstring _Str(_Len + 1, L'\0');
	:: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}



		
inline string to_string(int _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned int _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(long long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned long long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(float _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(double _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(long double _Val)
	{	
	return (_Floating_to_string("%Lf", _Val));
	}

		
inline wstring to_wstring(int _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(long long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned long long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(double _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(long double _Val)
	{	
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	





inline namespace literals {
inline namespace string_literals {
inline string operator "" s(const char *_Str, size_t _Len)
	{	
	return (string(_Str, _Len));
	}

inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	
	return (wstring(_Str, _Len));
	}

inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	
	return (u16string(_Str, _Len));
	}

inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	
	return (u32string(_Str, _Len));
	}
}	
}	





}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 705 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"
#line 706 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"





#line 3 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\utils\\fileutil.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const char *,
	ios_base::openmode, int);
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const wchar_t *,
	ios_base::openmode, int);

 
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const unsigned short *,
	ios_base::openmode, int);
 #line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fgetc(_Elem& _Ch, FILE *_File)
	{	
	return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
	}

template<> inline bool _Fgetc(char& _Byte, FILE *_File)
	{	
	int _Meta;
	if ((_Meta = fgetc(_File)) == (-1))
		return (false);
	else
		{	
		_Byte = (char)_Meta;
		return (true);
		}
	}

template<> inline bool _Fgetc(wchar_t& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (wchar_t)_Meta;
		return (true);
		}
	}

 
template<> inline bool _Fgetc(unsigned short& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (unsigned short)_Meta;
		return (true);
		}
	}
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fputc(_Elem _Ch, FILE *_File)
	{	
	return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
	}

template<> inline bool _Fputc(char _Byte, FILE *_File)
	{	
	return (fputc(_Byte, _File) != (-1));
	}

template<> inline bool _Fputc(wchar_t _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Fputc(unsigned short _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 97 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Ungetc(const _Elem& _Ch, FILE *_File)
	{	
	return (false);
	}

template<> inline bool _Ungetc(const char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const signed char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const unsigned char& _Byte, FILE *_File)
	{	
	return (ungetc(_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const wchar_t& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Ungetc(const unsigned short& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem,
	class _Traits>
	class basic_filebuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_filebuf<_Elem, _Traits> _Myt;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef typename _Traits::state_type _Myst;
	typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;

	basic_filebuf(FILE *_File = 0)
		: _Mysb()
		{	
		_Init(_File, _Newfl);
		}

	virtual  ~basic_filebuf() noexcept
		{	
		if (_Myfile != 0)
			_Reset_back();	
		if (_Closef)
			close();
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_filebuf(_Uninitialized)
		: _Mysb(_Noinit)
		{	
		}

	basic_filebuf(_Myt&& _Right)
		{	
		_Init(_Right._Myfile, _Newfl);	
		_Init((FILE *)0, _Closefl);	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			
			FILE *_Myfile_sav = _Myfile;
			const _Cvt *_Pcvt_sav = _Pcvt;
			typename _Traits::state_type _State_sav = _State;
			bool _Wrotesome_sav = _Wrotesome;
			bool _Closef_sav = _Closef;
			bool _Set_eback_sav = _Mysb::eback() == &_Mychar;
			bool _Set_eback_live = _Mysb::gptr() == &_Mychar;

			_Elem *_Pfirst0 = _Mysb::pbase();
			_Elem *_Pnext0 = _Mysb::pptr();
			_Elem *_Pend = _Mysb::epptr();
			_Elem *_Gfirst0 = _Mysb::eback();
			_Elem *_Gnext0 = _Mysb::gptr();
			_Elem *_Gend = _Mysb::egptr();

			
			_Init(_Right._Myfile, _Right._Myfile != 0 ? _Openfl : _Newfl);
			_Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			if (_Right.eback() != &_Right._Mychar)
				_Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			else if (_Right.gptr() != &_Right._Mychar)
				_Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
			else
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

			_Pcvt = _Right._Pcvt;
			_State = _Right._State;
			_Wrotesome = _Right._Wrotesome;
			_Closef = _Right._Closef;

			
			_Right._Init(_Myfile_sav, _Myfile_sav != 0 ? _Openfl : _Newfl);
			_Right.setp(_Pfirst0, _Pnext0, _Pend);
			if (!_Set_eback_sav)
				_Right.setg(_Gfirst0, _Gnext0, _Gend);
			else if (!_Set_eback_live)
				_Right.setg(&_Right._Mychar, &_Right._Mychar + 1,
					&_Right._Mychar + 1);
			else
				_Right.setg(&_Right._Mychar, &_Right._Mychar,
					&_Right._Mychar + 1);

			_Right._Pcvt = _Pcvt_sav;
			_Right._State = _State_sav;
			_Right._Wrotesome = _Wrotesome_sav;
			_Right._Closef = _Closef_sav;

			
			::std:: swap(_Set_eback, _Right._Set_eback);
			::std:: swap(_Set_egptr, _Right._Set_egptr);

			::std:: swap(_Mychar, _Right._Mychar);
			::std:: swap(_Mysb::_Plocale, _Right._Plocale);
			}
		}

	basic_filebuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	enum _Initfl
		{	
		_Newfl, _Openfl, _Closefl};

	bool is_open() const
		{	
		return (_Myfile != 0);
		}

	_Myt *open(const char *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const string& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

 
	_Myt *open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 288 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	_Myt *open(const wchar_t *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const wstring& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

 
	_Myt *open(const wchar_t *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 338 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 339 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	_Myt *close()
		{	
		_Myt *_Ans = this;
		if (_Myfile == 0)
			_Ans = 0;
		else
			{	
			if (!_Endwrite())
				_Ans = 0;
			if (fclose(_Myfile) != 0)
				_Ans = 0;
			}
		_Init(0, _Closefl);
		return (_Ans);
		}

	virtual void  _Lock()
		{	
		if (_Myfile)
			:: _lock_file(_Myfile);
		}

	virtual void  _Unlock()
		{	
		if (_Myfile)
			:: _unlock_file(_Myfile);
		}

protected:
	virtual int_type  overflow(int_type _Meta =
		_Traits::eof())
		{	
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	
		else if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
				? _Meta : _Traits::eof());	
		else
			{	
			const int _STRING_INC = 8;
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (_Traits::eof());	

					_Wrotesome = true;	
					if (_Src != &_Ch)
						return (_Meta);	

					if (0 < _Count)
						;
					else if (_Str.size() < 4 * _STRING_INC)
						_Str.append(_STRING_INC, '\0');	
					else
						return (_Traits::eof());	
					break;
					}

				case codecvt_base::noconv:
					return (_Fputc(_Ch, _Myfile) ? _Meta
						: _Traits::eof());	

				default:
					return (_Traits::eof());	
				}
			}
	}

	virtual int_type  pbackfail(int_type _Meta =
		_Traits::eof())
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::eback() < _Mysb::gptr()
			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
				_Meta)))
			{	
			_Mysb::_Gndec();
			return (_Traits::not_eof(_Meta));
			}
		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::eof());	
		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
			return (_Meta);	
		else if (_Mysb::gptr() != &_Mychar)
			{	
			_Mychar = _Traits::to_char_type(_Meta);
			_Set_back();	
			return (_Meta);
			}
		else
			return (_Traits::eof());	
	}

	virtual int_type  underflow()
		{	
		int_type _Meta;
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
			return (_Meta);	
		else
			{	
			pbackfail(_Meta);
			return (_Meta);
			}
		}

	virtual int_type  uflow()
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(
				*_Mysb::_Gninc()));	
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			{	
			_Elem _Ch = 0;
			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
				: _Traits::eof());
			}
		else
			{	
			string _Str;

			for (; ; )
				{	
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Nleft;
				int _Meta = fgetc(_Myfile);

				if (_Meta == (-1))
					return (_Traits::eof());	

				_Str.append(1, (char)_Meta);	
				switch (_Pcvt->in(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					if (_Dest != &_Ch)
						{	
						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
						for (; 0 < _Nleft; )
							ungetc(_Src[--_Nleft], _Myfile);
						return (_Traits::to_int_type(_Ch));
						}
					else
						_Str.erase((size_t)0,	
							(size_t)(_Src - &*_Str.begin()));
					break;

				case codecvt_base::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	

					::memcpy_s((&_Ch), (sizeof (_Elem)), (&*_Str.begin()), (sizeof (_Elem)));	
#line 525 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

					return (_Traits::to_int_type(_Ch));	

				default:
					return (_Traits::eof());	
					}
				}
			}
		}

	virtual pos_type  seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition;

		if (_Mysb::gptr() == &_Mychar	
			&& _Way == ios_base::cur	
			&& _Pcvt == 0)	
			_Off -= (off_type)sizeof (_Elem);	

		if (_Myfile == 0 || !_Endwrite()
			|| ((_Off != 0 || _Way != ios_base::cur)
				&& _fseeki64(_Myfile, _Off, _Way) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 556 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
		}

	virtual pos_type  seekpos(pos_type _Pos,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition = _Pos.seekpos();
		off_type _Off = (off_type)_Pos - (off_type)((long long)(_Fileposition));

		if (_Myfile == 0 || !_Endwrite()
			|| fsetpos(_Myfile, &_Fileposition) != 0
			|| (_Off != 0 && _fseeki64(_Myfile, _Off, 1) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_State = _Pos.state();

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 576 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
		}

	virtual _Mysb * setbuf(_Elem *_Buffer, streamsize _Count)
		{	
		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
			_Buffer == 0 && _Count == 0 ? 0x0004 : 0x0000,
			(size_t)_Count * sizeof (_Elem)) != 0)
			return (0);	
		else
			{	
			_Init(_Myfile, _Openfl);
			return (this);
			}
		}

	virtual int  sync()
		{	
		return (_Myfile == 0
			|| _Traits::eq_int_type(_Traits::eof(), overflow())
			|| 0 <= fflush(_Myfile) ? 0 : -1);
		}

	virtual void  imbue(const locale& _Loc)
		{	
		_Initcvt(&use_facet< _Cvt >(_Loc));
		}

	void _Init(FILE *_File, _Initfl _Which)
		{	
		 static _Myst _Stinit;	

		_Closef = _Which == _Openfl;
		_Wrotesome = false;

		_Mysb::_Init();	

 
  
  
 #line 616 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

  #pragma warning(push)
  #pragma warning(disable: 6240)	
		if (_File != 0 && sizeof (_Elem) == 1)
  #pragma warning(pop)

			{	
			_Elem **_Pb = 0;
			_Elem **_Pn = 0;
			int *_Nr = 0;

			::_get_stream_buffer_pointers(
				_File,
				reinterpret_cast<char***>(&_Pb),
				reinterpret_cast<char***>(&_Pn),
				&_Nr);
			int *_Nw = _Nr;

			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}

		_Myfile = _File;
		_State = _Stinit;
		_Pcvt = 0;	
		}

	bool _Endwrite()
		{	
		if (_Pcvt == 0 || !_Wrotesome)
			return (true);
		else
			{	
			const int _STRING_INC = 8;
			char *_Dest;
			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
				return (false);

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->unshift(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::ok:
					_Wrotesome = false;	

				case codecvt_base::partial:	
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (false);	
					if (!_Wrotesome)
						return (true);
					if (_Count == 0)
						_Str.append(_STRING_INC, '\0');	
					break;
					}

				case codecvt_base::noconv:
					return (true);	

				default:
					return (false);	
				}
			}
		}

	void _Initcvt(const _Cvt *_Newpcvt)
		{	
		if (_Newpcvt->always_noconv())
			_Pcvt = 0;	
		else
			{	
			_Pcvt = _Newpcvt;
			_Mysb::_Init();	
			}
		}

private:
	const _Cvt *_Pcvt;	
	_Elem _Mychar;	
	bool _Wrotesome;	
	typename _Traits::state_type _State;	
	bool _Closef;	
	FILE *_Myfile;	

	void _Reset_back()
		{	
		if (_Mysb::eback() == &_Mychar)
			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
		}

	void _Set_back()
		{	
		if (_Mysb::eback() != &_Mychar)
			{	
			_Set_eback = _Mysb::eback();
			_Set_egptr = _Mysb::egptr();
			}
		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
		}

	_Elem *_Set_eback;	
	_Elem *_Set_egptr;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_filebuf<_Elem, _Traits>& _Left,
		basic_filebuf<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ifstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_ifstream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ifstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ifstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ifstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 794 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_ifstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ifstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ifstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 857 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 876 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 877 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_ifstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 915 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ifstream<_Elem, _Traits>& _Left,
		basic_ifstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ofstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ofstream<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ofstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ofstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ofstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 998 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_ofstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ofstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ofstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1061 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1080 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 1081 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_ofstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ofstream<_Elem, _Traits>& _Left,
		basic_ofstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_fstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_fstream<_Elem, _Traits> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_fstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_fstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_fstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 1207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_fstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_fstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_fstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1289 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 1290 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_fstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1328 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
	}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_fstream<_Elem, _Traits>& _Left,
		basic_fstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1353 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
#line 1354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"






#line 4 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\utils\\fileutil.h"

namespace spork {

	class FileUtil
	{
	public:
		static std::string read_file(const char* filepath)
		{
			FILE* file = fopen(filepath, "rt");
			fseek(file, 0, 2);
			unsigned long length = ftell(file); 
			char* data = new char[length + 1];	
			memset(data, 0, length + 1);
			fseek(file, 0, 0);	
			fread(data, 1, length, file);	
			fclose(file);	

			std::string result(data);
			delete[] data;
			return result;
		}
	};
}
#line 7 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\shader.h"


namespace spork { namespace graphics {

	using namespace maths;
	class Shader
	{
	private:
		GLuint m_ShaderID;
		const char* m_VertPath;
		const char* m_FragPath;
	public:
		Shader(const char* vertPath, const char* fragPath);
		~Shader();


		void setUniform1f(const GLchar* name, float value);
		void setUniform1i(const GLchar* name, int value);
		void setUniform1iv(const GLchar* name, int* value, int count);
		void setUniform2f(const GLchar* name, const maths::vec2& vector);
		void setUniform1fv(const GLchar* name, float* value, int count);
		void setUniform3f(const GLchar* name, const maths::vec3& vector);
		void setUniform4f(const GLchar* name, const maths::vec4& vector);
		void setUniformMat4(const GLchar* name, const mat4& matrix);
		
		void enable() const;
		void disable() const;
	private:
		GLuint load();
		GLint getUniformLoc(const GLchar* name);
	};

}	}
#line 7 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\texture.h"
#pragma once


#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\utils\\imageloader.h"
#pragma once
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"









































#line 43 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
	
		
		
		
		
		
		
		
		


			
		#line 56 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
	












#line 70 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
#line 71 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"







	

#line 81 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
#line 82 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"














	

#line 99 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
		
	#line 101 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
#line 102 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"




#line 107 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"











#line 119 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"



struct FIBITMAP { void *data; };
struct FIMULTIBITMAP { void *data; };





#line 130 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"






#line 137 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"


#line 140 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"






















typedef long BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef long LONG;
typedef signed __int64 INT64;
typedef unsigned __int64 UINT64;
#line 170 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"


#pragma pack(push, 1)


#line 176 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

typedef struct tagRGBQUAD {

  BYTE rgbBlue;
  BYTE rgbGreen;
  BYTE rgbRed;




#line 187 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
  BYTE rgbReserved;
} RGBQUAD;

typedef struct tagRGBTRIPLE {

  BYTE rgbtBlue;
  BYTE rgbtGreen;
  BYTE rgbtRed;




#line 200 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"
} RGBTRIPLE;


#pragma pack(pop)


#line 207 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

typedef struct tagBITMAPINFOHEADER{
  DWORD biSize;
  LONG  biWidth; 
  LONG  biHeight; 
  WORD  biPlanes; 
  WORD  biBitCount;
  DWORD biCompression; 
  DWORD biSizeImage; 
  LONG  biXPelsPerMeter; 
  LONG  biYPelsPerMeter; 
  DWORD biClrUsed; 
  DWORD biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER; 

typedef struct tagBITMAPINFO { 
  BITMAPINFOHEADER bmiHeader; 
  RGBQUAD          bmiColors[1];
} BITMAPINFO, *PBITMAPINFO;

#line 228 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"




#pragma pack(push, 1)


#line 236 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"



typedef struct tagFIRGB16 {
	WORD red;
	WORD green;
	WORD blue;
} FIRGB16;



typedef struct tagFIRGBA16 {
	WORD red;
	WORD green;
	WORD blue;
	WORD alpha;
} FIRGBA16;



typedef struct tagFIRGBF {
	float red;
	float green;
	float blue;
} FIRGBF;



typedef struct tagFIRGBAF {
	float red;
	float green;
	float blue;
	float alpha;
} FIRGBAF;



typedef struct tagFICOMPLEX {
    
	double r;
	
    double i;
} FICOMPLEX;


#pragma pack(pop)


#line 285 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

































#line 319 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"






























#line 350 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"























struct FIICCPROFILE { 
	WORD    flags;	
	DWORD	size;	
	void   *data;	
};





enum FREE_IMAGE_FORMAT {
	FIF_UNKNOWN = -1,
	FIF_BMP		= 0,
	FIF_ICO		= 1,
	FIF_JPEG	= 2,
	FIF_JNG		= 3,
	FIF_KOALA	= 4,
	FIF_LBM		= 5,
	FIF_IFF = FIF_LBM,
	FIF_MNG		= 6,
	FIF_PBM		= 7,
	FIF_PBMRAW	= 8,
	FIF_PCD		= 9,
	FIF_PCX		= 10,
	FIF_PGM		= 11,
	FIF_PGMRAW	= 12,
	FIF_PNG		= 13,
	FIF_PPM		= 14,
	FIF_PPMRAW	= 15,
	FIF_RAS		= 16,
	FIF_TARGA	= 17,
	FIF_TIFF	= 18,
	FIF_WBMP	= 19,
	FIF_PSD		= 20,
	FIF_CUT		= 21,
	FIF_XBM		= 22,
	FIF_XPM		= 23,
	FIF_DDS		= 24,
	FIF_GIF     = 25,
	FIF_HDR		= 26,
	FIF_FAXG3	= 27,
	FIF_SGI		= 28,
	FIF_EXR		= 29,
	FIF_J2K		= 30,
	FIF_JP2		= 31,
	FIF_PFM		= 32,
	FIF_PICT	= 33,
	FIF_RAW		= 34,
	FIF_WEBP	= 35,
	FIF_JXR		= 36
};



enum FREE_IMAGE_TYPE {
	FIT_UNKNOWN = 0,	
	FIT_BITMAP  = 1,	
	FIT_UINT16	= 2,	
	FIT_INT16	= 3,	
	FIT_UINT32	= 4,	
	FIT_INT32	= 5,	
	FIT_FLOAT	= 6,	
	FIT_DOUBLE	= 7,	
	FIT_COMPLEX	= 8,	
	FIT_RGB16	= 9,	
	FIT_RGBA16	= 10,	
	FIT_RGBF	= 11,	
	FIT_RGBAF	= 12	
};



enum FREE_IMAGE_COLOR_TYPE {
	FIC_MINISWHITE = 0,		
    FIC_MINISBLACK = 1,		
    FIC_RGB        = 2,		
    FIC_PALETTE    = 3,		
	FIC_RGBALPHA   = 4,		
	FIC_CMYK       = 5		
};




enum FREE_IMAGE_QUANTIZE {
    FIQ_WUQUANT = 0,		
    FIQ_NNQUANT = 1,		
	FIQ_LFPQUANT = 2		
};




enum FREE_IMAGE_DITHER {
    FID_FS			= 0,	
	FID_BAYER4x4	= 1,	
	FID_BAYER8x8	= 2,	
	FID_CLUSTER6x6	= 3,	
	FID_CLUSTER8x8	= 4,	
	FID_CLUSTER16x16= 5,	
	FID_BAYER16x16	= 6		
};




enum FREE_IMAGE_JPEG_OPERATION {
	FIJPEG_OP_NONE			= 0,	
	FIJPEG_OP_FLIP_H		= 1,	
	FIJPEG_OP_FLIP_V		= 2,	
	FIJPEG_OP_TRANSPOSE		= 3,	
	FIJPEG_OP_TRANSVERSE	= 4,	
	FIJPEG_OP_ROTATE_90		= 5,	
	FIJPEG_OP_ROTATE_180	= 6,	
	FIJPEG_OP_ROTATE_270	= 7		
};




enum FREE_IMAGE_TMO {
    FITMO_DRAGO03	 = 0,	
	FITMO_REINHARD05 = 1,	
	FITMO_FATTAL02	 = 2	
};




enum FREE_IMAGE_FILTER {
	FILTER_BOX		  = 0,	
	FILTER_BICUBIC	  = 1,	
	FILTER_BILINEAR   = 2,	
	FILTER_BSPLINE	  = 3,	
	FILTER_CATMULLROM = 4,	
	FILTER_LANCZOS3	  = 5	
};




enum FREE_IMAGE_COLOR_CHANNEL {
	FICC_RGB	= 0,	
	FICC_RED	= 1,	
	FICC_GREEN	= 2,	
	FICC_BLUE	= 3,	
	FICC_ALPHA	= 4,	
	FICC_BLACK	= 5,	
	FICC_REAL	= 6,	
	FICC_IMAG	= 7,	
	FICC_MAG	= 8,	
	FICC_PHASE	= 9		
};








enum FREE_IMAGE_MDTYPE {
	FIDT_NOTYPE		= 0,	
	FIDT_BYTE		= 1,	
	FIDT_ASCII		= 2,	
	FIDT_SHORT		= 3,	
	FIDT_LONG		= 4,	
	FIDT_RATIONAL	= 5,	
	FIDT_SBYTE		= 6,	
	FIDT_UNDEFINED	= 7,	
	FIDT_SSHORT		= 8,	
	FIDT_SLONG		= 9,	
	FIDT_SRATIONAL	= 10,	
	FIDT_FLOAT		= 11,	
	FIDT_DOUBLE		= 12,	
	FIDT_IFD		= 13,	
	FIDT_PALETTE	= 14,	
	FIDT_LONG8		= 16,	
	FIDT_SLONG8		= 17,	
	FIDT_IFD8		= 18	
};




enum FREE_IMAGE_MDMODEL {
	FIMD_NODATA			= -1,
	FIMD_COMMENTS		= 0,	
	FIMD_EXIF_MAIN		= 1,	
	FIMD_EXIF_EXIF		= 2,	
	FIMD_EXIF_GPS		= 3,	
	FIMD_EXIF_MAKERNOTE = 4,	
	FIMD_EXIF_INTEROP	= 5,	
	FIMD_IPTC			= 6,	
	FIMD_XMP			= 7,	
	FIMD_GEOTIFF		= 8,	
	FIMD_ANIMATION		= 9,	
	FIMD_CUSTOM			= 10,	
	FIMD_EXIF_RAW		= 11	
};




struct FIMETADATA { void *data; };




struct FITAG { void *data; };






typedef void* fi_handle;
typedef unsigned (__stdcall *FI_ReadProc) (void *buffer, unsigned size, unsigned count, fi_handle handle);
typedef unsigned (__stdcall *FI_WriteProc) (void *buffer, unsigned size, unsigned count, fi_handle handle);
typedef int (__stdcall *FI_SeekProc) (fi_handle handle, long offset, int origin);
typedef long (__stdcall *FI_TellProc) (fi_handle handle);


#pragma pack(push, 1)


#line 600 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

struct FreeImageIO {
	FI_ReadProc  read_proc;     
    FI_WriteProc write_proc;    
    FI_SeekProc  seek_proc;     
    FI_TellProc  tell_proc;     
};


#pragma pack(pop)


#line 613 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"




struct FIMEMORY { void *data; };

#line 620 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"






typedef const char *(__stdcall *FI_FormatProc)(void);
typedef const char *(__stdcall *FI_DescriptionProc)(void);
typedef const char *(__stdcall *FI_ExtensionListProc)(void);
typedef const char *(__stdcall *FI_RegExprProc)(void);
typedef void *(__stdcall *FI_OpenProc)(FreeImageIO *io, fi_handle handle, BOOL read);
typedef void (__stdcall *FI_CloseProc)(FreeImageIO *io, fi_handle handle, void *data);
typedef int (__stdcall *FI_PageCountProc)(FreeImageIO *io, fi_handle handle, void *data);
typedef int (__stdcall *FI_PageCapabilityProc)(FreeImageIO *io, fi_handle handle, void *data);
typedef FIBITMAP *(__stdcall *FI_LoadProc)(FreeImageIO *io, fi_handle handle, int page, int flags, void *data);
typedef BOOL (__stdcall *FI_SaveProc)(FreeImageIO *io, FIBITMAP *dib, fi_handle handle, int page, int flags, void *data);
typedef BOOL (__stdcall *FI_ValidateProc)(FreeImageIO *io, fi_handle handle);
typedef const char *(__stdcall *FI_MimeProc)(void);
typedef BOOL (__stdcall *FI_SupportsExportBPPProc)(int bpp);
typedef BOOL (__stdcall *FI_SupportsExportTypeProc)(FREE_IMAGE_TYPE type);
typedef BOOL (__stdcall *FI_SupportsICCProfilesProc)(void);
typedef BOOL (__stdcall *FI_SupportsNoPixelsProc)(void);

struct Plugin {
	FI_FormatProc format_proc;
	FI_DescriptionProc description_proc;
	FI_ExtensionListProc extension_proc;
	FI_RegExprProc regexpr_proc;
	FI_OpenProc open_proc;
	FI_CloseProc close_proc;
	FI_PageCountProc pagecount_proc;
	FI_PageCapabilityProc pagecapability_proc;
	FI_LoadProc load_proc;
	FI_SaveProc save_proc;
	FI_ValidateProc validate_proc;
	FI_MimeProc mime_proc;
	FI_SupportsExportBPPProc supports_export_bpp_proc;
	FI_SupportsExportTypeProc supports_export_type_proc;
	FI_SupportsICCProfilesProc supports_icc_profiles_proc;
	FI_SupportsNoPixelsProc supports_no_pixels_proc;
};

typedef void (__stdcall *FI_InitProc)(Plugin *plugin, int format_id);

#line 665 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"





















































































































extern "C" {
#line 784 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"



__declspec(dllimport) void __stdcall FreeImage_Initialise(BOOL load_local_plugins_only = 0);
__declspec(dllimport) void __stdcall FreeImage_DeInitialise(void);



__declspec(dllimport) const char *__stdcall FreeImage_GetVersion(void);
__declspec(dllimport) const char *__stdcall FreeImage_GetCopyrightMessage(void);



typedef void (*FreeImage_OutputMessageFunction)(FREE_IMAGE_FORMAT fif, const char *msg);
typedef void (__stdcall *FreeImage_OutputMessageFunctionStdCall)(FREE_IMAGE_FORMAT fif, const char *msg); 

__declspec(dllimport) void __stdcall FreeImage_SetOutputMessageStdCall(FreeImage_OutputMessageFunctionStdCall omf); 
__declspec(dllimport) void __stdcall FreeImage_SetOutputMessage(FreeImage_OutputMessageFunction omf);
__declspec(dllimport) void __stdcall FreeImage_OutputMessageProc(int fif, const char *fmt, ...);



__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Allocate(int width, int height, int bpp, unsigned red_mask = 0, unsigned green_mask = 0, unsigned blue_mask = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_AllocateT(FREE_IMAGE_TYPE type, int width, int height, int bpp = 8, unsigned red_mask = 0, unsigned green_mask = 0, unsigned blue_mask = 0);
__declspec(dllimport) FIBITMAP * __stdcall FreeImage_Clone(FIBITMAP *dib);
__declspec(dllimport) void __stdcall FreeImage_Unload(FIBITMAP *dib);


__declspec(dllimport) BOOL __stdcall FreeImage_HasPixels(FIBITMAP *dib);



__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Load(FREE_IMAGE_FORMAT fif, const char *filename, int flags = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_LoadU(FREE_IMAGE_FORMAT fif, const wchar_t *filename, int flags = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_LoadFromHandle(FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_Save(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, const char *filename, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_SaveU(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, const wchar_t *filename, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_SaveToHandle(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, FreeImageIO *io, fi_handle handle, int flags = 0);



__declspec(dllimport) FIMEMORY *__stdcall FreeImage_OpenMemory(BYTE *data = 0, DWORD size_in_bytes = 0);
__declspec(dllimport) void __stdcall FreeImage_CloseMemory(FIMEMORY *stream);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_LoadFromMemory(FREE_IMAGE_FORMAT fif, FIMEMORY *stream, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_SaveToMemory(FREE_IMAGE_FORMAT fif, FIBITMAP *dib, FIMEMORY *stream, int flags = 0);
__declspec(dllimport) long __stdcall FreeImage_TellMemory(FIMEMORY *stream);
__declspec(dllimport) BOOL __stdcall FreeImage_SeekMemory(FIMEMORY *stream, long offset, int origin);
__declspec(dllimport) BOOL __stdcall FreeImage_AcquireMemory(FIMEMORY *stream, BYTE **data, DWORD *size_in_bytes);
__declspec(dllimport) unsigned __stdcall FreeImage_ReadMemory(void *buffer, unsigned size, unsigned count, FIMEMORY *stream);
__declspec(dllimport) unsigned __stdcall FreeImage_WriteMemory(const void *buffer, unsigned size, unsigned count, FIMEMORY *stream);

__declspec(dllimport) FIMULTIBITMAP *__stdcall FreeImage_LoadMultiBitmapFromMemory(FREE_IMAGE_FORMAT fif, FIMEMORY *stream, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_SaveMultiBitmapToMemory(FREE_IMAGE_FORMAT fif, FIMULTIBITMAP *bitmap, FIMEMORY *stream, int flags);



__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_RegisterLocalPlugin(FI_InitProc proc_address, const char *format = 0, const char *description = 0, const char *extension = 0, const char *regexpr = 0);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_RegisterExternalPlugin(const char *path, const char *format = 0, const char *description = 0, const char *extension = 0, const char *regexpr = 0);
__declspec(dllimport) int __stdcall FreeImage_GetFIFCount(void);
__declspec(dllimport) int __stdcall FreeImage_SetPluginEnabled(FREE_IMAGE_FORMAT fif, BOOL enable);
__declspec(dllimport) int __stdcall FreeImage_IsPluginEnabled(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFIFFromFormat(const char *format);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFIFFromMime(const char *mime);
__declspec(dllimport) const char *__stdcall FreeImage_GetFormatFromFIF(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) const char *__stdcall FreeImage_GetFIFExtensionList(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) const char *__stdcall FreeImage_GetFIFDescription(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) const char *__stdcall FreeImage_GetFIFRegExpr(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) const char *__stdcall FreeImage_GetFIFMimeType(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFIFFromFilename(const char *filename);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFIFFromFilenameU(const wchar_t *filename);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsReading(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsWriting(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsExportBPP(FREE_IMAGE_FORMAT fif, int bpp);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsExportType(FREE_IMAGE_FORMAT fif, FREE_IMAGE_TYPE type);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsICCProfiles(FREE_IMAGE_FORMAT fif);
__declspec(dllimport) BOOL __stdcall FreeImage_FIFSupportsNoPixels(FREE_IMAGE_FORMAT fif);



__declspec(dllimport) FIMULTIBITMAP * __stdcall FreeImage_OpenMultiBitmap(FREE_IMAGE_FORMAT fif, const char *filename, BOOL create_new, BOOL read_only, BOOL keep_cache_in_memory = 0, int flags = 0);
__declspec(dllimport) FIMULTIBITMAP * __stdcall FreeImage_OpenMultiBitmapFromHandle(FREE_IMAGE_FORMAT fif, FreeImageIO *io, fi_handle handle, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_SaveMultiBitmapToHandle(FREE_IMAGE_FORMAT fif, FIMULTIBITMAP *bitmap, FreeImageIO *io, fi_handle handle, int flags = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_CloseMultiBitmap(FIMULTIBITMAP *bitmap, int flags = 0);
__declspec(dllimport) int __stdcall FreeImage_GetPageCount(FIMULTIBITMAP *bitmap);
__declspec(dllimport) void __stdcall FreeImage_AppendPage(FIMULTIBITMAP *bitmap, FIBITMAP *data);
__declspec(dllimport) void __stdcall FreeImage_InsertPage(FIMULTIBITMAP *bitmap, int page, FIBITMAP *data);
__declspec(dllimport) void __stdcall FreeImage_DeletePage(FIMULTIBITMAP *bitmap, int page);
__declspec(dllimport) FIBITMAP * __stdcall FreeImage_LockPage(FIMULTIBITMAP *bitmap, int page);
__declspec(dllimport) void __stdcall FreeImage_UnlockPage(FIMULTIBITMAP *bitmap, FIBITMAP *data, BOOL changed);
__declspec(dllimport) BOOL __stdcall FreeImage_MovePage(FIMULTIBITMAP *bitmap, int target, int source);
__declspec(dllimport) BOOL __stdcall FreeImage_GetLockedPageNumbers(FIMULTIBITMAP *bitmap, int *pages, int *count);



__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFileType(const char *filename, int size = 0);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFileTypeU(const wchar_t *filename, int size = 0);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFileTypeFromHandle(FreeImageIO *io, fi_handle handle, int size = 0);
__declspec(dllimport) FREE_IMAGE_FORMAT __stdcall FreeImage_GetFileTypeFromMemory(FIMEMORY *stream, int size = 0);



__declspec(dllimport) FREE_IMAGE_TYPE __stdcall FreeImage_GetImageType(FIBITMAP *dib);



__declspec(dllimport) BOOL __stdcall FreeImage_IsLittleEndian(void);
__declspec(dllimport) BOOL __stdcall FreeImage_LookupX11Color(const char *szColor, BYTE *nRed, BYTE *nGreen, BYTE *nBlue);
__declspec(dllimport) BOOL __stdcall FreeImage_LookupSVGColor(const char *szColor, BYTE *nRed, BYTE *nGreen, BYTE *nBlue);



__declspec(dllimport) BYTE *__stdcall FreeImage_GetBits(FIBITMAP *dib);
__declspec(dllimport) BYTE *__stdcall FreeImage_GetScanLine(FIBITMAP *dib, int scanline);

__declspec(dllimport) BOOL __stdcall FreeImage_GetPixelIndex(FIBITMAP *dib, unsigned x, unsigned y, BYTE *value);
__declspec(dllimport) BOOL __stdcall FreeImage_GetPixelColor(FIBITMAP *dib, unsigned x, unsigned y, RGBQUAD *value);
__declspec(dllimport) BOOL __stdcall FreeImage_SetPixelIndex(FIBITMAP *dib, unsigned x, unsigned y, BYTE *value);
__declspec(dllimport) BOOL __stdcall FreeImage_SetPixelColor(FIBITMAP *dib, unsigned x, unsigned y, RGBQUAD *value);



__declspec(dllimport) unsigned __stdcall FreeImage_GetColorsUsed(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetBPP(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetWidth(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetHeight(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetLine(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetPitch(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetDIBSize(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetMemorySize(FIBITMAP *dib);
__declspec(dllimport) RGBQUAD *__stdcall FreeImage_GetPalette(FIBITMAP *dib);

__declspec(dllimport) unsigned __stdcall FreeImage_GetDotsPerMeterX(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetDotsPerMeterY(FIBITMAP *dib);
__declspec(dllimport) void __stdcall FreeImage_SetDotsPerMeterX(FIBITMAP *dib, unsigned res);
__declspec(dllimport) void __stdcall FreeImage_SetDotsPerMeterY(FIBITMAP *dib, unsigned res);

__declspec(dllimport) BITMAPINFOHEADER *__stdcall FreeImage_GetInfoHeader(FIBITMAP *dib);
__declspec(dllimport) BITMAPINFO *__stdcall FreeImage_GetInfo(FIBITMAP *dib);
__declspec(dllimport) FREE_IMAGE_COLOR_TYPE __stdcall FreeImage_GetColorType(FIBITMAP *dib);

__declspec(dllimport) unsigned __stdcall FreeImage_GetRedMask(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetGreenMask(FIBITMAP *dib);
__declspec(dllimport) unsigned __stdcall FreeImage_GetBlueMask(FIBITMAP *dib);

__declspec(dllimport) unsigned __stdcall FreeImage_GetTransparencyCount(FIBITMAP *dib);
__declspec(dllimport) BYTE * __stdcall FreeImage_GetTransparencyTable(FIBITMAP *dib);
__declspec(dllimport) void __stdcall FreeImage_SetTransparent(FIBITMAP *dib, BOOL enabled);
__declspec(dllimport) void __stdcall FreeImage_SetTransparencyTable(FIBITMAP *dib, BYTE *table, int count);
__declspec(dllimport) BOOL __stdcall FreeImage_IsTransparent(FIBITMAP *dib);
__declspec(dllimport) void __stdcall FreeImage_SetTransparentIndex(FIBITMAP *dib, int index);
__declspec(dllimport) int __stdcall FreeImage_GetTransparentIndex(FIBITMAP *dib);

__declspec(dllimport) BOOL __stdcall FreeImage_HasBackgroundColor(FIBITMAP *dib);
__declspec(dllimport) BOOL __stdcall FreeImage_GetBackgroundColor(FIBITMAP *dib, RGBQUAD *bkcolor);
__declspec(dllimport) BOOL __stdcall FreeImage_SetBackgroundColor(FIBITMAP *dib, RGBQUAD *bkcolor);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_GetThumbnail(FIBITMAP *dib);
__declspec(dllimport) BOOL __stdcall FreeImage_SetThumbnail(FIBITMAP *dib, FIBITMAP *thumbnail);



__declspec(dllimport) FIICCPROFILE *__stdcall FreeImage_GetICCProfile(FIBITMAP *dib);
__declspec(dllimport) FIICCPROFILE *__stdcall FreeImage_CreateICCProfile(FIBITMAP *dib, void *data, long size);
__declspec(dllimport) void __stdcall FreeImage_DestroyICCProfile(FIBITMAP *dib);



__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To4(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine8To4(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To4_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To4_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine24To4(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine32To4(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To8(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine4To8(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To8_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To8_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine24To8(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine32To8(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine4To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine8To16_555(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16_565_To16_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine24To16_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine32To16_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine4To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine8To16_565(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16_555_To16_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine24To16_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine32To16_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine4To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine8To24(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To24_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To24_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine32To24(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine1To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine4To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine8To32(BYTE *target, BYTE *source, int width_in_pixels, RGBQUAD *palette);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To32_555(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine16To32_565(BYTE *target, BYTE *source, int width_in_pixels);
__declspec(dllimport) void __stdcall FreeImage_ConvertLine24To32(BYTE *target, BYTE *source, int width_in_pixels);



__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo4Bits(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo8Bits(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToGreyscale(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo16Bits555(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo16Bits565(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo24Bits(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertTo32Bits(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ColorQuantize(FIBITMAP *dib, FREE_IMAGE_QUANTIZE quantize);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ColorQuantizeEx(FIBITMAP *dib, FREE_IMAGE_QUANTIZE quantize = FIQ_WUQUANT, int PaletteSize = 256, int ReserveSize = 0, RGBQUAD *ReservePalette = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Threshold(FIBITMAP *dib, BYTE T);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Dither(FIBITMAP *dib, FREE_IMAGE_DITHER algorithm);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertFromRawBits(BYTE *bits, int width, int height, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertFromRawBitsEx(BOOL copySource, BYTE *bits, FREE_IMAGE_TYPE type, int width, int height, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown = 0);
__declspec(dllimport) void __stdcall FreeImage_ConvertToRawBits(BYTE *bits, FIBITMAP *dib, int pitch, unsigned bpp, unsigned red_mask, unsigned green_mask, unsigned blue_mask, BOOL topdown = 0);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToFloat(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToRGBF(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToRGBAF(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToUINT16(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToRGB16(FIBITMAP *dib);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToRGBA16(FIBITMAP *dib);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToStandardType(FIBITMAP *src, BOOL scale_linear = 1);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ConvertToType(FIBITMAP *src, FREE_IMAGE_TYPE dst_type, BOOL scale_linear = 1);



__declspec(dllimport) FIBITMAP *__stdcall FreeImage_ToneMapping(FIBITMAP *dib, FREE_IMAGE_TMO tmo, double first_param = 0, double second_param = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_TmoDrago03(FIBITMAP *src, double gamma = 2.2, double exposure = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_TmoReinhard05(FIBITMAP *src, double intensity = 0, double contrast = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_TmoReinhard05Ex(FIBITMAP *src, double intensity = 0, double contrast = 0, double adaptation = 1, double color_correction = 0);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_TmoFattal02(FIBITMAP *src, double color_saturation = 0.5, double attenuation = 0.85);



__declspec(dllimport) DWORD __stdcall FreeImage_ZLibCompress(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);
__declspec(dllimport) DWORD __stdcall FreeImage_ZLibUncompress(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);
__declspec(dllimport) DWORD __stdcall FreeImage_ZLibGZip(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);
__declspec(dllimport) DWORD __stdcall FreeImage_ZLibGUnzip(BYTE *target, DWORD target_size, BYTE *source, DWORD source_size);
__declspec(dllimport) DWORD __stdcall FreeImage_ZLibCRC32(DWORD crc, BYTE *source, DWORD source_size);






__declspec(dllimport) FITAG *__stdcall FreeImage_CreateTag(void);
__declspec(dllimport) void __stdcall FreeImage_DeleteTag(FITAG *tag);
__declspec(dllimport) FITAG *__stdcall FreeImage_CloneTag(FITAG *tag);


__declspec(dllimport) const char *__stdcall FreeImage_GetTagKey(FITAG *tag);
__declspec(dllimport) const char *__stdcall FreeImage_GetTagDescription(FITAG *tag);
__declspec(dllimport) WORD __stdcall FreeImage_GetTagID(FITAG *tag);
__declspec(dllimport) FREE_IMAGE_MDTYPE __stdcall FreeImage_GetTagType(FITAG *tag);
__declspec(dllimport) DWORD __stdcall FreeImage_GetTagCount(FITAG *tag);
__declspec(dllimport) DWORD __stdcall FreeImage_GetTagLength(FITAG *tag);
__declspec(dllimport) const void *__stdcall FreeImage_GetTagValue(FITAG *tag);

__declspec(dllimport) BOOL __stdcall FreeImage_SetTagKey(FITAG *tag, const char *key);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagDescription(FITAG *tag, const char *description);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagID(FITAG *tag, WORD id);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagType(FITAG *tag, FREE_IMAGE_MDTYPE type);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagCount(FITAG *tag, DWORD count);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagLength(FITAG *tag, DWORD length);
__declspec(dllimport) BOOL __stdcall FreeImage_SetTagValue(FITAG *tag, const void *value);


__declspec(dllimport) FIMETADATA *__stdcall FreeImage_FindFirstMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, FITAG **tag);
__declspec(dllimport) BOOL __stdcall FreeImage_FindNextMetadata(FIMETADATA *mdhandle, FITAG **tag);
__declspec(dllimport) void __stdcall FreeImage_FindCloseMetadata(FIMETADATA *mdhandle);


__declspec(dllimport) BOOL __stdcall FreeImage_SetMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, FITAG *tag);
__declspec(dllimport) BOOL __stdcall FreeImage_GetMetadata(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, FITAG **tag);
__declspec(dllimport) BOOL __stdcall FreeImage_SetMetadataKeyValue(FREE_IMAGE_MDMODEL model, FIBITMAP *dib, const char *key, const char *value);


__declspec(dllimport) unsigned __stdcall FreeImage_GetMetadataCount(FREE_IMAGE_MDMODEL model, FIBITMAP *dib);
__declspec(dllimport) BOOL __stdcall FreeImage_CloneMetadata(FIBITMAP *dst, FIBITMAP *src);


__declspec(dllimport) const char* __stdcall FreeImage_TagToString(FREE_IMAGE_MDMODEL model, FITAG *tag, char *Make = 0);





__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransform(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect = 1);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransformU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, BOOL perfect = 1);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGCrop(const char *src_file, const char *dst_file, int left, int top, int right, int bottom);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGCropU(const wchar_t *src_file, const wchar_t *dst_file, int left, int top, int right, int bottom);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransformFromHandle(FreeImageIO* src_io, fi_handle src_handle, FreeImageIO* dst_io, fi_handle dst_handle, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect = 1);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransformCombined(const char *src_file, const char *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect = 1);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransformCombinedU(const wchar_t *src_file, const wchar_t *dst_file, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect = 1);
__declspec(dllimport) BOOL __stdcall FreeImage_JPEGTransformCombinedFromMemory(FIMEMORY* src_stream, FIMEMORY* dst_stream, FREE_IMAGE_JPEG_OPERATION operation, int* left, int* top, int* right, int* bottom, BOOL perfect = 1);








__declspec(dllimport) FIBITMAP *__stdcall FreeImage_RotateClassic(FIBITMAP *dib, double angle);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Rotate(FIBITMAP *dib, double angle, const void *bkcolor = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_RotateEx(FIBITMAP *dib, double angle, double x_shift, double y_shift, double x_origin, double y_origin, BOOL use_mask);
__declspec(dllimport) BOOL __stdcall FreeImage_FlipHorizontal(FIBITMAP *dib);
__declspec(dllimport) BOOL __stdcall FreeImage_FlipVertical(FIBITMAP *dib);


__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Rescale(FIBITMAP *dib, int dst_width, int dst_height, FREE_IMAGE_FILTER filter = FILTER_CATMULLROM);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_MakeThumbnail(FIBITMAP *dib, int max_pixel_size, BOOL convert = 1);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_RescaleRect(FIBITMAP *dib, int dst_width, int dst_height, int left, int top, int right, int bottom, FREE_IMAGE_FILTER filter = FILTER_CATMULLROM, unsigned flags = 0);


__declspec(dllimport) BOOL __stdcall FreeImage_AdjustCurve(FIBITMAP *dib, BYTE *LUT, FREE_IMAGE_COLOR_CHANNEL channel);
__declspec(dllimport) BOOL __stdcall FreeImage_AdjustGamma(FIBITMAP *dib, double gamma);
__declspec(dllimport) BOOL __stdcall FreeImage_AdjustBrightness(FIBITMAP *dib, double percentage);
__declspec(dllimport) BOOL __stdcall FreeImage_AdjustContrast(FIBITMAP *dib, double percentage);
__declspec(dllimport) BOOL __stdcall FreeImage_Invert(FIBITMAP *dib);
__declspec(dllimport) BOOL __stdcall FreeImage_GetHistogram(FIBITMAP *dib, DWORD *histo, FREE_IMAGE_COLOR_CHANNEL channel = FICC_BLACK);
__declspec(dllimport) int __stdcall FreeImage_GetAdjustColorsLookupTable(BYTE *LUT, double brightness, double contrast, double gamma, BOOL invert);
__declspec(dllimport) BOOL __stdcall FreeImage_AdjustColors(FIBITMAP *dib, double brightness, double contrast, double gamma, BOOL invert = 0);
__declspec(dllimport) unsigned __stdcall FreeImage_ApplyColorMapping(FIBITMAP *dib, RGBQUAD *srccolors, RGBQUAD *dstcolors, unsigned count, BOOL ignore_alpha, BOOL swap);
__declspec(dllimport) unsigned __stdcall FreeImage_SwapColors(FIBITMAP *dib, RGBQUAD *color_a, RGBQUAD *color_b, BOOL ignore_alpha);
__declspec(dllimport) unsigned __stdcall FreeImage_ApplyPaletteIndexMapping(FIBITMAP *dib, BYTE *srcindices,	BYTE *dstindices, unsigned count, BOOL swap);
__declspec(dllimport) unsigned __stdcall FreeImage_SwapPaletteIndices(FIBITMAP *dib, BYTE *index_a, BYTE *index_b);


__declspec(dllimport) FIBITMAP *__stdcall FreeImage_GetChannel(FIBITMAP *dib, FREE_IMAGE_COLOR_CHANNEL channel);
__declspec(dllimport) BOOL __stdcall FreeImage_SetChannel(FIBITMAP *dst, FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_GetComplexChannel(FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);
__declspec(dllimport) BOOL __stdcall FreeImage_SetComplexChannel(FIBITMAP *dst, FIBITMAP *src, FREE_IMAGE_COLOR_CHANNEL channel);


__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Copy(FIBITMAP *dib, int left, int top, int right, int bottom);
__declspec(dllimport) BOOL __stdcall FreeImage_Paste(FIBITMAP *dst, FIBITMAP *src, int left, int top, int alpha);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_CreateView(FIBITMAP *dib, unsigned left, unsigned top, unsigned right, unsigned bottom);

__declspec(dllimport) FIBITMAP *__stdcall FreeImage_Composite(FIBITMAP *fg, BOOL useFileBkg = 0, RGBQUAD *appBkColor = 0, FIBITMAP *bg = 0);
__declspec(dllimport) BOOL __stdcall FreeImage_PreMultiplyWithAlpha(FIBITMAP *dib);


__declspec(dllimport) BOOL __stdcall FreeImage_FillBackground(FIBITMAP *dib, const void *color, int options = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_EnlargeCanvas(FIBITMAP *src, int left, int top, int right, int bottom, const void *color, int options = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_AllocateEx(int width, int height, int bpp, const RGBQUAD *color, int options = 0, const RGBQUAD *palette = 0, unsigned red_mask = 0, unsigned green_mask = 0, unsigned blue_mask = 0);
__declspec(dllimport) FIBITMAP *__stdcall FreeImage_AllocateExT(FREE_IMAGE_TYPE type, int width, int height, int bpp, const void *color, int options = 0, const RGBQUAD *palette = 0, unsigned red_mask = 0, unsigned green_mask = 0, unsigned blue_mask = 0);


__declspec(dllimport) FIBITMAP *__stdcall FreeImage_MultigridPoissonSolver(FIBITMAP *Laplacian, int ncycle = 3);




#line 1148 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"


}
#line 1152 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

#line 1154 "e:\\uni\\spork backup 24.10.17\\sporkengine\\dependencies\\freeimage\\include\\freeimage.h"

#line 3 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\utils\\imageloader.h"


namespace spork {
	
	static BYTE* load_image(const char* filename, GLsizei* width, GLsizei* height)
	{
		FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;
		FIBITMAP *dib = nullptr;
		fif = FreeImage_GetFileType(filename, 0);
		
		if (fif == FIF_UNKNOWN)
			fif = FreeImage_GetFIFFromFilename(filename);
		
		if (fif == FIF_UNKNOWN)
			return nullptr;

		
		if (FreeImage_FIFSupportsReading(fif))
			dib = FreeImage_Load(fif, filename);
		
		if (!dib)
			return nullptr;

		BYTE* result = FreeImage_GetBits(dib);
		*width = FreeImage_GetWidth(dib);
		*height = FreeImage_GetHeight(dib);

		return result;
	}

}
#line 5 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\texture.h"

namespace spork { namespace graphics {

	class Texture
	{
	private:
		std::string m_FileName;
		GLuint m_TexID;
		GLsizei m_Width, m_Height;

	public:
		Texture(const std::string& filename);
		~Texture();
		void bind() const;
		void unbind() const;

		inline unsigned int getID() const { return m_TexID; }
		inline unsigned int getWidth() const { return m_Width; }
		inline unsigned int getHeight() const { return m_Height; }
	private:
		GLuint load();
	};

} }
#line 8 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"
#line 1 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderer2d.h"
#pragma once




namespace spork { namespace graphics {
	using namespace maths;
	class Renderable2D;

	class Renderer2D
	{
	protected:
		std::vector<mat4> m_TransformationStack;
		const mat4* m_TransformationBack;
	protected:
		Renderer2D()
		{
			m_TransformationStack.push_back(mat4::identity());
			m_TransformationBack = &m_TransformationStack.back();
		};
	public:
		void push(const maths::mat4& matrix, bool override = false)
		{
			if (override)
				m_TransformationStack.push_back(matrix);
			else
				m_TransformationStack.push_back(m_TransformationStack.back() * matrix);

			m_TransformationBack = &m_TransformationStack.back();
		};
		void pop()
		{
			if(m_TransformationStack.size() > 1)
				m_TransformationStack.pop_back();
			
			m_TransformationBack = &m_TransformationStack.back();
		}
		virtual void begin() {}
		virtual void submit(const Renderable2D* renderable) = 0;
		virtual void drawText(const std::string& text, const maths::vec3 pos, const maths::vec4& col) {}
		virtual void end() {}
		virtual void flush() = 0;
	};

} }
#line 9 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\renderers\\renderable2d.h"

namespace spork { namespace graphics {

	struct VertexData {
		maths::vec3 vertex;
		maths::vec2 uv;
		float texID;
		unsigned int color;
	};

	class Renderable2D
	{
	protected:
		maths::vec3 m_Position;
		maths::vec2 m_Size;
		std::vector<maths::vec2> m_UV;
		maths::vec4 m_Color;
		Texture* m_Texture;

	protected:
		Renderable2D() : m_Texture(nullptr) { initUVs(); }

	public:
		Renderable2D(maths::vec3 position, maths::vec2 size, maths::vec4 color)
			:m_Position(position), m_Size(size), m_Color(color), m_Texture(nullptr)
		{
			initUVs();
		}

		virtual ~Renderable2D()
		{}

		virtual void submit(Renderer2D* renderer) const
		{
			renderer->submit(this);
		}

		void initUVs()
		{
			m_UV.push_back(maths::vec2(0, 0));
			m_UV.push_back(maths::vec2(0, 1));
			m_UV.push_back(maths::vec2(1, 1));
			m_UV.push_back(maths::vec2(1, 0));
		}

		inline const maths::vec3& getPosition() const { return m_Position; }
		inline const maths::vec2& getSize() const { return m_Size; }
		inline const maths::vec4& getColor() const { return m_Color; }
		inline const std::vector<maths::vec2>& getUV() const { return m_UV; }
		inline const GLuint getTexID() const { return m_Texture ? m_Texture->getID() : 0; }	  
	};
} }
#line 3 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\textcontainer.h"

namespace spork { namespace graphics {
	
	class TextContainer : public Renderable2D
	{
	public:
		std::string text;
		maths::vec3& pos;
		float x, y;
	public:
		TextContainer(std::string text, float x, float y, maths::vec4 col);
		void submit(Renderer2D* renderer) const override;
	};
} }
#line 2 "e:\\uni\\spork backup 24.10.17\\sporkengine\\sporkcore\\src\\graphics\\textcontainer.cpp"

namespace spork { namespace graphics {

	TextContainer::TextContainer(std::string text, float x, float y, maths::vec4 col)
		: Renderable2D(), text(text), pos(m_Position)
	{
		m_Position = maths::vec3(x, y, 0.0f);
		m_Color = col;
	}

	void TextContainer::submit(Renderer2D* renderer) const
	{
		renderer->drawText(text, pos, m_Color);
	}
} }
